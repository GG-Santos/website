
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model Verification
 * 
 */
export type Verification = $Result.DefaultSelection<Prisma.$VerificationPayload>
/**
 * Model BlogPost
 * 
 */
export type BlogPost = $Result.DefaultSelection<Prisma.$BlogPostPayload>
/**
 * Model RoadmapItem
 * 
 */
export type RoadmapItem = $Result.DefaultSelection<Prisma.$RoadmapItemPayload>
/**
 * Model GameAsset
 * 
 */
export type GameAsset = $Result.DefaultSelection<Prisma.$GameAssetPayload>
/**
 * Model GameObjective
 * 
 */
export type GameObjective = $Result.DefaultSelection<Prisma.$GameObjectivePayload>
/**
 * Model Testimonial
 * 
 */
export type Testimonial = $Result.DefaultSelection<Prisma.$TestimonialPayload>
/**
 * Model SiteSettings
 * 
 */
export type SiteSettings = $Result.DefaultSelection<Prisma.$SiteSettingsPayload>
/**
 * Model Investor
 * 
 */
export type Investor = $Result.DefaultSelection<Prisma.$InvestorPayload>
/**
 * Model subject
 * 
 */
export type subject = $Result.DefaultSelection<Prisma.$subjectPayload>
/**
 * Model domain
 * 
 */
export type domain = $Result.DefaultSelection<Prisma.$domainPayload>
/**
 * Model consentPolicy
 * 
 */
export type consentPolicy = $Result.DefaultSelection<Prisma.$consentPolicyPayload>
/**
 * Model consentPurpose
 * 
 */
export type consentPurpose = $Result.DefaultSelection<Prisma.$consentPurposePayload>
/**
 * Model consent
 * 
 */
export type consent = $Result.DefaultSelection<Prisma.$consentPayload>
/**
 * Model auditLog
 * 
 */
export type auditLog = $Result.DefaultSelection<Prisma.$auditLogPayload>
/**
 * Model consentRecord
 * 
 */
export type consentRecord = $Result.DefaultSelection<Prisma.$consentRecordPayload>
/**
 * Model private_c15t_settings
 * 
 */
export type private_c15t_settings = $Result.DefaultSelection<Prisma.$private_c15t_settingsPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P]): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number }): $Utils.JsPromise<R>

  /**
   * Executes a raw MongoDB command and returns the result of it.
   * @example
   * ```
   * const user = await prisma.$runCommandRaw({
   *   aggregate: 'User',
   *   pipeline: [{ $match: { name: 'Bob' } }, { $project: { email: true, _id: false } }],
   *   explain: false,
   * })
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $runCommandRaw(command: Prisma.InputJsonObject): Prisma.PrismaPromise<Prisma.JsonObject>

  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.verification`: Exposes CRUD operations for the **Verification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Verifications
    * const verifications = await prisma.verification.findMany()
    * ```
    */
  get verification(): Prisma.VerificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.blogPost`: Exposes CRUD operations for the **BlogPost** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BlogPosts
    * const blogPosts = await prisma.blogPost.findMany()
    * ```
    */
  get blogPost(): Prisma.BlogPostDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.roadmapItem`: Exposes CRUD operations for the **RoadmapItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RoadmapItems
    * const roadmapItems = await prisma.roadmapItem.findMany()
    * ```
    */
  get roadmapItem(): Prisma.RoadmapItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.gameAsset`: Exposes CRUD operations for the **GameAsset** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GameAssets
    * const gameAssets = await prisma.gameAsset.findMany()
    * ```
    */
  get gameAsset(): Prisma.GameAssetDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.gameObjective`: Exposes CRUD operations for the **GameObjective** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GameObjectives
    * const gameObjectives = await prisma.gameObjective.findMany()
    * ```
    */
  get gameObjective(): Prisma.GameObjectiveDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.testimonial`: Exposes CRUD operations for the **Testimonial** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Testimonials
    * const testimonials = await prisma.testimonial.findMany()
    * ```
    */
  get testimonial(): Prisma.TestimonialDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.siteSettings`: Exposes CRUD operations for the **SiteSettings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SiteSettings
    * const siteSettings = await prisma.siteSettings.findMany()
    * ```
    */
  get siteSettings(): Prisma.SiteSettingsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.investor`: Exposes CRUD operations for the **Investor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Investors
    * const investors = await prisma.investor.findMany()
    * ```
    */
  get investor(): Prisma.InvestorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subject`: Exposes CRUD operations for the **subject** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subjects
    * const subjects = await prisma.subject.findMany()
    * ```
    */
  get subject(): Prisma.subjectDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.domain`: Exposes CRUD operations for the **domain** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Domains
    * const domains = await prisma.domain.findMany()
    * ```
    */
  get domain(): Prisma.domainDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.consentPolicy`: Exposes CRUD operations for the **consentPolicy** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ConsentPolicies
    * const consentPolicies = await prisma.consentPolicy.findMany()
    * ```
    */
  get consentPolicy(): Prisma.consentPolicyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.consentPurpose`: Exposes CRUD operations for the **consentPurpose** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ConsentPurposes
    * const consentPurposes = await prisma.consentPurpose.findMany()
    * ```
    */
  get consentPurpose(): Prisma.consentPurposeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.consent`: Exposes CRUD operations for the **consent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Consents
    * const consents = await prisma.consent.findMany()
    * ```
    */
  get consent(): Prisma.consentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **auditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.auditLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.consentRecord`: Exposes CRUD operations for the **consentRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ConsentRecords
    * const consentRecords = await prisma.consentRecord.findMany()
    * ```
    */
  get consentRecord(): Prisma.consentRecordDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.private_c15t_settings`: Exposes CRUD operations for the **private_c15t_settings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Private_c15t_settings
    * const private_c15t_settings = await prisma.private_c15t_settings.findMany()
    * ```
    */
  get private_c15t_settings(): Prisma.private_c15t_settingsDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.19.0
   * Query Engine version: 2ba551f319ab1df4bc874a89965d8b3641056773
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Session: 'Session',
    Account: 'Account',
    Verification: 'Verification',
    BlogPost: 'BlogPost',
    RoadmapItem: 'RoadmapItem',
    GameAsset: 'GameAsset',
    GameObjective: 'GameObjective',
    Testimonial: 'Testimonial',
    SiteSettings: 'SiteSettings',
    Investor: 'Investor',
    subject: 'subject',
    domain: 'domain',
    consentPolicy: 'consentPolicy',
    consentPurpose: 'consentPurpose',
    consent: 'consent',
    auditLog: 'auditLog',
    consentRecord: 'consentRecord',
    private_c15t_settings: 'private_c15t_settings'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "session" | "account" | "verification" | "blogPost" | "roadmapItem" | "gameAsset" | "gameObjective" | "testimonial" | "siteSettings" | "investor" | "subject" | "domain" | "consentPolicy" | "consentPurpose" | "consent" | "auditLog" | "consentRecord" | "private_c15t_settings"
      txIsolationLevel: never
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.UserFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.UserAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.SessionFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.SessionAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.AccountFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.AccountAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      Verification: {
        payload: Prisma.$VerificationPayload<ExtArgs>
        fields: Prisma.VerificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          findFirst: {
            args: Prisma.VerificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          findMany: {
            args: Prisma.VerificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>[]
          }
          create: {
            args: Prisma.VerificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          createMany: {
            args: Prisma.VerificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.VerificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          update: {
            args: Prisma.VerificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          deleteMany: {
            args: Prisma.VerificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VerificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          aggregate: {
            args: Prisma.VerificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerification>
          }
          groupBy: {
            args: Prisma.VerificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerificationGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.VerificationFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.VerificationAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.VerificationCountArgs<ExtArgs>
            result: $Utils.Optional<VerificationCountAggregateOutputType> | number
          }
        }
      }
      BlogPost: {
        payload: Prisma.$BlogPostPayload<ExtArgs>
        fields: Prisma.BlogPostFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BlogPostFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BlogPostFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>
          }
          findFirst: {
            args: Prisma.BlogPostFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BlogPostFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>
          }
          findMany: {
            args: Prisma.BlogPostFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>[]
          }
          create: {
            args: Prisma.BlogPostCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>
          }
          createMany: {
            args: Prisma.BlogPostCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BlogPostDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>
          }
          update: {
            args: Prisma.BlogPostUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>
          }
          deleteMany: {
            args: Prisma.BlogPostDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BlogPostUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BlogPostUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>
          }
          aggregate: {
            args: Prisma.BlogPostAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBlogPost>
          }
          groupBy: {
            args: Prisma.BlogPostGroupByArgs<ExtArgs>
            result: $Utils.Optional<BlogPostGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.BlogPostFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.BlogPostAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.BlogPostCountArgs<ExtArgs>
            result: $Utils.Optional<BlogPostCountAggregateOutputType> | number
          }
        }
      }
      RoadmapItem: {
        payload: Prisma.$RoadmapItemPayload<ExtArgs>
        fields: Prisma.RoadmapItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoadmapItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoadmapItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapItemPayload>
          }
          findFirst: {
            args: Prisma.RoadmapItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoadmapItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapItemPayload>
          }
          findMany: {
            args: Prisma.RoadmapItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapItemPayload>[]
          }
          create: {
            args: Prisma.RoadmapItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapItemPayload>
          }
          createMany: {
            args: Prisma.RoadmapItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.RoadmapItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapItemPayload>
          }
          update: {
            args: Prisma.RoadmapItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapItemPayload>
          }
          deleteMany: {
            args: Prisma.RoadmapItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoadmapItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RoadmapItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapItemPayload>
          }
          aggregate: {
            args: Prisma.RoadmapItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoadmapItem>
          }
          groupBy: {
            args: Prisma.RoadmapItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoadmapItemGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.RoadmapItemFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.RoadmapItemAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.RoadmapItemCountArgs<ExtArgs>
            result: $Utils.Optional<RoadmapItemCountAggregateOutputType> | number
          }
        }
      }
      GameAsset: {
        payload: Prisma.$GameAssetPayload<ExtArgs>
        fields: Prisma.GameAssetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GameAssetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameAssetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GameAssetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameAssetPayload>
          }
          findFirst: {
            args: Prisma.GameAssetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameAssetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GameAssetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameAssetPayload>
          }
          findMany: {
            args: Prisma.GameAssetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameAssetPayload>[]
          }
          create: {
            args: Prisma.GameAssetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameAssetPayload>
          }
          createMany: {
            args: Prisma.GameAssetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.GameAssetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameAssetPayload>
          }
          update: {
            args: Prisma.GameAssetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameAssetPayload>
          }
          deleteMany: {
            args: Prisma.GameAssetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GameAssetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.GameAssetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameAssetPayload>
          }
          aggregate: {
            args: Prisma.GameAssetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGameAsset>
          }
          groupBy: {
            args: Prisma.GameAssetGroupByArgs<ExtArgs>
            result: $Utils.Optional<GameAssetGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.GameAssetFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.GameAssetAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.GameAssetCountArgs<ExtArgs>
            result: $Utils.Optional<GameAssetCountAggregateOutputType> | number
          }
        }
      }
      GameObjective: {
        payload: Prisma.$GameObjectivePayload<ExtArgs>
        fields: Prisma.GameObjectiveFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GameObjectiveFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameObjectivePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GameObjectiveFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameObjectivePayload>
          }
          findFirst: {
            args: Prisma.GameObjectiveFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameObjectivePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GameObjectiveFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameObjectivePayload>
          }
          findMany: {
            args: Prisma.GameObjectiveFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameObjectivePayload>[]
          }
          create: {
            args: Prisma.GameObjectiveCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameObjectivePayload>
          }
          createMany: {
            args: Prisma.GameObjectiveCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.GameObjectiveDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameObjectivePayload>
          }
          update: {
            args: Prisma.GameObjectiveUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameObjectivePayload>
          }
          deleteMany: {
            args: Prisma.GameObjectiveDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GameObjectiveUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.GameObjectiveUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameObjectivePayload>
          }
          aggregate: {
            args: Prisma.GameObjectiveAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGameObjective>
          }
          groupBy: {
            args: Prisma.GameObjectiveGroupByArgs<ExtArgs>
            result: $Utils.Optional<GameObjectiveGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.GameObjectiveFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.GameObjectiveAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.GameObjectiveCountArgs<ExtArgs>
            result: $Utils.Optional<GameObjectiveCountAggregateOutputType> | number
          }
        }
      }
      Testimonial: {
        payload: Prisma.$TestimonialPayload<ExtArgs>
        fields: Prisma.TestimonialFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TestimonialFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestimonialPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TestimonialFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestimonialPayload>
          }
          findFirst: {
            args: Prisma.TestimonialFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestimonialPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TestimonialFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestimonialPayload>
          }
          findMany: {
            args: Prisma.TestimonialFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestimonialPayload>[]
          }
          create: {
            args: Prisma.TestimonialCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestimonialPayload>
          }
          createMany: {
            args: Prisma.TestimonialCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TestimonialDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestimonialPayload>
          }
          update: {
            args: Prisma.TestimonialUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestimonialPayload>
          }
          deleteMany: {
            args: Prisma.TestimonialDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TestimonialUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TestimonialUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestimonialPayload>
          }
          aggregate: {
            args: Prisma.TestimonialAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTestimonial>
          }
          groupBy: {
            args: Prisma.TestimonialGroupByArgs<ExtArgs>
            result: $Utils.Optional<TestimonialGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.TestimonialFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.TestimonialAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.TestimonialCountArgs<ExtArgs>
            result: $Utils.Optional<TestimonialCountAggregateOutputType> | number
          }
        }
      }
      SiteSettings: {
        payload: Prisma.$SiteSettingsPayload<ExtArgs>
        fields: Prisma.SiteSettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SiteSettingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteSettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SiteSettingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteSettingsPayload>
          }
          findFirst: {
            args: Prisma.SiteSettingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteSettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SiteSettingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteSettingsPayload>
          }
          findMany: {
            args: Prisma.SiteSettingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteSettingsPayload>[]
          }
          create: {
            args: Prisma.SiteSettingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteSettingsPayload>
          }
          createMany: {
            args: Prisma.SiteSettingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SiteSettingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteSettingsPayload>
          }
          update: {
            args: Prisma.SiteSettingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteSettingsPayload>
          }
          deleteMany: {
            args: Prisma.SiteSettingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SiteSettingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SiteSettingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteSettingsPayload>
          }
          aggregate: {
            args: Prisma.SiteSettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSiteSettings>
          }
          groupBy: {
            args: Prisma.SiteSettingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SiteSettingsGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.SiteSettingsFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.SiteSettingsAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.SiteSettingsCountArgs<ExtArgs>
            result: $Utils.Optional<SiteSettingsCountAggregateOutputType> | number
          }
        }
      }
      Investor: {
        payload: Prisma.$InvestorPayload<ExtArgs>
        fields: Prisma.InvestorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvestorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvestorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestorPayload>
          }
          findFirst: {
            args: Prisma.InvestorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvestorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestorPayload>
          }
          findMany: {
            args: Prisma.InvestorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestorPayload>[]
          }
          create: {
            args: Prisma.InvestorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestorPayload>
          }
          createMany: {
            args: Prisma.InvestorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.InvestorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestorPayload>
          }
          update: {
            args: Prisma.InvestorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestorPayload>
          }
          deleteMany: {
            args: Prisma.InvestorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvestorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InvestorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestorPayload>
          }
          aggregate: {
            args: Prisma.InvestorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvestor>
          }
          groupBy: {
            args: Prisma.InvestorGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvestorGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.InvestorFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.InvestorAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.InvestorCountArgs<ExtArgs>
            result: $Utils.Optional<InvestorCountAggregateOutputType> | number
          }
        }
      }
      subject: {
        payload: Prisma.$subjectPayload<ExtArgs>
        fields: Prisma.subjectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.subjectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subjectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.subjectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subjectPayload>
          }
          findFirst: {
            args: Prisma.subjectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subjectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.subjectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subjectPayload>
          }
          findMany: {
            args: Prisma.subjectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subjectPayload>[]
          }
          create: {
            args: Prisma.subjectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subjectPayload>
          }
          createMany: {
            args: Prisma.subjectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.subjectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subjectPayload>
          }
          update: {
            args: Prisma.subjectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subjectPayload>
          }
          deleteMany: {
            args: Prisma.subjectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.subjectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.subjectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subjectPayload>
          }
          aggregate: {
            args: Prisma.SubjectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubject>
          }
          groupBy: {
            args: Prisma.subjectGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubjectGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.subjectFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.subjectAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.subjectCountArgs<ExtArgs>
            result: $Utils.Optional<SubjectCountAggregateOutputType> | number
          }
        }
      }
      domain: {
        payload: Prisma.$domainPayload<ExtArgs>
        fields: Prisma.domainFieldRefs
        operations: {
          findUnique: {
            args: Prisma.domainFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$domainPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.domainFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$domainPayload>
          }
          findFirst: {
            args: Prisma.domainFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$domainPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.domainFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$domainPayload>
          }
          findMany: {
            args: Prisma.domainFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$domainPayload>[]
          }
          create: {
            args: Prisma.domainCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$domainPayload>
          }
          createMany: {
            args: Prisma.domainCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.domainDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$domainPayload>
          }
          update: {
            args: Prisma.domainUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$domainPayload>
          }
          deleteMany: {
            args: Prisma.domainDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.domainUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.domainUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$domainPayload>
          }
          aggregate: {
            args: Prisma.DomainAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDomain>
          }
          groupBy: {
            args: Prisma.domainGroupByArgs<ExtArgs>
            result: $Utils.Optional<DomainGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.domainFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.domainAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.domainCountArgs<ExtArgs>
            result: $Utils.Optional<DomainCountAggregateOutputType> | number
          }
        }
      }
      consentPolicy: {
        payload: Prisma.$consentPolicyPayload<ExtArgs>
        fields: Prisma.consentPolicyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.consentPolicyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consentPolicyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.consentPolicyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consentPolicyPayload>
          }
          findFirst: {
            args: Prisma.consentPolicyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consentPolicyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.consentPolicyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consentPolicyPayload>
          }
          findMany: {
            args: Prisma.consentPolicyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consentPolicyPayload>[]
          }
          create: {
            args: Prisma.consentPolicyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consentPolicyPayload>
          }
          createMany: {
            args: Prisma.consentPolicyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.consentPolicyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consentPolicyPayload>
          }
          update: {
            args: Prisma.consentPolicyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consentPolicyPayload>
          }
          deleteMany: {
            args: Prisma.consentPolicyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.consentPolicyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.consentPolicyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consentPolicyPayload>
          }
          aggregate: {
            args: Prisma.ConsentPolicyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConsentPolicy>
          }
          groupBy: {
            args: Prisma.consentPolicyGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConsentPolicyGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.consentPolicyFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.consentPolicyAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.consentPolicyCountArgs<ExtArgs>
            result: $Utils.Optional<ConsentPolicyCountAggregateOutputType> | number
          }
        }
      }
      consentPurpose: {
        payload: Prisma.$consentPurposePayload<ExtArgs>
        fields: Prisma.consentPurposeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.consentPurposeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consentPurposePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.consentPurposeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consentPurposePayload>
          }
          findFirst: {
            args: Prisma.consentPurposeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consentPurposePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.consentPurposeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consentPurposePayload>
          }
          findMany: {
            args: Prisma.consentPurposeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consentPurposePayload>[]
          }
          create: {
            args: Prisma.consentPurposeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consentPurposePayload>
          }
          createMany: {
            args: Prisma.consentPurposeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.consentPurposeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consentPurposePayload>
          }
          update: {
            args: Prisma.consentPurposeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consentPurposePayload>
          }
          deleteMany: {
            args: Prisma.consentPurposeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.consentPurposeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.consentPurposeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consentPurposePayload>
          }
          aggregate: {
            args: Prisma.ConsentPurposeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConsentPurpose>
          }
          groupBy: {
            args: Prisma.consentPurposeGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConsentPurposeGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.consentPurposeFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.consentPurposeAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.consentPurposeCountArgs<ExtArgs>
            result: $Utils.Optional<ConsentPurposeCountAggregateOutputType> | number
          }
        }
      }
      consent: {
        payload: Prisma.$consentPayload<ExtArgs>
        fields: Prisma.consentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.consentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.consentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consentPayload>
          }
          findFirst: {
            args: Prisma.consentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.consentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consentPayload>
          }
          findMany: {
            args: Prisma.consentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consentPayload>[]
          }
          create: {
            args: Prisma.consentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consentPayload>
          }
          createMany: {
            args: Prisma.consentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.consentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consentPayload>
          }
          update: {
            args: Prisma.consentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consentPayload>
          }
          deleteMany: {
            args: Prisma.consentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.consentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.consentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consentPayload>
          }
          aggregate: {
            args: Prisma.ConsentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConsent>
          }
          groupBy: {
            args: Prisma.consentGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConsentGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.consentFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.consentAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.consentCountArgs<ExtArgs>
            result: $Utils.Optional<ConsentCountAggregateOutputType> | number
          }
        }
      }
      auditLog: {
        payload: Prisma.$auditLogPayload<ExtArgs>
        fields: Prisma.auditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.auditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.auditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auditLogPayload>
          }
          findFirst: {
            args: Prisma.auditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.auditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auditLogPayload>
          }
          findMany: {
            args: Prisma.auditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auditLogPayload>[]
          }
          create: {
            args: Prisma.auditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auditLogPayload>
          }
          createMany: {
            args: Prisma.auditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.auditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auditLogPayload>
          }
          update: {
            args: Prisma.auditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auditLogPayload>
          }
          deleteMany: {
            args: Prisma.auditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.auditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.auditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.auditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.auditLogFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.auditLogAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.auditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
      consentRecord: {
        payload: Prisma.$consentRecordPayload<ExtArgs>
        fields: Prisma.consentRecordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.consentRecordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consentRecordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.consentRecordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consentRecordPayload>
          }
          findFirst: {
            args: Prisma.consentRecordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consentRecordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.consentRecordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consentRecordPayload>
          }
          findMany: {
            args: Prisma.consentRecordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consentRecordPayload>[]
          }
          create: {
            args: Prisma.consentRecordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consentRecordPayload>
          }
          createMany: {
            args: Prisma.consentRecordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.consentRecordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consentRecordPayload>
          }
          update: {
            args: Prisma.consentRecordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consentRecordPayload>
          }
          deleteMany: {
            args: Prisma.consentRecordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.consentRecordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.consentRecordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consentRecordPayload>
          }
          aggregate: {
            args: Prisma.ConsentRecordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConsentRecord>
          }
          groupBy: {
            args: Prisma.consentRecordGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConsentRecordGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.consentRecordFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.consentRecordAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.consentRecordCountArgs<ExtArgs>
            result: $Utils.Optional<ConsentRecordCountAggregateOutputType> | number
          }
        }
      }
      private_c15t_settings: {
        payload: Prisma.$private_c15t_settingsPayload<ExtArgs>
        fields: Prisma.private_c15t_settingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.private_c15t_settingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$private_c15t_settingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.private_c15t_settingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$private_c15t_settingsPayload>
          }
          findFirst: {
            args: Prisma.private_c15t_settingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$private_c15t_settingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.private_c15t_settingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$private_c15t_settingsPayload>
          }
          findMany: {
            args: Prisma.private_c15t_settingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$private_c15t_settingsPayload>[]
          }
          create: {
            args: Prisma.private_c15t_settingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$private_c15t_settingsPayload>
          }
          createMany: {
            args: Prisma.private_c15t_settingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.private_c15t_settingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$private_c15t_settingsPayload>
          }
          update: {
            args: Prisma.private_c15t_settingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$private_c15t_settingsPayload>
          }
          deleteMany: {
            args: Prisma.private_c15t_settingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.private_c15t_settingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.private_c15t_settingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$private_c15t_settingsPayload>
          }
          aggregate: {
            args: Prisma.Private_c15t_settingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePrivate_c15t_settings>
          }
          groupBy: {
            args: Prisma.private_c15t_settingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Private_c15t_settingsGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.private_c15t_settingsFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.private_c15t_settingsAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.private_c15t_settingsCountArgs<ExtArgs>
            result: $Utils.Optional<Private_c15t_settingsCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $runCommandRaw: {
          args: Prisma.InputJsonObject,
          result: Prisma.JsonObject
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    session?: SessionOmit
    account?: AccountOmit
    verification?: VerificationOmit
    blogPost?: BlogPostOmit
    roadmapItem?: RoadmapItemOmit
    gameAsset?: GameAssetOmit
    gameObjective?: GameObjectiveOmit
    testimonial?: TestimonialOmit
    siteSettings?: SiteSettingsOmit
    investor?: InvestorOmit
    subject?: subjectOmit
    domain?: domainOmit
    consentPolicy?: consentPolicyOmit
    consentPurpose?: consentPurposeOmit
    consent?: consentOmit
    auditLog?: auditLogOmit
    consentRecord?: consentRecordOmit
    private_c15t_settings?: private_c15t_settingsOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    sessions: number
    accounts: number
    blogPosts: number
    roadmapItems: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    accounts?: boolean | UserCountOutputTypeCountAccountsArgs
    blogPosts?: boolean | UserCountOutputTypeCountBlogPostsArgs
    roadmapItems?: boolean | UserCountOutputTypeCountRoadmapItemsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBlogPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlogPostWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRoadmapItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoadmapItemWhereInput
  }


  /**
   * Count Type SubjectCountOutputType
   */

  export type SubjectCountOutputType = {
    consents: number
    consentRecords: number
    auditLogs: number
  }

  export type SubjectCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    consents?: boolean | SubjectCountOutputTypeCountConsentsArgs
    consentRecords?: boolean | SubjectCountOutputTypeCountConsentRecordsArgs
    auditLogs?: boolean | SubjectCountOutputTypeCountAuditLogsArgs
  }

  // Custom InputTypes
  /**
   * SubjectCountOutputType without action
   */
  export type SubjectCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubjectCountOutputType
     */
    select?: SubjectCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SubjectCountOutputType without action
   */
  export type SubjectCountOutputTypeCountConsentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: consentWhereInput
  }

  /**
   * SubjectCountOutputType without action
   */
  export type SubjectCountOutputTypeCountConsentRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: consentRecordWhereInput
  }

  /**
   * SubjectCountOutputType without action
   */
  export type SubjectCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: auditLogWhereInput
  }


  /**
   * Count Type DomainCountOutputType
   */

  export type DomainCountOutputType = {
    consents: number
  }

  export type DomainCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    consents?: boolean | DomainCountOutputTypeCountConsentsArgs
  }

  // Custom InputTypes
  /**
   * DomainCountOutputType without action
   */
  export type DomainCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainCountOutputType
     */
    select?: DomainCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DomainCountOutputType without action
   */
  export type DomainCountOutputTypeCountConsentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: consentWhereInput
  }


  /**
   * Count Type ConsentPolicyCountOutputType
   */

  export type ConsentPolicyCountOutputType = {
    consents: number
  }

  export type ConsentPolicyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    consents?: boolean | ConsentPolicyCountOutputTypeCountConsentsArgs
  }

  // Custom InputTypes
  /**
   * ConsentPolicyCountOutputType without action
   */
  export type ConsentPolicyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsentPolicyCountOutputType
     */
    select?: ConsentPolicyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ConsentPolicyCountOutputType without action
   */
  export type ConsentPolicyCountOutputTypeCountConsentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: consentWhereInput
  }


  /**
   * Count Type ConsentCountOutputType
   */

  export type ConsentCountOutputType = {
    consentRecords: number
  }

  export type ConsentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    consentRecords?: boolean | ConsentCountOutputTypeCountConsentRecordsArgs
  }

  // Custom InputTypes
  /**
   * ConsentCountOutputType without action
   */
  export type ConsentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsentCountOutputType
     */
    select?: ConsentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ConsentCountOutputType without action
   */
  export type ConsentCountOutputTypeCountConsentRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: consentRecordWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    emailVerified: boolean | null
    image: string | null
    bio: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    emailVerified: boolean | null
    image: string | null
    bio: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    emailVerified: number
    image: number
    bio: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    bio?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    bio?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    bio?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image: string | null
    bio: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    bio?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    accounts?: boolean | User$accountsArgs<ExtArgs>
    blogPosts?: boolean | User$blogPostsArgs<ExtArgs>
    roadmapItems?: boolean | User$roadmapItemsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>



  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    bio?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "emailVerified" | "image" | "bio" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    accounts?: boolean | User$accountsArgs<ExtArgs>
    blogPosts?: boolean | User$blogPostsArgs<ExtArgs>
    roadmapItems?: boolean | User$roadmapItemsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      accounts: Prisma.$AccountPayload<ExtArgs>[]
      blogPosts: Prisma.$BlogPostPayload<ExtArgs>[]
      roadmapItems: Prisma.$RoadmapItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string
      emailVerified: boolean
      image: string | null
      bio: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * @param {UserFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const user = await prisma.user.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: UserFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a User.
     * @param {UserAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const user = await prisma.user.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: UserAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    accounts<T extends User$accountsArgs<ExtArgs> = {}>(args?: Subset<T, User$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    blogPosts<T extends User$blogPostsArgs<ExtArgs> = {}>(args?: Subset<T, User$blogPostsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    roadmapItems<T extends User$roadmapItemsArgs<ExtArgs> = {}>(args?: Subset<T, User$roadmapItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoadmapItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly emailVerified: FieldRef<"User", 'Boolean'>
    readonly image: FieldRef<"User", 'String'>
    readonly bio: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User findRaw
   */
  export type UserFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * User aggregateRaw
   */
  export type UserAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User.accounts
   */
  export type User$accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * User.blogPosts
   */
  export type User$blogPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPost
     */
    omit?: BlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    where?: BlogPostWhereInput
    orderBy?: BlogPostOrderByWithRelationInput | BlogPostOrderByWithRelationInput[]
    cursor?: BlogPostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BlogPostScalarFieldEnum | BlogPostScalarFieldEnum[]
  }

  /**
   * User.roadmapItems
   */
  export type User$roadmapItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapItem
     */
    select?: RoadmapItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoadmapItem
     */
    omit?: RoadmapItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapItemInclude<ExtArgs> | null
    where?: RoadmapItemWhereInput
    orderBy?: RoadmapItemOrderByWithRelationInput | RoadmapItemOrderByWithRelationInput[]
    cursor?: RoadmapItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoadmapItemScalarFieldEnum | RoadmapItemScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    expiresAt: Date | null
    token: string | null
    createdAt: Date | null
    updatedAt: Date | null
    ipAddress: string | null
    userAgent: string | null
    userId: string | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    expiresAt: Date | null
    token: string | null
    createdAt: Date | null
    updatedAt: Date | null
    ipAddress: string | null
    userAgent: string | null
    userId: string | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    expiresAt: number
    token: number
    createdAt: number
    updatedAt: number
    ipAddress: number
    userAgent: number
    userId: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    expiresAt?: true
    token?: true
    createdAt?: true
    updatedAt?: true
    ipAddress?: true
    userAgent?: true
    userId?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    expiresAt?: true
    token?: true
    createdAt?: true
    updatedAt?: true
    ipAddress?: true
    userAgent?: true
    userId?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    expiresAt?: true
    token?: true
    createdAt?: true
    updatedAt?: true
    ipAddress?: true
    userAgent?: true
    userId?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    expiresAt: Date
    token: string
    createdAt: Date
    updatedAt: Date
    ipAddress: string | null
    userAgent: string | null
    userId: string
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    expiresAt?: boolean
    token?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>



  export type SessionSelectScalar = {
    id?: boolean
    expiresAt?: boolean
    token?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    userId?: boolean
  }

  export type SessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "expiresAt" | "token" | "createdAt" | "updatedAt" | "ipAddress" | "userAgent" | "userId", ExtArgs["result"]["session"]>
  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      expiresAt: Date
      token: string
      createdAt: Date
      updatedAt: Date
      ipAddress: string | null
      userAgent: string | null
      userId: string
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * @param {SessionFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const session = await prisma.session.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: SessionFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Session.
     * @param {SessionAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const session = await prisma.session.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: SessionAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly expiresAt: FieldRef<"Session", 'DateTime'>
    readonly token: FieldRef<"Session", 'String'>
    readonly createdAt: FieldRef<"Session", 'DateTime'>
    readonly updatedAt: FieldRef<"Session", 'DateTime'>
    readonly ipAddress: FieldRef<"Session", 'String'>
    readonly userAgent: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to delete.
     */
    limit?: number
  }

  /**
   * Session findRaw
   */
  export type SessionFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Session aggregateRaw
   */
  export type SessionAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    accountId: string | null
    providerId: string | null
    userId: string | null
    accessToken: string | null
    refreshToken: string | null
    idToken: string | null
    accessTokenExpiresAt: Date | null
    refreshTokenExpiresAt: Date | null
    scope: string | null
    password: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    accountId: string | null
    providerId: string | null
    userId: string | null
    accessToken: string | null
    refreshToken: string | null
    idToken: string | null
    accessTokenExpiresAt: Date | null
    refreshTokenExpiresAt: Date | null
    scope: string | null
    password: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    accountId: number
    providerId: number
    userId: number
    accessToken: number
    refreshToken: number
    idToken: number
    accessTokenExpiresAt: number
    refreshTokenExpiresAt: number
    scope: number
    password: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AccountMinAggregateInputType = {
    id?: true
    accountId?: true
    providerId?: true
    userId?: true
    accessToken?: true
    refreshToken?: true
    idToken?: true
    accessTokenExpiresAt?: true
    refreshTokenExpiresAt?: true
    scope?: true
    password?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    accountId?: true
    providerId?: true
    userId?: true
    accessToken?: true
    refreshToken?: true
    idToken?: true
    accessTokenExpiresAt?: true
    refreshTokenExpiresAt?: true
    scope?: true
    password?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    accountId?: true
    providerId?: true
    userId?: true
    accessToken?: true
    refreshToken?: true
    idToken?: true
    accessTokenExpiresAt?: true
    refreshTokenExpiresAt?: true
    scope?: true
    password?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: string
    accountId: string
    providerId: string
    userId: string
    accessToken: string | null
    refreshToken: string | null
    idToken: string | null
    accessTokenExpiresAt: Date | null
    refreshTokenExpiresAt: Date | null
    scope: string | null
    password: string | null
    createdAt: Date
    updatedAt: Date
    _count: AccountCountAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    providerId?: boolean
    userId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    idToken?: boolean
    accessTokenExpiresAt?: boolean
    refreshTokenExpiresAt?: boolean
    scope?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>



  export type AccountSelectScalar = {
    id?: boolean
    accountId?: boolean
    providerId?: boolean
    userId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    idToken?: boolean
    accessTokenExpiresAt?: boolean
    refreshTokenExpiresAt?: boolean
    scope?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "accountId" | "providerId" | "userId" | "accessToken" | "refreshToken" | "idToken" | "accessTokenExpiresAt" | "refreshTokenExpiresAt" | "scope" | "password" | "createdAt" | "updatedAt", ExtArgs["result"]["account"]>
  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      accountId: string
      providerId: string
      userId: string
      accessToken: string | null
      refreshToken: string | null
      idToken: string | null
      accessTokenExpiresAt: Date | null
      refreshTokenExpiresAt: Date | null
      scope: string | null
      password: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["account"]>
    composites: {}
  }

  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountFindManyArgs>(args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
     */
    create<T extends AccountCreateArgs>(args: SelectSubset<T, AccountCreateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountCreateManyArgs>(args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
     */
    delete<T extends AccountDeleteArgs>(args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountUpdateArgs>(args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountDeleteManyArgs>(args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountUpdateManyArgs>(args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Accounts that matches the filter.
     * @param {AccountFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const account = await prisma.account.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: AccountFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Account.
     * @param {AccountAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const account = await prisma.account.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: AccountAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Account model
   */
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", 'String'>
    readonly accountId: FieldRef<"Account", 'String'>
    readonly providerId: FieldRef<"Account", 'String'>
    readonly userId: FieldRef<"Account", 'String'>
    readonly accessToken: FieldRef<"Account", 'String'>
    readonly refreshToken: FieldRef<"Account", 'String'>
    readonly idToken: FieldRef<"Account", 'String'>
    readonly accessTokenExpiresAt: FieldRef<"Account", 'DateTime'>
    readonly refreshTokenExpiresAt: FieldRef<"Account", 'DateTime'>
    readonly scope: FieldRef<"Account", 'String'>
    readonly password: FieldRef<"Account", 'String'>
    readonly createdAt: FieldRef<"Account", 'DateTime'>
    readonly updatedAt: FieldRef<"Account", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
  }

  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
  }

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }

  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to delete.
     */
    limit?: number
  }

  /**
   * Account findRaw
   */
  export type AccountFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Account aggregateRaw
   */
  export type AccountAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
  }


  /**
   * Model Verification
   */

  export type AggregateVerification = {
    _count: VerificationCountAggregateOutputType | null
    _min: VerificationMinAggregateOutputType | null
    _max: VerificationMaxAggregateOutputType | null
  }

  export type VerificationMinAggregateOutputType = {
    id: string | null
    identifier: string | null
    value: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VerificationMaxAggregateOutputType = {
    id: string | null
    identifier: string | null
    value: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VerificationCountAggregateOutputType = {
    id: number
    identifier: number
    value: number
    expiresAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VerificationMinAggregateInputType = {
    id?: true
    identifier?: true
    value?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VerificationMaxAggregateInputType = {
    id?: true
    identifier?: true
    value?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VerificationCountAggregateInputType = {
    id?: true
    identifier?: true
    value?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VerificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Verification to aggregate.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Verifications
    **/
    _count?: true | VerificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerificationMaxAggregateInputType
  }

  export type GetVerificationAggregateType<T extends VerificationAggregateArgs> = {
        [P in keyof T & keyof AggregateVerification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerification[P]>
      : GetScalarType<T[P], AggregateVerification[P]>
  }




  export type VerificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerificationWhereInput
    orderBy?: VerificationOrderByWithAggregationInput | VerificationOrderByWithAggregationInput[]
    by: VerificationScalarFieldEnum[] | VerificationScalarFieldEnum
    having?: VerificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerificationCountAggregateInputType | true
    _min?: VerificationMinAggregateInputType
    _max?: VerificationMaxAggregateInputType
  }

  export type VerificationGroupByOutputType = {
    id: string
    identifier: string
    value: string
    expiresAt: Date
    createdAt: Date
    updatedAt: Date
    _count: VerificationCountAggregateOutputType | null
    _min: VerificationMinAggregateOutputType | null
    _max: VerificationMaxAggregateOutputType | null
  }

  type GetVerificationGroupByPayload<T extends VerificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerificationGroupByOutputType[P]>
            : GetScalarType<T[P], VerificationGroupByOutputType[P]>
        }
      >
    >


  export type VerificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["verification"]>



  export type VerificationSelectScalar = {
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VerificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "identifier" | "value" | "expiresAt" | "createdAt" | "updatedAt", ExtArgs["result"]["verification"]>

  export type $VerificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Verification"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      identifier: string
      value: string
      expiresAt: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["verification"]>
    composites: {}
  }

  type VerificationGetPayload<S extends boolean | null | undefined | VerificationDefaultArgs> = $Result.GetResult<Prisma.$VerificationPayload, S>

  type VerificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VerificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VerificationCountAggregateInputType | true
    }

  export interface VerificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Verification'], meta: { name: 'Verification' } }
    /**
     * Find zero or one Verification that matches the filter.
     * @param {VerificationFindUniqueArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerificationFindUniqueArgs>(args: SelectSubset<T, VerificationFindUniqueArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Verification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VerificationFindUniqueOrThrowArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerificationFindUniqueOrThrowArgs>(args: SelectSubset<T, VerificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Verification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationFindFirstArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerificationFindFirstArgs>(args?: SelectSubset<T, VerificationFindFirstArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Verification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationFindFirstOrThrowArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerificationFindFirstOrThrowArgs>(args?: SelectSubset<T, VerificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Verifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Verifications
     * const verifications = await prisma.verification.findMany()
     * 
     * // Get first 10 Verifications
     * const verifications = await prisma.verification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const verificationWithIdOnly = await prisma.verification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VerificationFindManyArgs>(args?: SelectSubset<T, VerificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Verification.
     * @param {VerificationCreateArgs} args - Arguments to create a Verification.
     * @example
     * // Create one Verification
     * const Verification = await prisma.verification.create({
     *   data: {
     *     // ... data to create a Verification
     *   }
     * })
     * 
     */
    create<T extends VerificationCreateArgs>(args: SelectSubset<T, VerificationCreateArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Verifications.
     * @param {VerificationCreateManyArgs} args - Arguments to create many Verifications.
     * @example
     * // Create many Verifications
     * const verification = await prisma.verification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerificationCreateManyArgs>(args?: SelectSubset<T, VerificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Verification.
     * @param {VerificationDeleteArgs} args - Arguments to delete one Verification.
     * @example
     * // Delete one Verification
     * const Verification = await prisma.verification.delete({
     *   where: {
     *     // ... filter to delete one Verification
     *   }
     * })
     * 
     */
    delete<T extends VerificationDeleteArgs>(args: SelectSubset<T, VerificationDeleteArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Verification.
     * @param {VerificationUpdateArgs} args - Arguments to update one Verification.
     * @example
     * // Update one Verification
     * const verification = await prisma.verification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerificationUpdateArgs>(args: SelectSubset<T, VerificationUpdateArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Verifications.
     * @param {VerificationDeleteManyArgs} args - Arguments to filter Verifications to delete.
     * @example
     * // Delete a few Verifications
     * const { count } = await prisma.verification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerificationDeleteManyArgs>(args?: SelectSubset<T, VerificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Verifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Verifications
     * const verification = await prisma.verification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerificationUpdateManyArgs>(args: SelectSubset<T, VerificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Verification.
     * @param {VerificationUpsertArgs} args - Arguments to update or create a Verification.
     * @example
     * // Update or create a Verification
     * const verification = await prisma.verification.upsert({
     *   create: {
     *     // ... data to create a Verification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Verification we want to update
     *   }
     * })
     */
    upsert<T extends VerificationUpsertArgs>(args: SelectSubset<T, VerificationUpsertArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Verifications that matches the filter.
     * @param {VerificationFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const verification = await prisma.verification.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: VerificationFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Verification.
     * @param {VerificationAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const verification = await prisma.verification.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: VerificationAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Verifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationCountArgs} args - Arguments to filter Verifications to count.
     * @example
     * // Count the number of Verifications
     * const count = await prisma.verification.count({
     *   where: {
     *     // ... the filter for the Verifications we want to count
     *   }
     * })
    **/
    count<T extends VerificationCountArgs>(
      args?: Subset<T, VerificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Verification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerificationAggregateArgs>(args: Subset<T, VerificationAggregateArgs>): Prisma.PrismaPromise<GetVerificationAggregateType<T>>

    /**
     * Group by Verification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerificationGroupByArgs['orderBy'] }
        : { orderBy?: VerificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Verification model
   */
  readonly fields: VerificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Verification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Verification model
   */
  interface VerificationFieldRefs {
    readonly id: FieldRef<"Verification", 'String'>
    readonly identifier: FieldRef<"Verification", 'String'>
    readonly value: FieldRef<"Verification", 'String'>
    readonly expiresAt: FieldRef<"Verification", 'DateTime'>
    readonly createdAt: FieldRef<"Verification", 'DateTime'>
    readonly updatedAt: FieldRef<"Verification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Verification findUnique
   */
  export type VerificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification findUniqueOrThrow
   */
  export type VerificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification findFirst
   */
  export type VerificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Verifications.
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Verifications.
     */
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[]
  }

  /**
   * Verification findFirstOrThrow
   */
  export type VerificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Verifications.
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Verifications.
     */
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[]
  }

  /**
   * Verification findMany
   */
  export type VerificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verifications to fetch.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Verifications.
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[]
  }

  /**
   * Verification create
   */
  export type VerificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The data needed to create a Verification.
     */
    data: XOR<VerificationCreateInput, VerificationUncheckedCreateInput>
  }

  /**
   * Verification createMany
   */
  export type VerificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Verifications.
     */
    data: VerificationCreateManyInput | VerificationCreateManyInput[]
  }

  /**
   * Verification update
   */
  export type VerificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The data needed to update a Verification.
     */
    data: XOR<VerificationUpdateInput, VerificationUncheckedUpdateInput>
    /**
     * Choose, which Verification to update.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification updateMany
   */
  export type VerificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Verifications.
     */
    data: XOR<VerificationUpdateManyMutationInput, VerificationUncheckedUpdateManyInput>
    /**
     * Filter which Verifications to update
     */
    where?: VerificationWhereInput
    /**
     * Limit how many Verifications to update.
     */
    limit?: number
  }

  /**
   * Verification upsert
   */
  export type VerificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The filter to search for the Verification to update in case it exists.
     */
    where: VerificationWhereUniqueInput
    /**
     * In case the Verification found by the `where` argument doesn't exist, create a new Verification with this data.
     */
    create: XOR<VerificationCreateInput, VerificationUncheckedCreateInput>
    /**
     * In case the Verification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerificationUpdateInput, VerificationUncheckedUpdateInput>
  }

  /**
   * Verification delete
   */
  export type VerificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter which Verification to delete.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification deleteMany
   */
  export type VerificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Verifications to delete
     */
    where?: VerificationWhereInput
    /**
     * Limit how many Verifications to delete.
     */
    limit?: number
  }

  /**
   * Verification findRaw
   */
  export type VerificationFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Verification aggregateRaw
   */
  export type VerificationAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Verification without action
   */
  export type VerificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
  }


  /**
   * Model BlogPost
   */

  export type AggregateBlogPost = {
    _count: BlogPostCountAggregateOutputType | null
    _avg: BlogPostAvgAggregateOutputType | null
    _sum: BlogPostSumAggregateOutputType | null
    _min: BlogPostMinAggregateOutputType | null
    _max: BlogPostMaxAggregateOutputType | null
  }

  export type BlogPostAvgAggregateOutputType = {
    views: number | null
  }

  export type BlogPostSumAggregateOutputType = {
    views: number | null
  }

  export type BlogPostMinAggregateOutputType = {
    id: string | null
    title: string | null
    slug: string | null
    excerpt: string | null
    content: string | null
    image: string | null
    published: boolean | null
    authorId: string | null
    views: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BlogPostMaxAggregateOutputType = {
    id: string | null
    title: string | null
    slug: string | null
    excerpt: string | null
    content: string | null
    image: string | null
    published: boolean | null
    authorId: string | null
    views: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BlogPostCountAggregateOutputType = {
    id: number
    title: number
    slug: number
    excerpt: number
    content: number
    image: number
    published: number
    authorId: number
    categories: number
    tags: number
    views: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BlogPostAvgAggregateInputType = {
    views?: true
  }

  export type BlogPostSumAggregateInputType = {
    views?: true
  }

  export type BlogPostMinAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    excerpt?: true
    content?: true
    image?: true
    published?: true
    authorId?: true
    views?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BlogPostMaxAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    excerpt?: true
    content?: true
    image?: true
    published?: true
    authorId?: true
    views?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BlogPostCountAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    excerpt?: true
    content?: true
    image?: true
    published?: true
    authorId?: true
    categories?: true
    tags?: true
    views?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BlogPostAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlogPost to aggregate.
     */
    where?: BlogPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogPosts to fetch.
     */
    orderBy?: BlogPostOrderByWithRelationInput | BlogPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BlogPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BlogPosts
    **/
    _count?: true | BlogPostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BlogPostAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BlogPostSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BlogPostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BlogPostMaxAggregateInputType
  }

  export type GetBlogPostAggregateType<T extends BlogPostAggregateArgs> = {
        [P in keyof T & keyof AggregateBlogPost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlogPost[P]>
      : GetScalarType<T[P], AggregateBlogPost[P]>
  }




  export type BlogPostGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlogPostWhereInput
    orderBy?: BlogPostOrderByWithAggregationInput | BlogPostOrderByWithAggregationInput[]
    by: BlogPostScalarFieldEnum[] | BlogPostScalarFieldEnum
    having?: BlogPostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BlogPostCountAggregateInputType | true
    _avg?: BlogPostAvgAggregateInputType
    _sum?: BlogPostSumAggregateInputType
    _min?: BlogPostMinAggregateInputType
    _max?: BlogPostMaxAggregateInputType
  }

  export type BlogPostGroupByOutputType = {
    id: string
    title: string
    slug: string
    excerpt: string
    content: string
    image: string
    published: boolean
    authorId: string
    categories: string[]
    tags: string[]
    views: number
    createdAt: Date
    updatedAt: Date
    _count: BlogPostCountAggregateOutputType | null
    _avg: BlogPostAvgAggregateOutputType | null
    _sum: BlogPostSumAggregateOutputType | null
    _min: BlogPostMinAggregateOutputType | null
    _max: BlogPostMaxAggregateOutputType | null
  }

  type GetBlogPostGroupByPayload<T extends BlogPostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BlogPostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BlogPostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BlogPostGroupByOutputType[P]>
            : GetScalarType<T[P], BlogPostGroupByOutputType[P]>
        }
      >
    >


  export type BlogPostSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    excerpt?: boolean
    content?: boolean
    image?: boolean
    published?: boolean
    authorId?: boolean
    categories?: boolean
    tags?: boolean
    views?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    author?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blogPost"]>



  export type BlogPostSelectScalar = {
    id?: boolean
    title?: boolean
    slug?: boolean
    excerpt?: boolean
    content?: boolean
    image?: boolean
    published?: boolean
    authorId?: boolean
    categories?: boolean
    tags?: boolean
    views?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BlogPostOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "slug" | "excerpt" | "content" | "image" | "published" | "authorId" | "categories" | "tags" | "views" | "createdAt" | "updatedAt", ExtArgs["result"]["blogPost"]>
  export type BlogPostInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $BlogPostPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BlogPost"
    objects: {
      author: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      slug: string
      excerpt: string
      content: string
      image: string
      published: boolean
      authorId: string
      categories: string[]
      tags: string[]
      views: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["blogPost"]>
    composites: {}
  }

  type BlogPostGetPayload<S extends boolean | null | undefined | BlogPostDefaultArgs> = $Result.GetResult<Prisma.$BlogPostPayload, S>

  type BlogPostCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BlogPostFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BlogPostCountAggregateInputType | true
    }

  export interface BlogPostDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BlogPost'], meta: { name: 'BlogPost' } }
    /**
     * Find zero or one BlogPost that matches the filter.
     * @param {BlogPostFindUniqueArgs} args - Arguments to find a BlogPost
     * @example
     * // Get one BlogPost
     * const blogPost = await prisma.blogPost.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BlogPostFindUniqueArgs>(args: SelectSubset<T, BlogPostFindUniqueArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BlogPost that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BlogPostFindUniqueOrThrowArgs} args - Arguments to find a BlogPost
     * @example
     * // Get one BlogPost
     * const blogPost = await prisma.blogPost.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BlogPostFindUniqueOrThrowArgs>(args: SelectSubset<T, BlogPostFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BlogPost that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostFindFirstArgs} args - Arguments to find a BlogPost
     * @example
     * // Get one BlogPost
     * const blogPost = await prisma.blogPost.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BlogPostFindFirstArgs>(args?: SelectSubset<T, BlogPostFindFirstArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BlogPost that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostFindFirstOrThrowArgs} args - Arguments to find a BlogPost
     * @example
     * // Get one BlogPost
     * const blogPost = await prisma.blogPost.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BlogPostFindFirstOrThrowArgs>(args?: SelectSubset<T, BlogPostFindFirstOrThrowArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BlogPosts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BlogPosts
     * const blogPosts = await prisma.blogPost.findMany()
     * 
     * // Get first 10 BlogPosts
     * const blogPosts = await prisma.blogPost.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const blogPostWithIdOnly = await prisma.blogPost.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BlogPostFindManyArgs>(args?: SelectSubset<T, BlogPostFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BlogPost.
     * @param {BlogPostCreateArgs} args - Arguments to create a BlogPost.
     * @example
     * // Create one BlogPost
     * const BlogPost = await prisma.blogPost.create({
     *   data: {
     *     // ... data to create a BlogPost
     *   }
     * })
     * 
     */
    create<T extends BlogPostCreateArgs>(args: SelectSubset<T, BlogPostCreateArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BlogPosts.
     * @param {BlogPostCreateManyArgs} args - Arguments to create many BlogPosts.
     * @example
     * // Create many BlogPosts
     * const blogPost = await prisma.blogPost.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BlogPostCreateManyArgs>(args?: SelectSubset<T, BlogPostCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BlogPost.
     * @param {BlogPostDeleteArgs} args - Arguments to delete one BlogPost.
     * @example
     * // Delete one BlogPost
     * const BlogPost = await prisma.blogPost.delete({
     *   where: {
     *     // ... filter to delete one BlogPost
     *   }
     * })
     * 
     */
    delete<T extends BlogPostDeleteArgs>(args: SelectSubset<T, BlogPostDeleteArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BlogPost.
     * @param {BlogPostUpdateArgs} args - Arguments to update one BlogPost.
     * @example
     * // Update one BlogPost
     * const blogPost = await prisma.blogPost.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BlogPostUpdateArgs>(args: SelectSubset<T, BlogPostUpdateArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BlogPosts.
     * @param {BlogPostDeleteManyArgs} args - Arguments to filter BlogPosts to delete.
     * @example
     * // Delete a few BlogPosts
     * const { count } = await prisma.blogPost.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BlogPostDeleteManyArgs>(args?: SelectSubset<T, BlogPostDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BlogPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BlogPosts
     * const blogPost = await prisma.blogPost.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BlogPostUpdateManyArgs>(args: SelectSubset<T, BlogPostUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BlogPost.
     * @param {BlogPostUpsertArgs} args - Arguments to update or create a BlogPost.
     * @example
     * // Update or create a BlogPost
     * const blogPost = await prisma.blogPost.upsert({
     *   create: {
     *     // ... data to create a BlogPost
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BlogPost we want to update
     *   }
     * })
     */
    upsert<T extends BlogPostUpsertArgs>(args: SelectSubset<T, BlogPostUpsertArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BlogPosts that matches the filter.
     * @param {BlogPostFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const blogPost = await prisma.blogPost.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: BlogPostFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a BlogPost.
     * @param {BlogPostAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const blogPost = await prisma.blogPost.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: BlogPostAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of BlogPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostCountArgs} args - Arguments to filter BlogPosts to count.
     * @example
     * // Count the number of BlogPosts
     * const count = await prisma.blogPost.count({
     *   where: {
     *     // ... the filter for the BlogPosts we want to count
     *   }
     * })
    **/
    count<T extends BlogPostCountArgs>(
      args?: Subset<T, BlogPostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BlogPostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BlogPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BlogPostAggregateArgs>(args: Subset<T, BlogPostAggregateArgs>): Prisma.PrismaPromise<GetBlogPostAggregateType<T>>

    /**
     * Group by BlogPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BlogPostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BlogPostGroupByArgs['orderBy'] }
        : { orderBy?: BlogPostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BlogPostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlogPostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BlogPost model
   */
  readonly fields: BlogPostFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BlogPost.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BlogPostClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    author<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BlogPost model
   */
  interface BlogPostFieldRefs {
    readonly id: FieldRef<"BlogPost", 'String'>
    readonly title: FieldRef<"BlogPost", 'String'>
    readonly slug: FieldRef<"BlogPost", 'String'>
    readonly excerpt: FieldRef<"BlogPost", 'String'>
    readonly content: FieldRef<"BlogPost", 'String'>
    readonly image: FieldRef<"BlogPost", 'String'>
    readonly published: FieldRef<"BlogPost", 'Boolean'>
    readonly authorId: FieldRef<"BlogPost", 'String'>
    readonly categories: FieldRef<"BlogPost", 'String[]'>
    readonly tags: FieldRef<"BlogPost", 'String[]'>
    readonly views: FieldRef<"BlogPost", 'Int'>
    readonly createdAt: FieldRef<"BlogPost", 'DateTime'>
    readonly updatedAt: FieldRef<"BlogPost", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BlogPost findUnique
   */
  export type BlogPostFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPost
     */
    omit?: BlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * Filter, which BlogPost to fetch.
     */
    where: BlogPostWhereUniqueInput
  }

  /**
   * BlogPost findUniqueOrThrow
   */
  export type BlogPostFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPost
     */
    omit?: BlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * Filter, which BlogPost to fetch.
     */
    where: BlogPostWhereUniqueInput
  }

  /**
   * BlogPost findFirst
   */
  export type BlogPostFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPost
     */
    omit?: BlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * Filter, which BlogPost to fetch.
     */
    where?: BlogPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogPosts to fetch.
     */
    orderBy?: BlogPostOrderByWithRelationInput | BlogPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlogPosts.
     */
    cursor?: BlogPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlogPosts.
     */
    distinct?: BlogPostScalarFieldEnum | BlogPostScalarFieldEnum[]
  }

  /**
   * BlogPost findFirstOrThrow
   */
  export type BlogPostFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPost
     */
    omit?: BlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * Filter, which BlogPost to fetch.
     */
    where?: BlogPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogPosts to fetch.
     */
    orderBy?: BlogPostOrderByWithRelationInput | BlogPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlogPosts.
     */
    cursor?: BlogPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlogPosts.
     */
    distinct?: BlogPostScalarFieldEnum | BlogPostScalarFieldEnum[]
  }

  /**
   * BlogPost findMany
   */
  export type BlogPostFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPost
     */
    omit?: BlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * Filter, which BlogPosts to fetch.
     */
    where?: BlogPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogPosts to fetch.
     */
    orderBy?: BlogPostOrderByWithRelationInput | BlogPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BlogPosts.
     */
    cursor?: BlogPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogPosts.
     */
    skip?: number
    distinct?: BlogPostScalarFieldEnum | BlogPostScalarFieldEnum[]
  }

  /**
   * BlogPost create
   */
  export type BlogPostCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPost
     */
    omit?: BlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * The data needed to create a BlogPost.
     */
    data: XOR<BlogPostCreateInput, BlogPostUncheckedCreateInput>
  }

  /**
   * BlogPost createMany
   */
  export type BlogPostCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BlogPosts.
     */
    data: BlogPostCreateManyInput | BlogPostCreateManyInput[]
  }

  /**
   * BlogPost update
   */
  export type BlogPostUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPost
     */
    omit?: BlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * The data needed to update a BlogPost.
     */
    data: XOR<BlogPostUpdateInput, BlogPostUncheckedUpdateInput>
    /**
     * Choose, which BlogPost to update.
     */
    where: BlogPostWhereUniqueInput
  }

  /**
   * BlogPost updateMany
   */
  export type BlogPostUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BlogPosts.
     */
    data: XOR<BlogPostUpdateManyMutationInput, BlogPostUncheckedUpdateManyInput>
    /**
     * Filter which BlogPosts to update
     */
    where?: BlogPostWhereInput
    /**
     * Limit how many BlogPosts to update.
     */
    limit?: number
  }

  /**
   * BlogPost upsert
   */
  export type BlogPostUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPost
     */
    omit?: BlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * The filter to search for the BlogPost to update in case it exists.
     */
    where: BlogPostWhereUniqueInput
    /**
     * In case the BlogPost found by the `where` argument doesn't exist, create a new BlogPost with this data.
     */
    create: XOR<BlogPostCreateInput, BlogPostUncheckedCreateInput>
    /**
     * In case the BlogPost was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BlogPostUpdateInput, BlogPostUncheckedUpdateInput>
  }

  /**
   * BlogPost delete
   */
  export type BlogPostDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPost
     */
    omit?: BlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * Filter which BlogPost to delete.
     */
    where: BlogPostWhereUniqueInput
  }

  /**
   * BlogPost deleteMany
   */
  export type BlogPostDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlogPosts to delete
     */
    where?: BlogPostWhereInput
    /**
     * Limit how many BlogPosts to delete.
     */
    limit?: number
  }

  /**
   * BlogPost findRaw
   */
  export type BlogPostFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * BlogPost aggregateRaw
   */
  export type BlogPostAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * BlogPost without action
   */
  export type BlogPostDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPost
     */
    omit?: BlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
  }


  /**
   * Model RoadmapItem
   */

  export type AggregateRoadmapItem = {
    _count: RoadmapItemCountAggregateOutputType | null
    _avg: RoadmapItemAvgAggregateOutputType | null
    _sum: RoadmapItemSumAggregateOutputType | null
    _min: RoadmapItemMinAggregateOutputType | null
    _max: RoadmapItemMaxAggregateOutputType | null
  }

  export type RoadmapItemAvgAggregateOutputType = {
    views: number | null
  }

  export type RoadmapItemSumAggregateOutputType = {
    views: number | null
  }

  export type RoadmapItemMinAggregateOutputType = {
    id: string | null
    title: string | null
    slug: string | null
    excerpt: string | null
    content: string | null
    featuredImage: string | null
    youtubeVideoId: string | null
    displayDate: Date | null
    published: boolean | null
    authorId: string | null
    views: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoadmapItemMaxAggregateOutputType = {
    id: string | null
    title: string | null
    slug: string | null
    excerpt: string | null
    content: string | null
    featuredImage: string | null
    youtubeVideoId: string | null
    displayDate: Date | null
    published: boolean | null
    authorId: string | null
    views: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoadmapItemCountAggregateOutputType = {
    id: number
    title: number
    slug: number
    excerpt: number
    content: number
    featuredImage: number
    gallery: number
    youtubeVideoId: number
    displayDate: number
    published: number
    authorId: number
    categories: number
    tags: number
    views: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RoadmapItemAvgAggregateInputType = {
    views?: true
  }

  export type RoadmapItemSumAggregateInputType = {
    views?: true
  }

  export type RoadmapItemMinAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    excerpt?: true
    content?: true
    featuredImage?: true
    youtubeVideoId?: true
    displayDate?: true
    published?: true
    authorId?: true
    views?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoadmapItemMaxAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    excerpt?: true
    content?: true
    featuredImage?: true
    youtubeVideoId?: true
    displayDate?: true
    published?: true
    authorId?: true
    views?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoadmapItemCountAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    excerpt?: true
    content?: true
    featuredImage?: true
    gallery?: true
    youtubeVideoId?: true
    displayDate?: true
    published?: true
    authorId?: true
    categories?: true
    tags?: true
    views?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RoadmapItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoadmapItem to aggregate.
     */
    where?: RoadmapItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoadmapItems to fetch.
     */
    orderBy?: RoadmapItemOrderByWithRelationInput | RoadmapItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoadmapItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoadmapItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoadmapItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RoadmapItems
    **/
    _count?: true | RoadmapItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoadmapItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoadmapItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoadmapItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoadmapItemMaxAggregateInputType
  }

  export type GetRoadmapItemAggregateType<T extends RoadmapItemAggregateArgs> = {
        [P in keyof T & keyof AggregateRoadmapItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoadmapItem[P]>
      : GetScalarType<T[P], AggregateRoadmapItem[P]>
  }




  export type RoadmapItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoadmapItemWhereInput
    orderBy?: RoadmapItemOrderByWithAggregationInput | RoadmapItemOrderByWithAggregationInput[]
    by: RoadmapItemScalarFieldEnum[] | RoadmapItemScalarFieldEnum
    having?: RoadmapItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoadmapItemCountAggregateInputType | true
    _avg?: RoadmapItemAvgAggregateInputType
    _sum?: RoadmapItemSumAggregateInputType
    _min?: RoadmapItemMinAggregateInputType
    _max?: RoadmapItemMaxAggregateInputType
  }

  export type RoadmapItemGroupByOutputType = {
    id: string
    title: string
    slug: string
    excerpt: string
    content: string
    featuredImage: string
    gallery: string[]
    youtubeVideoId: string | null
    displayDate: Date | null
    published: boolean
    authorId: string
    categories: string[]
    tags: string[]
    views: number
    createdAt: Date
    updatedAt: Date
    _count: RoadmapItemCountAggregateOutputType | null
    _avg: RoadmapItemAvgAggregateOutputType | null
    _sum: RoadmapItemSumAggregateOutputType | null
    _min: RoadmapItemMinAggregateOutputType | null
    _max: RoadmapItemMaxAggregateOutputType | null
  }

  type GetRoadmapItemGroupByPayload<T extends RoadmapItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoadmapItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoadmapItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoadmapItemGroupByOutputType[P]>
            : GetScalarType<T[P], RoadmapItemGroupByOutputType[P]>
        }
      >
    >


  export type RoadmapItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    excerpt?: boolean
    content?: boolean
    featuredImage?: boolean
    gallery?: boolean
    youtubeVideoId?: boolean
    displayDate?: boolean
    published?: boolean
    authorId?: boolean
    categories?: boolean
    tags?: boolean
    views?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    author?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roadmapItem"]>



  export type RoadmapItemSelectScalar = {
    id?: boolean
    title?: boolean
    slug?: boolean
    excerpt?: boolean
    content?: boolean
    featuredImage?: boolean
    gallery?: boolean
    youtubeVideoId?: boolean
    displayDate?: boolean
    published?: boolean
    authorId?: boolean
    categories?: boolean
    tags?: boolean
    views?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RoadmapItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "slug" | "excerpt" | "content" | "featuredImage" | "gallery" | "youtubeVideoId" | "displayDate" | "published" | "authorId" | "categories" | "tags" | "views" | "createdAt" | "updatedAt", ExtArgs["result"]["roadmapItem"]>
  export type RoadmapItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $RoadmapItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RoadmapItem"
    objects: {
      author: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      slug: string
      excerpt: string
      content: string
      featuredImage: string
      gallery: string[]
      youtubeVideoId: string | null
      displayDate: Date | null
      published: boolean
      authorId: string
      categories: string[]
      tags: string[]
      views: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["roadmapItem"]>
    composites: {}
  }

  type RoadmapItemGetPayload<S extends boolean | null | undefined | RoadmapItemDefaultArgs> = $Result.GetResult<Prisma.$RoadmapItemPayload, S>

  type RoadmapItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RoadmapItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RoadmapItemCountAggregateInputType | true
    }

  export interface RoadmapItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RoadmapItem'], meta: { name: 'RoadmapItem' } }
    /**
     * Find zero or one RoadmapItem that matches the filter.
     * @param {RoadmapItemFindUniqueArgs} args - Arguments to find a RoadmapItem
     * @example
     * // Get one RoadmapItem
     * const roadmapItem = await prisma.roadmapItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoadmapItemFindUniqueArgs>(args: SelectSubset<T, RoadmapItemFindUniqueArgs<ExtArgs>>): Prisma__RoadmapItemClient<$Result.GetResult<Prisma.$RoadmapItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RoadmapItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RoadmapItemFindUniqueOrThrowArgs} args - Arguments to find a RoadmapItem
     * @example
     * // Get one RoadmapItem
     * const roadmapItem = await prisma.roadmapItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoadmapItemFindUniqueOrThrowArgs>(args: SelectSubset<T, RoadmapItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoadmapItemClient<$Result.GetResult<Prisma.$RoadmapItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RoadmapItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadmapItemFindFirstArgs} args - Arguments to find a RoadmapItem
     * @example
     * // Get one RoadmapItem
     * const roadmapItem = await prisma.roadmapItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoadmapItemFindFirstArgs>(args?: SelectSubset<T, RoadmapItemFindFirstArgs<ExtArgs>>): Prisma__RoadmapItemClient<$Result.GetResult<Prisma.$RoadmapItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RoadmapItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadmapItemFindFirstOrThrowArgs} args - Arguments to find a RoadmapItem
     * @example
     * // Get one RoadmapItem
     * const roadmapItem = await prisma.roadmapItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoadmapItemFindFirstOrThrowArgs>(args?: SelectSubset<T, RoadmapItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoadmapItemClient<$Result.GetResult<Prisma.$RoadmapItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RoadmapItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadmapItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RoadmapItems
     * const roadmapItems = await prisma.roadmapItem.findMany()
     * 
     * // Get first 10 RoadmapItems
     * const roadmapItems = await prisma.roadmapItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roadmapItemWithIdOnly = await prisma.roadmapItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoadmapItemFindManyArgs>(args?: SelectSubset<T, RoadmapItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoadmapItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RoadmapItem.
     * @param {RoadmapItemCreateArgs} args - Arguments to create a RoadmapItem.
     * @example
     * // Create one RoadmapItem
     * const RoadmapItem = await prisma.roadmapItem.create({
     *   data: {
     *     // ... data to create a RoadmapItem
     *   }
     * })
     * 
     */
    create<T extends RoadmapItemCreateArgs>(args: SelectSubset<T, RoadmapItemCreateArgs<ExtArgs>>): Prisma__RoadmapItemClient<$Result.GetResult<Prisma.$RoadmapItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RoadmapItems.
     * @param {RoadmapItemCreateManyArgs} args - Arguments to create many RoadmapItems.
     * @example
     * // Create many RoadmapItems
     * const roadmapItem = await prisma.roadmapItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoadmapItemCreateManyArgs>(args?: SelectSubset<T, RoadmapItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RoadmapItem.
     * @param {RoadmapItemDeleteArgs} args - Arguments to delete one RoadmapItem.
     * @example
     * // Delete one RoadmapItem
     * const RoadmapItem = await prisma.roadmapItem.delete({
     *   where: {
     *     // ... filter to delete one RoadmapItem
     *   }
     * })
     * 
     */
    delete<T extends RoadmapItemDeleteArgs>(args: SelectSubset<T, RoadmapItemDeleteArgs<ExtArgs>>): Prisma__RoadmapItemClient<$Result.GetResult<Prisma.$RoadmapItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RoadmapItem.
     * @param {RoadmapItemUpdateArgs} args - Arguments to update one RoadmapItem.
     * @example
     * // Update one RoadmapItem
     * const roadmapItem = await prisma.roadmapItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoadmapItemUpdateArgs>(args: SelectSubset<T, RoadmapItemUpdateArgs<ExtArgs>>): Prisma__RoadmapItemClient<$Result.GetResult<Prisma.$RoadmapItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RoadmapItems.
     * @param {RoadmapItemDeleteManyArgs} args - Arguments to filter RoadmapItems to delete.
     * @example
     * // Delete a few RoadmapItems
     * const { count } = await prisma.roadmapItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoadmapItemDeleteManyArgs>(args?: SelectSubset<T, RoadmapItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RoadmapItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadmapItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RoadmapItems
     * const roadmapItem = await prisma.roadmapItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoadmapItemUpdateManyArgs>(args: SelectSubset<T, RoadmapItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RoadmapItem.
     * @param {RoadmapItemUpsertArgs} args - Arguments to update or create a RoadmapItem.
     * @example
     * // Update or create a RoadmapItem
     * const roadmapItem = await prisma.roadmapItem.upsert({
     *   create: {
     *     // ... data to create a RoadmapItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RoadmapItem we want to update
     *   }
     * })
     */
    upsert<T extends RoadmapItemUpsertArgs>(args: SelectSubset<T, RoadmapItemUpsertArgs<ExtArgs>>): Prisma__RoadmapItemClient<$Result.GetResult<Prisma.$RoadmapItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RoadmapItems that matches the filter.
     * @param {RoadmapItemFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const roadmapItem = await prisma.roadmapItem.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: RoadmapItemFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a RoadmapItem.
     * @param {RoadmapItemAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const roadmapItem = await prisma.roadmapItem.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: RoadmapItemAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of RoadmapItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadmapItemCountArgs} args - Arguments to filter RoadmapItems to count.
     * @example
     * // Count the number of RoadmapItems
     * const count = await prisma.roadmapItem.count({
     *   where: {
     *     // ... the filter for the RoadmapItems we want to count
     *   }
     * })
    **/
    count<T extends RoadmapItemCountArgs>(
      args?: Subset<T, RoadmapItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoadmapItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RoadmapItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadmapItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoadmapItemAggregateArgs>(args: Subset<T, RoadmapItemAggregateArgs>): Prisma.PrismaPromise<GetRoadmapItemAggregateType<T>>

    /**
     * Group by RoadmapItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadmapItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoadmapItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoadmapItemGroupByArgs['orderBy'] }
        : { orderBy?: RoadmapItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoadmapItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoadmapItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RoadmapItem model
   */
  readonly fields: RoadmapItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RoadmapItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoadmapItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    author<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RoadmapItem model
   */
  interface RoadmapItemFieldRefs {
    readonly id: FieldRef<"RoadmapItem", 'String'>
    readonly title: FieldRef<"RoadmapItem", 'String'>
    readonly slug: FieldRef<"RoadmapItem", 'String'>
    readonly excerpt: FieldRef<"RoadmapItem", 'String'>
    readonly content: FieldRef<"RoadmapItem", 'String'>
    readonly featuredImage: FieldRef<"RoadmapItem", 'String'>
    readonly gallery: FieldRef<"RoadmapItem", 'String[]'>
    readonly youtubeVideoId: FieldRef<"RoadmapItem", 'String'>
    readonly displayDate: FieldRef<"RoadmapItem", 'DateTime'>
    readonly published: FieldRef<"RoadmapItem", 'Boolean'>
    readonly authorId: FieldRef<"RoadmapItem", 'String'>
    readonly categories: FieldRef<"RoadmapItem", 'String[]'>
    readonly tags: FieldRef<"RoadmapItem", 'String[]'>
    readonly views: FieldRef<"RoadmapItem", 'Int'>
    readonly createdAt: FieldRef<"RoadmapItem", 'DateTime'>
    readonly updatedAt: FieldRef<"RoadmapItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RoadmapItem findUnique
   */
  export type RoadmapItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapItem
     */
    select?: RoadmapItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoadmapItem
     */
    omit?: RoadmapItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapItemInclude<ExtArgs> | null
    /**
     * Filter, which RoadmapItem to fetch.
     */
    where: RoadmapItemWhereUniqueInput
  }

  /**
   * RoadmapItem findUniqueOrThrow
   */
  export type RoadmapItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapItem
     */
    select?: RoadmapItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoadmapItem
     */
    omit?: RoadmapItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapItemInclude<ExtArgs> | null
    /**
     * Filter, which RoadmapItem to fetch.
     */
    where: RoadmapItemWhereUniqueInput
  }

  /**
   * RoadmapItem findFirst
   */
  export type RoadmapItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapItem
     */
    select?: RoadmapItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoadmapItem
     */
    omit?: RoadmapItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapItemInclude<ExtArgs> | null
    /**
     * Filter, which RoadmapItem to fetch.
     */
    where?: RoadmapItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoadmapItems to fetch.
     */
    orderBy?: RoadmapItemOrderByWithRelationInput | RoadmapItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoadmapItems.
     */
    cursor?: RoadmapItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoadmapItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoadmapItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoadmapItems.
     */
    distinct?: RoadmapItemScalarFieldEnum | RoadmapItemScalarFieldEnum[]
  }

  /**
   * RoadmapItem findFirstOrThrow
   */
  export type RoadmapItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapItem
     */
    select?: RoadmapItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoadmapItem
     */
    omit?: RoadmapItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapItemInclude<ExtArgs> | null
    /**
     * Filter, which RoadmapItem to fetch.
     */
    where?: RoadmapItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoadmapItems to fetch.
     */
    orderBy?: RoadmapItemOrderByWithRelationInput | RoadmapItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoadmapItems.
     */
    cursor?: RoadmapItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoadmapItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoadmapItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoadmapItems.
     */
    distinct?: RoadmapItemScalarFieldEnum | RoadmapItemScalarFieldEnum[]
  }

  /**
   * RoadmapItem findMany
   */
  export type RoadmapItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapItem
     */
    select?: RoadmapItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoadmapItem
     */
    omit?: RoadmapItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapItemInclude<ExtArgs> | null
    /**
     * Filter, which RoadmapItems to fetch.
     */
    where?: RoadmapItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoadmapItems to fetch.
     */
    orderBy?: RoadmapItemOrderByWithRelationInput | RoadmapItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RoadmapItems.
     */
    cursor?: RoadmapItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoadmapItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoadmapItems.
     */
    skip?: number
    distinct?: RoadmapItemScalarFieldEnum | RoadmapItemScalarFieldEnum[]
  }

  /**
   * RoadmapItem create
   */
  export type RoadmapItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapItem
     */
    select?: RoadmapItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoadmapItem
     */
    omit?: RoadmapItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapItemInclude<ExtArgs> | null
    /**
     * The data needed to create a RoadmapItem.
     */
    data: XOR<RoadmapItemCreateInput, RoadmapItemUncheckedCreateInput>
  }

  /**
   * RoadmapItem createMany
   */
  export type RoadmapItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RoadmapItems.
     */
    data: RoadmapItemCreateManyInput | RoadmapItemCreateManyInput[]
  }

  /**
   * RoadmapItem update
   */
  export type RoadmapItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapItem
     */
    select?: RoadmapItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoadmapItem
     */
    omit?: RoadmapItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapItemInclude<ExtArgs> | null
    /**
     * The data needed to update a RoadmapItem.
     */
    data: XOR<RoadmapItemUpdateInput, RoadmapItemUncheckedUpdateInput>
    /**
     * Choose, which RoadmapItem to update.
     */
    where: RoadmapItemWhereUniqueInput
  }

  /**
   * RoadmapItem updateMany
   */
  export type RoadmapItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RoadmapItems.
     */
    data: XOR<RoadmapItemUpdateManyMutationInput, RoadmapItemUncheckedUpdateManyInput>
    /**
     * Filter which RoadmapItems to update
     */
    where?: RoadmapItemWhereInput
    /**
     * Limit how many RoadmapItems to update.
     */
    limit?: number
  }

  /**
   * RoadmapItem upsert
   */
  export type RoadmapItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapItem
     */
    select?: RoadmapItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoadmapItem
     */
    omit?: RoadmapItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapItemInclude<ExtArgs> | null
    /**
     * The filter to search for the RoadmapItem to update in case it exists.
     */
    where: RoadmapItemWhereUniqueInput
    /**
     * In case the RoadmapItem found by the `where` argument doesn't exist, create a new RoadmapItem with this data.
     */
    create: XOR<RoadmapItemCreateInput, RoadmapItemUncheckedCreateInput>
    /**
     * In case the RoadmapItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoadmapItemUpdateInput, RoadmapItemUncheckedUpdateInput>
  }

  /**
   * RoadmapItem delete
   */
  export type RoadmapItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapItem
     */
    select?: RoadmapItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoadmapItem
     */
    omit?: RoadmapItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapItemInclude<ExtArgs> | null
    /**
     * Filter which RoadmapItem to delete.
     */
    where: RoadmapItemWhereUniqueInput
  }

  /**
   * RoadmapItem deleteMany
   */
  export type RoadmapItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoadmapItems to delete
     */
    where?: RoadmapItemWhereInput
    /**
     * Limit how many RoadmapItems to delete.
     */
    limit?: number
  }

  /**
   * RoadmapItem findRaw
   */
  export type RoadmapItemFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * RoadmapItem aggregateRaw
   */
  export type RoadmapItemAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * RoadmapItem without action
   */
  export type RoadmapItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapItem
     */
    select?: RoadmapItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoadmapItem
     */
    omit?: RoadmapItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapItemInclude<ExtArgs> | null
  }


  /**
   * Model GameAsset
   */

  export type AggregateGameAsset = {
    _count: GameAssetCountAggregateOutputType | null
    _avg: GameAssetAvgAggregateOutputType | null
    _sum: GameAssetSumAggregateOutputType | null
    _min: GameAssetMinAggregateOutputType | null
    _max: GameAssetMaxAggregateOutputType | null
  }

  export type GameAssetAvgAggregateOutputType = {
    difficulty: number | null
  }

  export type GameAssetSumAggregateOutputType = {
    difficulty: number | null
  }

  export type GameAssetMinAggregateOutputType = {
    id: string | null
    title: string | null
    image: string | null
    description: string | null
    blogLink: string | null
    difficulty: number | null
    pinned: boolean | null
    category: string | null
    type: string | null
    published: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GameAssetMaxAggregateOutputType = {
    id: string | null
    title: string | null
    image: string | null
    description: string | null
    blogLink: string | null
    difficulty: number | null
    pinned: boolean | null
    category: string | null
    type: string | null
    published: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GameAssetCountAggregateOutputType = {
    id: number
    title: number
    image: number
    description: number
    blogLink: number
    difficulty: number
    pinned: number
    category: number
    type: number
    published: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GameAssetAvgAggregateInputType = {
    difficulty?: true
  }

  export type GameAssetSumAggregateInputType = {
    difficulty?: true
  }

  export type GameAssetMinAggregateInputType = {
    id?: true
    title?: true
    image?: true
    description?: true
    blogLink?: true
    difficulty?: true
    pinned?: true
    category?: true
    type?: true
    published?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GameAssetMaxAggregateInputType = {
    id?: true
    title?: true
    image?: true
    description?: true
    blogLink?: true
    difficulty?: true
    pinned?: true
    category?: true
    type?: true
    published?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GameAssetCountAggregateInputType = {
    id?: true
    title?: true
    image?: true
    description?: true
    blogLink?: true
    difficulty?: true
    pinned?: true
    category?: true
    type?: true
    published?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GameAssetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GameAsset to aggregate.
     */
    where?: GameAssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameAssets to fetch.
     */
    orderBy?: GameAssetOrderByWithRelationInput | GameAssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GameAssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameAssets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameAssets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GameAssets
    **/
    _count?: true | GameAssetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GameAssetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GameAssetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GameAssetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GameAssetMaxAggregateInputType
  }

  export type GetGameAssetAggregateType<T extends GameAssetAggregateArgs> = {
        [P in keyof T & keyof AggregateGameAsset]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGameAsset[P]>
      : GetScalarType<T[P], AggregateGameAsset[P]>
  }




  export type GameAssetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GameAssetWhereInput
    orderBy?: GameAssetOrderByWithAggregationInput | GameAssetOrderByWithAggregationInput[]
    by: GameAssetScalarFieldEnum[] | GameAssetScalarFieldEnum
    having?: GameAssetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GameAssetCountAggregateInputType | true
    _avg?: GameAssetAvgAggregateInputType
    _sum?: GameAssetSumAggregateInputType
    _min?: GameAssetMinAggregateInputType
    _max?: GameAssetMaxAggregateInputType
  }

  export type GameAssetGroupByOutputType = {
    id: string
    title: string
    image: string
    description: string | null
    blogLink: string | null
    difficulty: number
    pinned: boolean
    category: string
    type: string | null
    published: boolean
    createdAt: Date
    updatedAt: Date
    _count: GameAssetCountAggregateOutputType | null
    _avg: GameAssetAvgAggregateOutputType | null
    _sum: GameAssetSumAggregateOutputType | null
    _min: GameAssetMinAggregateOutputType | null
    _max: GameAssetMaxAggregateOutputType | null
  }

  type GetGameAssetGroupByPayload<T extends GameAssetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GameAssetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GameAssetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GameAssetGroupByOutputType[P]>
            : GetScalarType<T[P], GameAssetGroupByOutputType[P]>
        }
      >
    >


  export type GameAssetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    image?: boolean
    description?: boolean
    blogLink?: boolean
    difficulty?: boolean
    pinned?: boolean
    category?: boolean
    type?: boolean
    published?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["gameAsset"]>



  export type GameAssetSelectScalar = {
    id?: boolean
    title?: boolean
    image?: boolean
    description?: boolean
    blogLink?: boolean
    difficulty?: boolean
    pinned?: boolean
    category?: boolean
    type?: boolean
    published?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type GameAssetOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "image" | "description" | "blogLink" | "difficulty" | "pinned" | "category" | "type" | "published" | "createdAt" | "updatedAt", ExtArgs["result"]["gameAsset"]>

  export type $GameAssetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GameAsset"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      image: string
      description: string | null
      blogLink: string | null
      difficulty: number
      pinned: boolean
      category: string
      type: string | null
      published: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["gameAsset"]>
    composites: {}
  }

  type GameAssetGetPayload<S extends boolean | null | undefined | GameAssetDefaultArgs> = $Result.GetResult<Prisma.$GameAssetPayload, S>

  type GameAssetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GameAssetFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GameAssetCountAggregateInputType | true
    }

  export interface GameAssetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GameAsset'], meta: { name: 'GameAsset' } }
    /**
     * Find zero or one GameAsset that matches the filter.
     * @param {GameAssetFindUniqueArgs} args - Arguments to find a GameAsset
     * @example
     * // Get one GameAsset
     * const gameAsset = await prisma.gameAsset.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GameAssetFindUniqueArgs>(args: SelectSubset<T, GameAssetFindUniqueArgs<ExtArgs>>): Prisma__GameAssetClient<$Result.GetResult<Prisma.$GameAssetPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GameAsset that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GameAssetFindUniqueOrThrowArgs} args - Arguments to find a GameAsset
     * @example
     * // Get one GameAsset
     * const gameAsset = await prisma.gameAsset.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GameAssetFindUniqueOrThrowArgs>(args: SelectSubset<T, GameAssetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GameAssetClient<$Result.GetResult<Prisma.$GameAssetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GameAsset that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameAssetFindFirstArgs} args - Arguments to find a GameAsset
     * @example
     * // Get one GameAsset
     * const gameAsset = await prisma.gameAsset.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GameAssetFindFirstArgs>(args?: SelectSubset<T, GameAssetFindFirstArgs<ExtArgs>>): Prisma__GameAssetClient<$Result.GetResult<Prisma.$GameAssetPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GameAsset that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameAssetFindFirstOrThrowArgs} args - Arguments to find a GameAsset
     * @example
     * // Get one GameAsset
     * const gameAsset = await prisma.gameAsset.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GameAssetFindFirstOrThrowArgs>(args?: SelectSubset<T, GameAssetFindFirstOrThrowArgs<ExtArgs>>): Prisma__GameAssetClient<$Result.GetResult<Prisma.$GameAssetPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GameAssets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameAssetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GameAssets
     * const gameAssets = await prisma.gameAsset.findMany()
     * 
     * // Get first 10 GameAssets
     * const gameAssets = await prisma.gameAsset.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gameAssetWithIdOnly = await prisma.gameAsset.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GameAssetFindManyArgs>(args?: SelectSubset<T, GameAssetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameAssetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GameAsset.
     * @param {GameAssetCreateArgs} args - Arguments to create a GameAsset.
     * @example
     * // Create one GameAsset
     * const GameAsset = await prisma.gameAsset.create({
     *   data: {
     *     // ... data to create a GameAsset
     *   }
     * })
     * 
     */
    create<T extends GameAssetCreateArgs>(args: SelectSubset<T, GameAssetCreateArgs<ExtArgs>>): Prisma__GameAssetClient<$Result.GetResult<Prisma.$GameAssetPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GameAssets.
     * @param {GameAssetCreateManyArgs} args - Arguments to create many GameAssets.
     * @example
     * // Create many GameAssets
     * const gameAsset = await prisma.gameAsset.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GameAssetCreateManyArgs>(args?: SelectSubset<T, GameAssetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a GameAsset.
     * @param {GameAssetDeleteArgs} args - Arguments to delete one GameAsset.
     * @example
     * // Delete one GameAsset
     * const GameAsset = await prisma.gameAsset.delete({
     *   where: {
     *     // ... filter to delete one GameAsset
     *   }
     * })
     * 
     */
    delete<T extends GameAssetDeleteArgs>(args: SelectSubset<T, GameAssetDeleteArgs<ExtArgs>>): Prisma__GameAssetClient<$Result.GetResult<Prisma.$GameAssetPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GameAsset.
     * @param {GameAssetUpdateArgs} args - Arguments to update one GameAsset.
     * @example
     * // Update one GameAsset
     * const gameAsset = await prisma.gameAsset.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GameAssetUpdateArgs>(args: SelectSubset<T, GameAssetUpdateArgs<ExtArgs>>): Prisma__GameAssetClient<$Result.GetResult<Prisma.$GameAssetPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GameAssets.
     * @param {GameAssetDeleteManyArgs} args - Arguments to filter GameAssets to delete.
     * @example
     * // Delete a few GameAssets
     * const { count } = await prisma.gameAsset.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GameAssetDeleteManyArgs>(args?: SelectSubset<T, GameAssetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GameAssets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameAssetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GameAssets
     * const gameAsset = await prisma.gameAsset.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GameAssetUpdateManyArgs>(args: SelectSubset<T, GameAssetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one GameAsset.
     * @param {GameAssetUpsertArgs} args - Arguments to update or create a GameAsset.
     * @example
     * // Update or create a GameAsset
     * const gameAsset = await prisma.gameAsset.upsert({
     *   create: {
     *     // ... data to create a GameAsset
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GameAsset we want to update
     *   }
     * })
     */
    upsert<T extends GameAssetUpsertArgs>(args: SelectSubset<T, GameAssetUpsertArgs<ExtArgs>>): Prisma__GameAssetClient<$Result.GetResult<Prisma.$GameAssetPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GameAssets that matches the filter.
     * @param {GameAssetFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const gameAsset = await prisma.gameAsset.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: GameAssetFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a GameAsset.
     * @param {GameAssetAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const gameAsset = await prisma.gameAsset.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: GameAssetAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of GameAssets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameAssetCountArgs} args - Arguments to filter GameAssets to count.
     * @example
     * // Count the number of GameAssets
     * const count = await prisma.gameAsset.count({
     *   where: {
     *     // ... the filter for the GameAssets we want to count
     *   }
     * })
    **/
    count<T extends GameAssetCountArgs>(
      args?: Subset<T, GameAssetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GameAssetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GameAsset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameAssetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GameAssetAggregateArgs>(args: Subset<T, GameAssetAggregateArgs>): Prisma.PrismaPromise<GetGameAssetAggregateType<T>>

    /**
     * Group by GameAsset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameAssetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GameAssetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GameAssetGroupByArgs['orderBy'] }
        : { orderBy?: GameAssetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GameAssetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGameAssetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GameAsset model
   */
  readonly fields: GameAssetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GameAsset.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GameAssetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GameAsset model
   */
  interface GameAssetFieldRefs {
    readonly id: FieldRef<"GameAsset", 'String'>
    readonly title: FieldRef<"GameAsset", 'String'>
    readonly image: FieldRef<"GameAsset", 'String'>
    readonly description: FieldRef<"GameAsset", 'String'>
    readonly blogLink: FieldRef<"GameAsset", 'String'>
    readonly difficulty: FieldRef<"GameAsset", 'Int'>
    readonly pinned: FieldRef<"GameAsset", 'Boolean'>
    readonly category: FieldRef<"GameAsset", 'String'>
    readonly type: FieldRef<"GameAsset", 'String'>
    readonly published: FieldRef<"GameAsset", 'Boolean'>
    readonly createdAt: FieldRef<"GameAsset", 'DateTime'>
    readonly updatedAt: FieldRef<"GameAsset", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GameAsset findUnique
   */
  export type GameAssetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameAsset
     */
    select?: GameAssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameAsset
     */
    omit?: GameAssetOmit<ExtArgs> | null
    /**
     * Filter, which GameAsset to fetch.
     */
    where: GameAssetWhereUniqueInput
  }

  /**
   * GameAsset findUniqueOrThrow
   */
  export type GameAssetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameAsset
     */
    select?: GameAssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameAsset
     */
    omit?: GameAssetOmit<ExtArgs> | null
    /**
     * Filter, which GameAsset to fetch.
     */
    where: GameAssetWhereUniqueInput
  }

  /**
   * GameAsset findFirst
   */
  export type GameAssetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameAsset
     */
    select?: GameAssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameAsset
     */
    omit?: GameAssetOmit<ExtArgs> | null
    /**
     * Filter, which GameAsset to fetch.
     */
    where?: GameAssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameAssets to fetch.
     */
    orderBy?: GameAssetOrderByWithRelationInput | GameAssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GameAssets.
     */
    cursor?: GameAssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameAssets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameAssets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GameAssets.
     */
    distinct?: GameAssetScalarFieldEnum | GameAssetScalarFieldEnum[]
  }

  /**
   * GameAsset findFirstOrThrow
   */
  export type GameAssetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameAsset
     */
    select?: GameAssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameAsset
     */
    omit?: GameAssetOmit<ExtArgs> | null
    /**
     * Filter, which GameAsset to fetch.
     */
    where?: GameAssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameAssets to fetch.
     */
    orderBy?: GameAssetOrderByWithRelationInput | GameAssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GameAssets.
     */
    cursor?: GameAssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameAssets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameAssets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GameAssets.
     */
    distinct?: GameAssetScalarFieldEnum | GameAssetScalarFieldEnum[]
  }

  /**
   * GameAsset findMany
   */
  export type GameAssetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameAsset
     */
    select?: GameAssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameAsset
     */
    omit?: GameAssetOmit<ExtArgs> | null
    /**
     * Filter, which GameAssets to fetch.
     */
    where?: GameAssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameAssets to fetch.
     */
    orderBy?: GameAssetOrderByWithRelationInput | GameAssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GameAssets.
     */
    cursor?: GameAssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameAssets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameAssets.
     */
    skip?: number
    distinct?: GameAssetScalarFieldEnum | GameAssetScalarFieldEnum[]
  }

  /**
   * GameAsset create
   */
  export type GameAssetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameAsset
     */
    select?: GameAssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameAsset
     */
    omit?: GameAssetOmit<ExtArgs> | null
    /**
     * The data needed to create a GameAsset.
     */
    data: XOR<GameAssetCreateInput, GameAssetUncheckedCreateInput>
  }

  /**
   * GameAsset createMany
   */
  export type GameAssetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GameAssets.
     */
    data: GameAssetCreateManyInput | GameAssetCreateManyInput[]
  }

  /**
   * GameAsset update
   */
  export type GameAssetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameAsset
     */
    select?: GameAssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameAsset
     */
    omit?: GameAssetOmit<ExtArgs> | null
    /**
     * The data needed to update a GameAsset.
     */
    data: XOR<GameAssetUpdateInput, GameAssetUncheckedUpdateInput>
    /**
     * Choose, which GameAsset to update.
     */
    where: GameAssetWhereUniqueInput
  }

  /**
   * GameAsset updateMany
   */
  export type GameAssetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GameAssets.
     */
    data: XOR<GameAssetUpdateManyMutationInput, GameAssetUncheckedUpdateManyInput>
    /**
     * Filter which GameAssets to update
     */
    where?: GameAssetWhereInput
    /**
     * Limit how many GameAssets to update.
     */
    limit?: number
  }

  /**
   * GameAsset upsert
   */
  export type GameAssetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameAsset
     */
    select?: GameAssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameAsset
     */
    omit?: GameAssetOmit<ExtArgs> | null
    /**
     * The filter to search for the GameAsset to update in case it exists.
     */
    where: GameAssetWhereUniqueInput
    /**
     * In case the GameAsset found by the `where` argument doesn't exist, create a new GameAsset with this data.
     */
    create: XOR<GameAssetCreateInput, GameAssetUncheckedCreateInput>
    /**
     * In case the GameAsset was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GameAssetUpdateInput, GameAssetUncheckedUpdateInput>
  }

  /**
   * GameAsset delete
   */
  export type GameAssetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameAsset
     */
    select?: GameAssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameAsset
     */
    omit?: GameAssetOmit<ExtArgs> | null
    /**
     * Filter which GameAsset to delete.
     */
    where: GameAssetWhereUniqueInput
  }

  /**
   * GameAsset deleteMany
   */
  export type GameAssetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GameAssets to delete
     */
    where?: GameAssetWhereInput
    /**
     * Limit how many GameAssets to delete.
     */
    limit?: number
  }

  /**
   * GameAsset findRaw
   */
  export type GameAssetFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * GameAsset aggregateRaw
   */
  export type GameAssetAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * GameAsset without action
   */
  export type GameAssetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameAsset
     */
    select?: GameAssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameAsset
     */
    omit?: GameAssetOmit<ExtArgs> | null
  }


  /**
   * Model GameObjective
   */

  export type AggregateGameObjective = {
    _count: GameObjectiveCountAggregateOutputType | null
    _avg: GameObjectiveAvgAggregateOutputType | null
    _sum: GameObjectiveSumAggregateOutputType | null
    _min: GameObjectiveMinAggregateOutputType | null
    _max: GameObjectiveMaxAggregateOutputType | null
  }

  export type GameObjectiveAvgAggregateOutputType = {
    order: number | null
  }

  export type GameObjectiveSumAggregateOutputType = {
    order: number | null
  }

  export type GameObjectiveMinAggregateOutputType = {
    id: string | null
    category: string | null
    title: string | null
    image: string | null
    published: boolean | null
    order: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GameObjectiveMaxAggregateOutputType = {
    id: string | null
    category: string | null
    title: string | null
    image: string | null
    published: boolean | null
    order: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GameObjectiveCountAggregateOutputType = {
    id: number
    category: number
    title: number
    image: number
    published: number
    order: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GameObjectiveAvgAggregateInputType = {
    order?: true
  }

  export type GameObjectiveSumAggregateInputType = {
    order?: true
  }

  export type GameObjectiveMinAggregateInputType = {
    id?: true
    category?: true
    title?: true
    image?: true
    published?: true
    order?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GameObjectiveMaxAggregateInputType = {
    id?: true
    category?: true
    title?: true
    image?: true
    published?: true
    order?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GameObjectiveCountAggregateInputType = {
    id?: true
    category?: true
    title?: true
    image?: true
    published?: true
    order?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GameObjectiveAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GameObjective to aggregate.
     */
    where?: GameObjectiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameObjectives to fetch.
     */
    orderBy?: GameObjectiveOrderByWithRelationInput | GameObjectiveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GameObjectiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameObjectives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameObjectives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GameObjectives
    **/
    _count?: true | GameObjectiveCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GameObjectiveAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GameObjectiveSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GameObjectiveMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GameObjectiveMaxAggregateInputType
  }

  export type GetGameObjectiveAggregateType<T extends GameObjectiveAggregateArgs> = {
        [P in keyof T & keyof AggregateGameObjective]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGameObjective[P]>
      : GetScalarType<T[P], AggregateGameObjective[P]>
  }




  export type GameObjectiveGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GameObjectiveWhereInput
    orderBy?: GameObjectiveOrderByWithAggregationInput | GameObjectiveOrderByWithAggregationInput[]
    by: GameObjectiveScalarFieldEnum[] | GameObjectiveScalarFieldEnum
    having?: GameObjectiveScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GameObjectiveCountAggregateInputType | true
    _avg?: GameObjectiveAvgAggregateInputType
    _sum?: GameObjectiveSumAggregateInputType
    _min?: GameObjectiveMinAggregateInputType
    _max?: GameObjectiveMaxAggregateInputType
  }

  export type GameObjectiveGroupByOutputType = {
    id: string
    category: string
    title: string
    image: string
    published: boolean
    order: number
    createdAt: Date
    updatedAt: Date
    _count: GameObjectiveCountAggregateOutputType | null
    _avg: GameObjectiveAvgAggregateOutputType | null
    _sum: GameObjectiveSumAggregateOutputType | null
    _min: GameObjectiveMinAggregateOutputType | null
    _max: GameObjectiveMaxAggregateOutputType | null
  }

  type GetGameObjectiveGroupByPayload<T extends GameObjectiveGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GameObjectiveGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GameObjectiveGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GameObjectiveGroupByOutputType[P]>
            : GetScalarType<T[P], GameObjectiveGroupByOutputType[P]>
        }
      >
    >


  export type GameObjectiveSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    category?: boolean
    title?: boolean
    image?: boolean
    published?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["gameObjective"]>



  export type GameObjectiveSelectScalar = {
    id?: boolean
    category?: boolean
    title?: boolean
    image?: boolean
    published?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type GameObjectiveOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "category" | "title" | "image" | "published" | "order" | "createdAt" | "updatedAt", ExtArgs["result"]["gameObjective"]>

  export type $GameObjectivePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GameObjective"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      category: string
      title: string
      image: string
      published: boolean
      order: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["gameObjective"]>
    composites: {}
  }

  type GameObjectiveGetPayload<S extends boolean | null | undefined | GameObjectiveDefaultArgs> = $Result.GetResult<Prisma.$GameObjectivePayload, S>

  type GameObjectiveCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GameObjectiveFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GameObjectiveCountAggregateInputType | true
    }

  export interface GameObjectiveDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GameObjective'], meta: { name: 'GameObjective' } }
    /**
     * Find zero or one GameObjective that matches the filter.
     * @param {GameObjectiveFindUniqueArgs} args - Arguments to find a GameObjective
     * @example
     * // Get one GameObjective
     * const gameObjective = await prisma.gameObjective.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GameObjectiveFindUniqueArgs>(args: SelectSubset<T, GameObjectiveFindUniqueArgs<ExtArgs>>): Prisma__GameObjectiveClient<$Result.GetResult<Prisma.$GameObjectivePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GameObjective that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GameObjectiveFindUniqueOrThrowArgs} args - Arguments to find a GameObjective
     * @example
     * // Get one GameObjective
     * const gameObjective = await prisma.gameObjective.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GameObjectiveFindUniqueOrThrowArgs>(args: SelectSubset<T, GameObjectiveFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GameObjectiveClient<$Result.GetResult<Prisma.$GameObjectivePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GameObjective that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameObjectiveFindFirstArgs} args - Arguments to find a GameObjective
     * @example
     * // Get one GameObjective
     * const gameObjective = await prisma.gameObjective.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GameObjectiveFindFirstArgs>(args?: SelectSubset<T, GameObjectiveFindFirstArgs<ExtArgs>>): Prisma__GameObjectiveClient<$Result.GetResult<Prisma.$GameObjectivePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GameObjective that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameObjectiveFindFirstOrThrowArgs} args - Arguments to find a GameObjective
     * @example
     * // Get one GameObjective
     * const gameObjective = await prisma.gameObjective.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GameObjectiveFindFirstOrThrowArgs>(args?: SelectSubset<T, GameObjectiveFindFirstOrThrowArgs<ExtArgs>>): Prisma__GameObjectiveClient<$Result.GetResult<Prisma.$GameObjectivePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GameObjectives that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameObjectiveFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GameObjectives
     * const gameObjectives = await prisma.gameObjective.findMany()
     * 
     * // Get first 10 GameObjectives
     * const gameObjectives = await prisma.gameObjective.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gameObjectiveWithIdOnly = await prisma.gameObjective.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GameObjectiveFindManyArgs>(args?: SelectSubset<T, GameObjectiveFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameObjectivePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GameObjective.
     * @param {GameObjectiveCreateArgs} args - Arguments to create a GameObjective.
     * @example
     * // Create one GameObjective
     * const GameObjective = await prisma.gameObjective.create({
     *   data: {
     *     // ... data to create a GameObjective
     *   }
     * })
     * 
     */
    create<T extends GameObjectiveCreateArgs>(args: SelectSubset<T, GameObjectiveCreateArgs<ExtArgs>>): Prisma__GameObjectiveClient<$Result.GetResult<Prisma.$GameObjectivePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GameObjectives.
     * @param {GameObjectiveCreateManyArgs} args - Arguments to create many GameObjectives.
     * @example
     * // Create many GameObjectives
     * const gameObjective = await prisma.gameObjective.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GameObjectiveCreateManyArgs>(args?: SelectSubset<T, GameObjectiveCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a GameObjective.
     * @param {GameObjectiveDeleteArgs} args - Arguments to delete one GameObjective.
     * @example
     * // Delete one GameObjective
     * const GameObjective = await prisma.gameObjective.delete({
     *   where: {
     *     // ... filter to delete one GameObjective
     *   }
     * })
     * 
     */
    delete<T extends GameObjectiveDeleteArgs>(args: SelectSubset<T, GameObjectiveDeleteArgs<ExtArgs>>): Prisma__GameObjectiveClient<$Result.GetResult<Prisma.$GameObjectivePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GameObjective.
     * @param {GameObjectiveUpdateArgs} args - Arguments to update one GameObjective.
     * @example
     * // Update one GameObjective
     * const gameObjective = await prisma.gameObjective.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GameObjectiveUpdateArgs>(args: SelectSubset<T, GameObjectiveUpdateArgs<ExtArgs>>): Prisma__GameObjectiveClient<$Result.GetResult<Prisma.$GameObjectivePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GameObjectives.
     * @param {GameObjectiveDeleteManyArgs} args - Arguments to filter GameObjectives to delete.
     * @example
     * // Delete a few GameObjectives
     * const { count } = await prisma.gameObjective.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GameObjectiveDeleteManyArgs>(args?: SelectSubset<T, GameObjectiveDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GameObjectives.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameObjectiveUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GameObjectives
     * const gameObjective = await prisma.gameObjective.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GameObjectiveUpdateManyArgs>(args: SelectSubset<T, GameObjectiveUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one GameObjective.
     * @param {GameObjectiveUpsertArgs} args - Arguments to update or create a GameObjective.
     * @example
     * // Update or create a GameObjective
     * const gameObjective = await prisma.gameObjective.upsert({
     *   create: {
     *     // ... data to create a GameObjective
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GameObjective we want to update
     *   }
     * })
     */
    upsert<T extends GameObjectiveUpsertArgs>(args: SelectSubset<T, GameObjectiveUpsertArgs<ExtArgs>>): Prisma__GameObjectiveClient<$Result.GetResult<Prisma.$GameObjectivePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GameObjectives that matches the filter.
     * @param {GameObjectiveFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const gameObjective = await prisma.gameObjective.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: GameObjectiveFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a GameObjective.
     * @param {GameObjectiveAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const gameObjective = await prisma.gameObjective.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: GameObjectiveAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of GameObjectives.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameObjectiveCountArgs} args - Arguments to filter GameObjectives to count.
     * @example
     * // Count the number of GameObjectives
     * const count = await prisma.gameObjective.count({
     *   where: {
     *     // ... the filter for the GameObjectives we want to count
     *   }
     * })
    **/
    count<T extends GameObjectiveCountArgs>(
      args?: Subset<T, GameObjectiveCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GameObjectiveCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GameObjective.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameObjectiveAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GameObjectiveAggregateArgs>(args: Subset<T, GameObjectiveAggregateArgs>): Prisma.PrismaPromise<GetGameObjectiveAggregateType<T>>

    /**
     * Group by GameObjective.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameObjectiveGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GameObjectiveGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GameObjectiveGroupByArgs['orderBy'] }
        : { orderBy?: GameObjectiveGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GameObjectiveGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGameObjectiveGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GameObjective model
   */
  readonly fields: GameObjectiveFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GameObjective.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GameObjectiveClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GameObjective model
   */
  interface GameObjectiveFieldRefs {
    readonly id: FieldRef<"GameObjective", 'String'>
    readonly category: FieldRef<"GameObjective", 'String'>
    readonly title: FieldRef<"GameObjective", 'String'>
    readonly image: FieldRef<"GameObjective", 'String'>
    readonly published: FieldRef<"GameObjective", 'Boolean'>
    readonly order: FieldRef<"GameObjective", 'Int'>
    readonly createdAt: FieldRef<"GameObjective", 'DateTime'>
    readonly updatedAt: FieldRef<"GameObjective", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GameObjective findUnique
   */
  export type GameObjectiveFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameObjective
     */
    select?: GameObjectiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameObjective
     */
    omit?: GameObjectiveOmit<ExtArgs> | null
    /**
     * Filter, which GameObjective to fetch.
     */
    where: GameObjectiveWhereUniqueInput
  }

  /**
   * GameObjective findUniqueOrThrow
   */
  export type GameObjectiveFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameObjective
     */
    select?: GameObjectiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameObjective
     */
    omit?: GameObjectiveOmit<ExtArgs> | null
    /**
     * Filter, which GameObjective to fetch.
     */
    where: GameObjectiveWhereUniqueInput
  }

  /**
   * GameObjective findFirst
   */
  export type GameObjectiveFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameObjective
     */
    select?: GameObjectiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameObjective
     */
    omit?: GameObjectiveOmit<ExtArgs> | null
    /**
     * Filter, which GameObjective to fetch.
     */
    where?: GameObjectiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameObjectives to fetch.
     */
    orderBy?: GameObjectiveOrderByWithRelationInput | GameObjectiveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GameObjectives.
     */
    cursor?: GameObjectiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameObjectives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameObjectives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GameObjectives.
     */
    distinct?: GameObjectiveScalarFieldEnum | GameObjectiveScalarFieldEnum[]
  }

  /**
   * GameObjective findFirstOrThrow
   */
  export type GameObjectiveFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameObjective
     */
    select?: GameObjectiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameObjective
     */
    omit?: GameObjectiveOmit<ExtArgs> | null
    /**
     * Filter, which GameObjective to fetch.
     */
    where?: GameObjectiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameObjectives to fetch.
     */
    orderBy?: GameObjectiveOrderByWithRelationInput | GameObjectiveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GameObjectives.
     */
    cursor?: GameObjectiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameObjectives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameObjectives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GameObjectives.
     */
    distinct?: GameObjectiveScalarFieldEnum | GameObjectiveScalarFieldEnum[]
  }

  /**
   * GameObjective findMany
   */
  export type GameObjectiveFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameObjective
     */
    select?: GameObjectiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameObjective
     */
    omit?: GameObjectiveOmit<ExtArgs> | null
    /**
     * Filter, which GameObjectives to fetch.
     */
    where?: GameObjectiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameObjectives to fetch.
     */
    orderBy?: GameObjectiveOrderByWithRelationInput | GameObjectiveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GameObjectives.
     */
    cursor?: GameObjectiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameObjectives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameObjectives.
     */
    skip?: number
    distinct?: GameObjectiveScalarFieldEnum | GameObjectiveScalarFieldEnum[]
  }

  /**
   * GameObjective create
   */
  export type GameObjectiveCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameObjective
     */
    select?: GameObjectiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameObjective
     */
    omit?: GameObjectiveOmit<ExtArgs> | null
    /**
     * The data needed to create a GameObjective.
     */
    data: XOR<GameObjectiveCreateInput, GameObjectiveUncheckedCreateInput>
  }

  /**
   * GameObjective createMany
   */
  export type GameObjectiveCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GameObjectives.
     */
    data: GameObjectiveCreateManyInput | GameObjectiveCreateManyInput[]
  }

  /**
   * GameObjective update
   */
  export type GameObjectiveUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameObjective
     */
    select?: GameObjectiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameObjective
     */
    omit?: GameObjectiveOmit<ExtArgs> | null
    /**
     * The data needed to update a GameObjective.
     */
    data: XOR<GameObjectiveUpdateInput, GameObjectiveUncheckedUpdateInput>
    /**
     * Choose, which GameObjective to update.
     */
    where: GameObjectiveWhereUniqueInput
  }

  /**
   * GameObjective updateMany
   */
  export type GameObjectiveUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GameObjectives.
     */
    data: XOR<GameObjectiveUpdateManyMutationInput, GameObjectiveUncheckedUpdateManyInput>
    /**
     * Filter which GameObjectives to update
     */
    where?: GameObjectiveWhereInput
    /**
     * Limit how many GameObjectives to update.
     */
    limit?: number
  }

  /**
   * GameObjective upsert
   */
  export type GameObjectiveUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameObjective
     */
    select?: GameObjectiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameObjective
     */
    omit?: GameObjectiveOmit<ExtArgs> | null
    /**
     * The filter to search for the GameObjective to update in case it exists.
     */
    where: GameObjectiveWhereUniqueInput
    /**
     * In case the GameObjective found by the `where` argument doesn't exist, create a new GameObjective with this data.
     */
    create: XOR<GameObjectiveCreateInput, GameObjectiveUncheckedCreateInput>
    /**
     * In case the GameObjective was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GameObjectiveUpdateInput, GameObjectiveUncheckedUpdateInput>
  }

  /**
   * GameObjective delete
   */
  export type GameObjectiveDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameObjective
     */
    select?: GameObjectiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameObjective
     */
    omit?: GameObjectiveOmit<ExtArgs> | null
    /**
     * Filter which GameObjective to delete.
     */
    where: GameObjectiveWhereUniqueInput
  }

  /**
   * GameObjective deleteMany
   */
  export type GameObjectiveDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GameObjectives to delete
     */
    where?: GameObjectiveWhereInput
    /**
     * Limit how many GameObjectives to delete.
     */
    limit?: number
  }

  /**
   * GameObjective findRaw
   */
  export type GameObjectiveFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * GameObjective aggregateRaw
   */
  export type GameObjectiveAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * GameObjective without action
   */
  export type GameObjectiveDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameObjective
     */
    select?: GameObjectiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameObjective
     */
    omit?: GameObjectiveOmit<ExtArgs> | null
  }


  /**
   * Model Testimonial
   */

  export type AggregateTestimonial = {
    _count: TestimonialCountAggregateOutputType | null
    _avg: TestimonialAvgAggregateOutputType | null
    _sum: TestimonialSumAggregateOutputType | null
    _min: TestimonialMinAggregateOutputType | null
    _max: TestimonialMaxAggregateOutputType | null
  }

  export type TestimonialAvgAggregateOutputType = {
    order: number | null
  }

  export type TestimonialSumAggregateOutputType = {
    order: number | null
  }

  export type TestimonialMinAggregateOutputType = {
    id: string | null
    quote: string | null
    name: string | null
    designation: string | null
    image: string | null
    order: number | null
    published: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TestimonialMaxAggregateOutputType = {
    id: string | null
    quote: string | null
    name: string | null
    designation: string | null
    image: string | null
    order: number | null
    published: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TestimonialCountAggregateOutputType = {
    id: number
    quote: number
    name: number
    designation: number
    image: number
    order: number
    published: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TestimonialAvgAggregateInputType = {
    order?: true
  }

  export type TestimonialSumAggregateInputType = {
    order?: true
  }

  export type TestimonialMinAggregateInputType = {
    id?: true
    quote?: true
    name?: true
    designation?: true
    image?: true
    order?: true
    published?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TestimonialMaxAggregateInputType = {
    id?: true
    quote?: true
    name?: true
    designation?: true
    image?: true
    order?: true
    published?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TestimonialCountAggregateInputType = {
    id?: true
    quote?: true
    name?: true
    designation?: true
    image?: true
    order?: true
    published?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TestimonialAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Testimonial to aggregate.
     */
    where?: TestimonialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Testimonials to fetch.
     */
    orderBy?: TestimonialOrderByWithRelationInput | TestimonialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TestimonialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Testimonials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Testimonials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Testimonials
    **/
    _count?: true | TestimonialCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TestimonialAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TestimonialSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TestimonialMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TestimonialMaxAggregateInputType
  }

  export type GetTestimonialAggregateType<T extends TestimonialAggregateArgs> = {
        [P in keyof T & keyof AggregateTestimonial]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTestimonial[P]>
      : GetScalarType<T[P], AggregateTestimonial[P]>
  }




  export type TestimonialGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestimonialWhereInput
    orderBy?: TestimonialOrderByWithAggregationInput | TestimonialOrderByWithAggregationInput[]
    by: TestimonialScalarFieldEnum[] | TestimonialScalarFieldEnum
    having?: TestimonialScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TestimonialCountAggregateInputType | true
    _avg?: TestimonialAvgAggregateInputType
    _sum?: TestimonialSumAggregateInputType
    _min?: TestimonialMinAggregateInputType
    _max?: TestimonialMaxAggregateInputType
  }

  export type TestimonialGroupByOutputType = {
    id: string
    quote: string
    name: string
    designation: string
    image: string
    order: number
    published: boolean
    createdAt: Date
    updatedAt: Date
    _count: TestimonialCountAggregateOutputType | null
    _avg: TestimonialAvgAggregateOutputType | null
    _sum: TestimonialSumAggregateOutputType | null
    _min: TestimonialMinAggregateOutputType | null
    _max: TestimonialMaxAggregateOutputType | null
  }

  type GetTestimonialGroupByPayload<T extends TestimonialGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TestimonialGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TestimonialGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TestimonialGroupByOutputType[P]>
            : GetScalarType<T[P], TestimonialGroupByOutputType[P]>
        }
      >
    >


  export type TestimonialSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quote?: boolean
    name?: boolean
    designation?: boolean
    image?: boolean
    order?: boolean
    published?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["testimonial"]>



  export type TestimonialSelectScalar = {
    id?: boolean
    quote?: boolean
    name?: boolean
    designation?: boolean
    image?: boolean
    order?: boolean
    published?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TestimonialOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "quote" | "name" | "designation" | "image" | "order" | "published" | "createdAt" | "updatedAt", ExtArgs["result"]["testimonial"]>

  export type $TestimonialPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Testimonial"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      quote: string
      name: string
      designation: string
      image: string
      order: number
      published: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["testimonial"]>
    composites: {}
  }

  type TestimonialGetPayload<S extends boolean | null | undefined | TestimonialDefaultArgs> = $Result.GetResult<Prisma.$TestimonialPayload, S>

  type TestimonialCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TestimonialFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TestimonialCountAggregateInputType | true
    }

  export interface TestimonialDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Testimonial'], meta: { name: 'Testimonial' } }
    /**
     * Find zero or one Testimonial that matches the filter.
     * @param {TestimonialFindUniqueArgs} args - Arguments to find a Testimonial
     * @example
     * // Get one Testimonial
     * const testimonial = await prisma.testimonial.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TestimonialFindUniqueArgs>(args: SelectSubset<T, TestimonialFindUniqueArgs<ExtArgs>>): Prisma__TestimonialClient<$Result.GetResult<Prisma.$TestimonialPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Testimonial that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TestimonialFindUniqueOrThrowArgs} args - Arguments to find a Testimonial
     * @example
     * // Get one Testimonial
     * const testimonial = await prisma.testimonial.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TestimonialFindUniqueOrThrowArgs>(args: SelectSubset<T, TestimonialFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TestimonialClient<$Result.GetResult<Prisma.$TestimonialPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Testimonial that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestimonialFindFirstArgs} args - Arguments to find a Testimonial
     * @example
     * // Get one Testimonial
     * const testimonial = await prisma.testimonial.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TestimonialFindFirstArgs>(args?: SelectSubset<T, TestimonialFindFirstArgs<ExtArgs>>): Prisma__TestimonialClient<$Result.GetResult<Prisma.$TestimonialPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Testimonial that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestimonialFindFirstOrThrowArgs} args - Arguments to find a Testimonial
     * @example
     * // Get one Testimonial
     * const testimonial = await prisma.testimonial.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TestimonialFindFirstOrThrowArgs>(args?: SelectSubset<T, TestimonialFindFirstOrThrowArgs<ExtArgs>>): Prisma__TestimonialClient<$Result.GetResult<Prisma.$TestimonialPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Testimonials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestimonialFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Testimonials
     * const testimonials = await prisma.testimonial.findMany()
     * 
     * // Get first 10 Testimonials
     * const testimonials = await prisma.testimonial.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const testimonialWithIdOnly = await prisma.testimonial.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TestimonialFindManyArgs>(args?: SelectSubset<T, TestimonialFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestimonialPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Testimonial.
     * @param {TestimonialCreateArgs} args - Arguments to create a Testimonial.
     * @example
     * // Create one Testimonial
     * const Testimonial = await prisma.testimonial.create({
     *   data: {
     *     // ... data to create a Testimonial
     *   }
     * })
     * 
     */
    create<T extends TestimonialCreateArgs>(args: SelectSubset<T, TestimonialCreateArgs<ExtArgs>>): Prisma__TestimonialClient<$Result.GetResult<Prisma.$TestimonialPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Testimonials.
     * @param {TestimonialCreateManyArgs} args - Arguments to create many Testimonials.
     * @example
     * // Create many Testimonials
     * const testimonial = await prisma.testimonial.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TestimonialCreateManyArgs>(args?: SelectSubset<T, TestimonialCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Testimonial.
     * @param {TestimonialDeleteArgs} args - Arguments to delete one Testimonial.
     * @example
     * // Delete one Testimonial
     * const Testimonial = await prisma.testimonial.delete({
     *   where: {
     *     // ... filter to delete one Testimonial
     *   }
     * })
     * 
     */
    delete<T extends TestimonialDeleteArgs>(args: SelectSubset<T, TestimonialDeleteArgs<ExtArgs>>): Prisma__TestimonialClient<$Result.GetResult<Prisma.$TestimonialPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Testimonial.
     * @param {TestimonialUpdateArgs} args - Arguments to update one Testimonial.
     * @example
     * // Update one Testimonial
     * const testimonial = await prisma.testimonial.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TestimonialUpdateArgs>(args: SelectSubset<T, TestimonialUpdateArgs<ExtArgs>>): Prisma__TestimonialClient<$Result.GetResult<Prisma.$TestimonialPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Testimonials.
     * @param {TestimonialDeleteManyArgs} args - Arguments to filter Testimonials to delete.
     * @example
     * // Delete a few Testimonials
     * const { count } = await prisma.testimonial.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TestimonialDeleteManyArgs>(args?: SelectSubset<T, TestimonialDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Testimonials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestimonialUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Testimonials
     * const testimonial = await prisma.testimonial.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TestimonialUpdateManyArgs>(args: SelectSubset<T, TestimonialUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Testimonial.
     * @param {TestimonialUpsertArgs} args - Arguments to update or create a Testimonial.
     * @example
     * // Update or create a Testimonial
     * const testimonial = await prisma.testimonial.upsert({
     *   create: {
     *     // ... data to create a Testimonial
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Testimonial we want to update
     *   }
     * })
     */
    upsert<T extends TestimonialUpsertArgs>(args: SelectSubset<T, TestimonialUpsertArgs<ExtArgs>>): Prisma__TestimonialClient<$Result.GetResult<Prisma.$TestimonialPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Testimonials that matches the filter.
     * @param {TestimonialFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const testimonial = await prisma.testimonial.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: TestimonialFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Testimonial.
     * @param {TestimonialAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const testimonial = await prisma.testimonial.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: TestimonialAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Testimonials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestimonialCountArgs} args - Arguments to filter Testimonials to count.
     * @example
     * // Count the number of Testimonials
     * const count = await prisma.testimonial.count({
     *   where: {
     *     // ... the filter for the Testimonials we want to count
     *   }
     * })
    **/
    count<T extends TestimonialCountArgs>(
      args?: Subset<T, TestimonialCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TestimonialCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Testimonial.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestimonialAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TestimonialAggregateArgs>(args: Subset<T, TestimonialAggregateArgs>): Prisma.PrismaPromise<GetTestimonialAggregateType<T>>

    /**
     * Group by Testimonial.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestimonialGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TestimonialGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TestimonialGroupByArgs['orderBy'] }
        : { orderBy?: TestimonialGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TestimonialGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTestimonialGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Testimonial model
   */
  readonly fields: TestimonialFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Testimonial.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TestimonialClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Testimonial model
   */
  interface TestimonialFieldRefs {
    readonly id: FieldRef<"Testimonial", 'String'>
    readonly quote: FieldRef<"Testimonial", 'String'>
    readonly name: FieldRef<"Testimonial", 'String'>
    readonly designation: FieldRef<"Testimonial", 'String'>
    readonly image: FieldRef<"Testimonial", 'String'>
    readonly order: FieldRef<"Testimonial", 'Int'>
    readonly published: FieldRef<"Testimonial", 'Boolean'>
    readonly createdAt: FieldRef<"Testimonial", 'DateTime'>
    readonly updatedAt: FieldRef<"Testimonial", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Testimonial findUnique
   */
  export type TestimonialFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Testimonial
     */
    select?: TestimonialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Testimonial
     */
    omit?: TestimonialOmit<ExtArgs> | null
    /**
     * Filter, which Testimonial to fetch.
     */
    where: TestimonialWhereUniqueInput
  }

  /**
   * Testimonial findUniqueOrThrow
   */
  export type TestimonialFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Testimonial
     */
    select?: TestimonialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Testimonial
     */
    omit?: TestimonialOmit<ExtArgs> | null
    /**
     * Filter, which Testimonial to fetch.
     */
    where: TestimonialWhereUniqueInput
  }

  /**
   * Testimonial findFirst
   */
  export type TestimonialFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Testimonial
     */
    select?: TestimonialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Testimonial
     */
    omit?: TestimonialOmit<ExtArgs> | null
    /**
     * Filter, which Testimonial to fetch.
     */
    where?: TestimonialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Testimonials to fetch.
     */
    orderBy?: TestimonialOrderByWithRelationInput | TestimonialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Testimonials.
     */
    cursor?: TestimonialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Testimonials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Testimonials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Testimonials.
     */
    distinct?: TestimonialScalarFieldEnum | TestimonialScalarFieldEnum[]
  }

  /**
   * Testimonial findFirstOrThrow
   */
  export type TestimonialFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Testimonial
     */
    select?: TestimonialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Testimonial
     */
    omit?: TestimonialOmit<ExtArgs> | null
    /**
     * Filter, which Testimonial to fetch.
     */
    where?: TestimonialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Testimonials to fetch.
     */
    orderBy?: TestimonialOrderByWithRelationInput | TestimonialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Testimonials.
     */
    cursor?: TestimonialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Testimonials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Testimonials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Testimonials.
     */
    distinct?: TestimonialScalarFieldEnum | TestimonialScalarFieldEnum[]
  }

  /**
   * Testimonial findMany
   */
  export type TestimonialFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Testimonial
     */
    select?: TestimonialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Testimonial
     */
    omit?: TestimonialOmit<ExtArgs> | null
    /**
     * Filter, which Testimonials to fetch.
     */
    where?: TestimonialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Testimonials to fetch.
     */
    orderBy?: TestimonialOrderByWithRelationInput | TestimonialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Testimonials.
     */
    cursor?: TestimonialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Testimonials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Testimonials.
     */
    skip?: number
    distinct?: TestimonialScalarFieldEnum | TestimonialScalarFieldEnum[]
  }

  /**
   * Testimonial create
   */
  export type TestimonialCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Testimonial
     */
    select?: TestimonialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Testimonial
     */
    omit?: TestimonialOmit<ExtArgs> | null
    /**
     * The data needed to create a Testimonial.
     */
    data: XOR<TestimonialCreateInput, TestimonialUncheckedCreateInput>
  }

  /**
   * Testimonial createMany
   */
  export type TestimonialCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Testimonials.
     */
    data: TestimonialCreateManyInput | TestimonialCreateManyInput[]
  }

  /**
   * Testimonial update
   */
  export type TestimonialUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Testimonial
     */
    select?: TestimonialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Testimonial
     */
    omit?: TestimonialOmit<ExtArgs> | null
    /**
     * The data needed to update a Testimonial.
     */
    data: XOR<TestimonialUpdateInput, TestimonialUncheckedUpdateInput>
    /**
     * Choose, which Testimonial to update.
     */
    where: TestimonialWhereUniqueInput
  }

  /**
   * Testimonial updateMany
   */
  export type TestimonialUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Testimonials.
     */
    data: XOR<TestimonialUpdateManyMutationInput, TestimonialUncheckedUpdateManyInput>
    /**
     * Filter which Testimonials to update
     */
    where?: TestimonialWhereInput
    /**
     * Limit how many Testimonials to update.
     */
    limit?: number
  }

  /**
   * Testimonial upsert
   */
  export type TestimonialUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Testimonial
     */
    select?: TestimonialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Testimonial
     */
    omit?: TestimonialOmit<ExtArgs> | null
    /**
     * The filter to search for the Testimonial to update in case it exists.
     */
    where: TestimonialWhereUniqueInput
    /**
     * In case the Testimonial found by the `where` argument doesn't exist, create a new Testimonial with this data.
     */
    create: XOR<TestimonialCreateInput, TestimonialUncheckedCreateInput>
    /**
     * In case the Testimonial was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TestimonialUpdateInput, TestimonialUncheckedUpdateInput>
  }

  /**
   * Testimonial delete
   */
  export type TestimonialDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Testimonial
     */
    select?: TestimonialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Testimonial
     */
    omit?: TestimonialOmit<ExtArgs> | null
    /**
     * Filter which Testimonial to delete.
     */
    where: TestimonialWhereUniqueInput
  }

  /**
   * Testimonial deleteMany
   */
  export type TestimonialDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Testimonials to delete
     */
    where?: TestimonialWhereInput
    /**
     * Limit how many Testimonials to delete.
     */
    limit?: number
  }

  /**
   * Testimonial findRaw
   */
  export type TestimonialFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Testimonial aggregateRaw
   */
  export type TestimonialAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Testimonial without action
   */
  export type TestimonialDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Testimonial
     */
    select?: TestimonialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Testimonial
     */
    omit?: TestimonialOmit<ExtArgs> | null
  }


  /**
   * Model SiteSettings
   */

  export type AggregateSiteSettings = {
    _count: SiteSettingsCountAggregateOutputType | null
    _min: SiteSettingsMinAggregateOutputType | null
    _max: SiteSettingsMaxAggregateOutputType | null
  }

  export type SiteSettingsMinAggregateOutputType = {
    id: string | null
    heroBackgroundImage: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SiteSettingsMaxAggregateOutputType = {
    id: string | null
    heroBackgroundImage: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SiteSettingsCountAggregateOutputType = {
    id: number
    heroBackgroundImage: number
    header: number
    pages: number
    footer: number
    homeSections: number
    aboutHomeSection: number
    aboutPage: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SiteSettingsMinAggregateInputType = {
    id?: true
    heroBackgroundImage?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SiteSettingsMaxAggregateInputType = {
    id?: true
    heroBackgroundImage?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SiteSettingsCountAggregateInputType = {
    id?: true
    heroBackgroundImage?: true
    header?: true
    pages?: true
    footer?: true
    homeSections?: true
    aboutHomeSection?: true
    aboutPage?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SiteSettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SiteSettings to aggregate.
     */
    where?: SiteSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SiteSettings to fetch.
     */
    orderBy?: SiteSettingsOrderByWithRelationInput | SiteSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SiteSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SiteSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SiteSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SiteSettings
    **/
    _count?: true | SiteSettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SiteSettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SiteSettingsMaxAggregateInputType
  }

  export type GetSiteSettingsAggregateType<T extends SiteSettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateSiteSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSiteSettings[P]>
      : GetScalarType<T[P], AggregateSiteSettings[P]>
  }




  export type SiteSettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SiteSettingsWhereInput
    orderBy?: SiteSettingsOrderByWithAggregationInput | SiteSettingsOrderByWithAggregationInput[]
    by: SiteSettingsScalarFieldEnum[] | SiteSettingsScalarFieldEnum
    having?: SiteSettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SiteSettingsCountAggregateInputType | true
    _min?: SiteSettingsMinAggregateInputType
    _max?: SiteSettingsMaxAggregateInputType
  }

  export type SiteSettingsGroupByOutputType = {
    id: string
    heroBackgroundImage: string
    header: JsonValue
    pages: JsonValue
    footer: JsonValue
    homeSections: JsonValue
    aboutHomeSection: JsonValue | null
    aboutPage: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: SiteSettingsCountAggregateOutputType | null
    _min: SiteSettingsMinAggregateOutputType | null
    _max: SiteSettingsMaxAggregateOutputType | null
  }

  type GetSiteSettingsGroupByPayload<T extends SiteSettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SiteSettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SiteSettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SiteSettingsGroupByOutputType[P]>
            : GetScalarType<T[P], SiteSettingsGroupByOutputType[P]>
        }
      >
    >


  export type SiteSettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    heroBackgroundImage?: boolean
    header?: boolean
    pages?: boolean
    footer?: boolean
    homeSections?: boolean
    aboutHomeSection?: boolean
    aboutPage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["siteSettings"]>



  export type SiteSettingsSelectScalar = {
    id?: boolean
    heroBackgroundImage?: boolean
    header?: boolean
    pages?: boolean
    footer?: boolean
    homeSections?: boolean
    aboutHomeSection?: boolean
    aboutPage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SiteSettingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "heroBackgroundImage" | "header" | "pages" | "footer" | "homeSections" | "aboutHomeSection" | "aboutPage" | "createdAt" | "updatedAt", ExtArgs["result"]["siteSettings"]>

  export type $SiteSettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SiteSettings"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      heroBackgroundImage: string
      header: Prisma.JsonValue
      pages: Prisma.JsonValue
      footer: Prisma.JsonValue
      homeSections: Prisma.JsonValue
      aboutHomeSection: Prisma.JsonValue | null
      aboutPage: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["siteSettings"]>
    composites: {}
  }

  type SiteSettingsGetPayload<S extends boolean | null | undefined | SiteSettingsDefaultArgs> = $Result.GetResult<Prisma.$SiteSettingsPayload, S>

  type SiteSettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SiteSettingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SiteSettingsCountAggregateInputType | true
    }

  export interface SiteSettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SiteSettings'], meta: { name: 'SiteSettings' } }
    /**
     * Find zero or one SiteSettings that matches the filter.
     * @param {SiteSettingsFindUniqueArgs} args - Arguments to find a SiteSettings
     * @example
     * // Get one SiteSettings
     * const siteSettings = await prisma.siteSettings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SiteSettingsFindUniqueArgs>(args: SelectSubset<T, SiteSettingsFindUniqueArgs<ExtArgs>>): Prisma__SiteSettingsClient<$Result.GetResult<Prisma.$SiteSettingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SiteSettings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SiteSettingsFindUniqueOrThrowArgs} args - Arguments to find a SiteSettings
     * @example
     * // Get one SiteSettings
     * const siteSettings = await prisma.siteSettings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SiteSettingsFindUniqueOrThrowArgs>(args: SelectSubset<T, SiteSettingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SiteSettingsClient<$Result.GetResult<Prisma.$SiteSettingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SiteSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteSettingsFindFirstArgs} args - Arguments to find a SiteSettings
     * @example
     * // Get one SiteSettings
     * const siteSettings = await prisma.siteSettings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SiteSettingsFindFirstArgs>(args?: SelectSubset<T, SiteSettingsFindFirstArgs<ExtArgs>>): Prisma__SiteSettingsClient<$Result.GetResult<Prisma.$SiteSettingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SiteSettings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteSettingsFindFirstOrThrowArgs} args - Arguments to find a SiteSettings
     * @example
     * // Get one SiteSettings
     * const siteSettings = await prisma.siteSettings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SiteSettingsFindFirstOrThrowArgs>(args?: SelectSubset<T, SiteSettingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__SiteSettingsClient<$Result.GetResult<Prisma.$SiteSettingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SiteSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteSettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SiteSettings
     * const siteSettings = await prisma.siteSettings.findMany()
     * 
     * // Get first 10 SiteSettings
     * const siteSettings = await prisma.siteSettings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const siteSettingsWithIdOnly = await prisma.siteSettings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SiteSettingsFindManyArgs>(args?: SelectSubset<T, SiteSettingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SiteSettingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SiteSettings.
     * @param {SiteSettingsCreateArgs} args - Arguments to create a SiteSettings.
     * @example
     * // Create one SiteSettings
     * const SiteSettings = await prisma.siteSettings.create({
     *   data: {
     *     // ... data to create a SiteSettings
     *   }
     * })
     * 
     */
    create<T extends SiteSettingsCreateArgs>(args: SelectSubset<T, SiteSettingsCreateArgs<ExtArgs>>): Prisma__SiteSettingsClient<$Result.GetResult<Prisma.$SiteSettingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SiteSettings.
     * @param {SiteSettingsCreateManyArgs} args - Arguments to create many SiteSettings.
     * @example
     * // Create many SiteSettings
     * const siteSettings = await prisma.siteSettings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SiteSettingsCreateManyArgs>(args?: SelectSubset<T, SiteSettingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SiteSettings.
     * @param {SiteSettingsDeleteArgs} args - Arguments to delete one SiteSettings.
     * @example
     * // Delete one SiteSettings
     * const SiteSettings = await prisma.siteSettings.delete({
     *   where: {
     *     // ... filter to delete one SiteSettings
     *   }
     * })
     * 
     */
    delete<T extends SiteSettingsDeleteArgs>(args: SelectSubset<T, SiteSettingsDeleteArgs<ExtArgs>>): Prisma__SiteSettingsClient<$Result.GetResult<Prisma.$SiteSettingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SiteSettings.
     * @param {SiteSettingsUpdateArgs} args - Arguments to update one SiteSettings.
     * @example
     * // Update one SiteSettings
     * const siteSettings = await prisma.siteSettings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SiteSettingsUpdateArgs>(args: SelectSubset<T, SiteSettingsUpdateArgs<ExtArgs>>): Prisma__SiteSettingsClient<$Result.GetResult<Prisma.$SiteSettingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SiteSettings.
     * @param {SiteSettingsDeleteManyArgs} args - Arguments to filter SiteSettings to delete.
     * @example
     * // Delete a few SiteSettings
     * const { count } = await prisma.siteSettings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SiteSettingsDeleteManyArgs>(args?: SelectSubset<T, SiteSettingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SiteSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteSettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SiteSettings
     * const siteSettings = await prisma.siteSettings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SiteSettingsUpdateManyArgs>(args: SelectSubset<T, SiteSettingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SiteSettings.
     * @param {SiteSettingsUpsertArgs} args - Arguments to update or create a SiteSettings.
     * @example
     * // Update or create a SiteSettings
     * const siteSettings = await prisma.siteSettings.upsert({
     *   create: {
     *     // ... data to create a SiteSettings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SiteSettings we want to update
     *   }
     * })
     */
    upsert<T extends SiteSettingsUpsertArgs>(args: SelectSubset<T, SiteSettingsUpsertArgs<ExtArgs>>): Prisma__SiteSettingsClient<$Result.GetResult<Prisma.$SiteSettingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SiteSettings that matches the filter.
     * @param {SiteSettingsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const siteSettings = await prisma.siteSettings.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: SiteSettingsFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a SiteSettings.
     * @param {SiteSettingsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const siteSettings = await prisma.siteSettings.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: SiteSettingsAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of SiteSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteSettingsCountArgs} args - Arguments to filter SiteSettings to count.
     * @example
     * // Count the number of SiteSettings
     * const count = await prisma.siteSettings.count({
     *   where: {
     *     // ... the filter for the SiteSettings we want to count
     *   }
     * })
    **/
    count<T extends SiteSettingsCountArgs>(
      args?: Subset<T, SiteSettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SiteSettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SiteSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteSettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SiteSettingsAggregateArgs>(args: Subset<T, SiteSettingsAggregateArgs>): Prisma.PrismaPromise<GetSiteSettingsAggregateType<T>>

    /**
     * Group by SiteSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteSettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SiteSettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SiteSettingsGroupByArgs['orderBy'] }
        : { orderBy?: SiteSettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SiteSettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSiteSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SiteSettings model
   */
  readonly fields: SiteSettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SiteSettings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SiteSettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SiteSettings model
   */
  interface SiteSettingsFieldRefs {
    readonly id: FieldRef<"SiteSettings", 'String'>
    readonly heroBackgroundImage: FieldRef<"SiteSettings", 'String'>
    readonly header: FieldRef<"SiteSettings", 'Json'>
    readonly pages: FieldRef<"SiteSettings", 'Json'>
    readonly footer: FieldRef<"SiteSettings", 'Json'>
    readonly homeSections: FieldRef<"SiteSettings", 'Json'>
    readonly aboutHomeSection: FieldRef<"SiteSettings", 'Json'>
    readonly aboutPage: FieldRef<"SiteSettings", 'Json'>
    readonly createdAt: FieldRef<"SiteSettings", 'DateTime'>
    readonly updatedAt: FieldRef<"SiteSettings", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SiteSettings findUnique
   */
  export type SiteSettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteSettings
     */
    select?: SiteSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteSettings
     */
    omit?: SiteSettingsOmit<ExtArgs> | null
    /**
     * Filter, which SiteSettings to fetch.
     */
    where: SiteSettingsWhereUniqueInput
  }

  /**
   * SiteSettings findUniqueOrThrow
   */
  export type SiteSettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteSettings
     */
    select?: SiteSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteSettings
     */
    omit?: SiteSettingsOmit<ExtArgs> | null
    /**
     * Filter, which SiteSettings to fetch.
     */
    where: SiteSettingsWhereUniqueInput
  }

  /**
   * SiteSettings findFirst
   */
  export type SiteSettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteSettings
     */
    select?: SiteSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteSettings
     */
    omit?: SiteSettingsOmit<ExtArgs> | null
    /**
     * Filter, which SiteSettings to fetch.
     */
    where?: SiteSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SiteSettings to fetch.
     */
    orderBy?: SiteSettingsOrderByWithRelationInput | SiteSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SiteSettings.
     */
    cursor?: SiteSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SiteSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SiteSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SiteSettings.
     */
    distinct?: SiteSettingsScalarFieldEnum | SiteSettingsScalarFieldEnum[]
  }

  /**
   * SiteSettings findFirstOrThrow
   */
  export type SiteSettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteSettings
     */
    select?: SiteSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteSettings
     */
    omit?: SiteSettingsOmit<ExtArgs> | null
    /**
     * Filter, which SiteSettings to fetch.
     */
    where?: SiteSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SiteSettings to fetch.
     */
    orderBy?: SiteSettingsOrderByWithRelationInput | SiteSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SiteSettings.
     */
    cursor?: SiteSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SiteSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SiteSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SiteSettings.
     */
    distinct?: SiteSettingsScalarFieldEnum | SiteSettingsScalarFieldEnum[]
  }

  /**
   * SiteSettings findMany
   */
  export type SiteSettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteSettings
     */
    select?: SiteSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteSettings
     */
    omit?: SiteSettingsOmit<ExtArgs> | null
    /**
     * Filter, which SiteSettings to fetch.
     */
    where?: SiteSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SiteSettings to fetch.
     */
    orderBy?: SiteSettingsOrderByWithRelationInput | SiteSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SiteSettings.
     */
    cursor?: SiteSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SiteSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SiteSettings.
     */
    skip?: number
    distinct?: SiteSettingsScalarFieldEnum | SiteSettingsScalarFieldEnum[]
  }

  /**
   * SiteSettings create
   */
  export type SiteSettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteSettings
     */
    select?: SiteSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteSettings
     */
    omit?: SiteSettingsOmit<ExtArgs> | null
    /**
     * The data needed to create a SiteSettings.
     */
    data: XOR<SiteSettingsCreateInput, SiteSettingsUncheckedCreateInput>
  }

  /**
   * SiteSettings createMany
   */
  export type SiteSettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SiteSettings.
     */
    data: SiteSettingsCreateManyInput | SiteSettingsCreateManyInput[]
  }

  /**
   * SiteSettings update
   */
  export type SiteSettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteSettings
     */
    select?: SiteSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteSettings
     */
    omit?: SiteSettingsOmit<ExtArgs> | null
    /**
     * The data needed to update a SiteSettings.
     */
    data: XOR<SiteSettingsUpdateInput, SiteSettingsUncheckedUpdateInput>
    /**
     * Choose, which SiteSettings to update.
     */
    where: SiteSettingsWhereUniqueInput
  }

  /**
   * SiteSettings updateMany
   */
  export type SiteSettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SiteSettings.
     */
    data: XOR<SiteSettingsUpdateManyMutationInput, SiteSettingsUncheckedUpdateManyInput>
    /**
     * Filter which SiteSettings to update
     */
    where?: SiteSettingsWhereInput
    /**
     * Limit how many SiteSettings to update.
     */
    limit?: number
  }

  /**
   * SiteSettings upsert
   */
  export type SiteSettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteSettings
     */
    select?: SiteSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteSettings
     */
    omit?: SiteSettingsOmit<ExtArgs> | null
    /**
     * The filter to search for the SiteSettings to update in case it exists.
     */
    where: SiteSettingsWhereUniqueInput
    /**
     * In case the SiteSettings found by the `where` argument doesn't exist, create a new SiteSettings with this data.
     */
    create: XOR<SiteSettingsCreateInput, SiteSettingsUncheckedCreateInput>
    /**
     * In case the SiteSettings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SiteSettingsUpdateInput, SiteSettingsUncheckedUpdateInput>
  }

  /**
   * SiteSettings delete
   */
  export type SiteSettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteSettings
     */
    select?: SiteSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteSettings
     */
    omit?: SiteSettingsOmit<ExtArgs> | null
    /**
     * Filter which SiteSettings to delete.
     */
    where: SiteSettingsWhereUniqueInput
  }

  /**
   * SiteSettings deleteMany
   */
  export type SiteSettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SiteSettings to delete
     */
    where?: SiteSettingsWhereInput
    /**
     * Limit how many SiteSettings to delete.
     */
    limit?: number
  }

  /**
   * SiteSettings findRaw
   */
  export type SiteSettingsFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * SiteSettings aggregateRaw
   */
  export type SiteSettingsAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * SiteSettings without action
   */
  export type SiteSettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteSettings
     */
    select?: SiteSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteSettings
     */
    omit?: SiteSettingsOmit<ExtArgs> | null
  }


  /**
   * Model Investor
   */

  export type AggregateInvestor = {
    _count: InvestorCountAggregateOutputType | null
    _avg: InvestorAvgAggregateOutputType | null
    _sum: InvestorSumAggregateOutputType | null
    _min: InvestorMinAggregateOutputType | null
    _max: InvestorMaxAggregateOutputType | null
  }

  export type InvestorAvgAggregateOutputType = {
    order: number | null
  }

  export type InvestorSumAggregateOutputType = {
    order: number | null
  }

  export type InvestorMinAggregateOutputType = {
    id: string | null
    name: string | null
    logo: string | null
    url: string | null
    order: number | null
    published: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvestorMaxAggregateOutputType = {
    id: string | null
    name: string | null
    logo: string | null
    url: string | null
    order: number | null
    published: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvestorCountAggregateOutputType = {
    id: number
    name: number
    logo: number
    url: number
    order: number
    published: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InvestorAvgAggregateInputType = {
    order?: true
  }

  export type InvestorSumAggregateInputType = {
    order?: true
  }

  export type InvestorMinAggregateInputType = {
    id?: true
    name?: true
    logo?: true
    url?: true
    order?: true
    published?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvestorMaxAggregateInputType = {
    id?: true
    name?: true
    logo?: true
    url?: true
    order?: true
    published?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvestorCountAggregateInputType = {
    id?: true
    name?: true
    logo?: true
    url?: true
    order?: true
    published?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InvestorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Investor to aggregate.
     */
    where?: InvestorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Investors to fetch.
     */
    orderBy?: InvestorOrderByWithRelationInput | InvestorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvestorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Investors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Investors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Investors
    **/
    _count?: true | InvestorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvestorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvestorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvestorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvestorMaxAggregateInputType
  }

  export type GetInvestorAggregateType<T extends InvestorAggregateArgs> = {
        [P in keyof T & keyof AggregateInvestor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvestor[P]>
      : GetScalarType<T[P], AggregateInvestor[P]>
  }




  export type InvestorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvestorWhereInput
    orderBy?: InvestorOrderByWithAggregationInput | InvestorOrderByWithAggregationInput[]
    by: InvestorScalarFieldEnum[] | InvestorScalarFieldEnum
    having?: InvestorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvestorCountAggregateInputType | true
    _avg?: InvestorAvgAggregateInputType
    _sum?: InvestorSumAggregateInputType
    _min?: InvestorMinAggregateInputType
    _max?: InvestorMaxAggregateInputType
  }

  export type InvestorGroupByOutputType = {
    id: string
    name: string | null
    logo: string
    url: string | null
    order: number
    published: boolean
    createdAt: Date
    updatedAt: Date
    _count: InvestorCountAggregateOutputType | null
    _avg: InvestorAvgAggregateOutputType | null
    _sum: InvestorSumAggregateOutputType | null
    _min: InvestorMinAggregateOutputType | null
    _max: InvestorMaxAggregateOutputType | null
  }

  type GetInvestorGroupByPayload<T extends InvestorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvestorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvestorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvestorGroupByOutputType[P]>
            : GetScalarType<T[P], InvestorGroupByOutputType[P]>
        }
      >
    >


  export type InvestorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    logo?: boolean
    url?: boolean
    order?: boolean
    published?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["investor"]>



  export type InvestorSelectScalar = {
    id?: boolean
    name?: boolean
    logo?: boolean
    url?: boolean
    order?: boolean
    published?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InvestorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "logo" | "url" | "order" | "published" | "createdAt" | "updatedAt", ExtArgs["result"]["investor"]>

  export type $InvestorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Investor"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string | null
      logo: string
      url: string | null
      order: number
      published: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["investor"]>
    composites: {}
  }

  type InvestorGetPayload<S extends boolean | null | undefined | InvestorDefaultArgs> = $Result.GetResult<Prisma.$InvestorPayload, S>

  type InvestorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InvestorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InvestorCountAggregateInputType | true
    }

  export interface InvestorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Investor'], meta: { name: 'Investor' } }
    /**
     * Find zero or one Investor that matches the filter.
     * @param {InvestorFindUniqueArgs} args - Arguments to find a Investor
     * @example
     * // Get one Investor
     * const investor = await prisma.investor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvestorFindUniqueArgs>(args: SelectSubset<T, InvestorFindUniqueArgs<ExtArgs>>): Prisma__InvestorClient<$Result.GetResult<Prisma.$InvestorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Investor that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InvestorFindUniqueOrThrowArgs} args - Arguments to find a Investor
     * @example
     * // Get one Investor
     * const investor = await prisma.investor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvestorFindUniqueOrThrowArgs>(args: SelectSubset<T, InvestorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvestorClient<$Result.GetResult<Prisma.$InvestorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Investor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestorFindFirstArgs} args - Arguments to find a Investor
     * @example
     * // Get one Investor
     * const investor = await prisma.investor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvestorFindFirstArgs>(args?: SelectSubset<T, InvestorFindFirstArgs<ExtArgs>>): Prisma__InvestorClient<$Result.GetResult<Prisma.$InvestorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Investor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestorFindFirstOrThrowArgs} args - Arguments to find a Investor
     * @example
     * // Get one Investor
     * const investor = await prisma.investor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvestorFindFirstOrThrowArgs>(args?: SelectSubset<T, InvestorFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvestorClient<$Result.GetResult<Prisma.$InvestorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Investors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Investors
     * const investors = await prisma.investor.findMany()
     * 
     * // Get first 10 Investors
     * const investors = await prisma.investor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const investorWithIdOnly = await prisma.investor.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvestorFindManyArgs>(args?: SelectSubset<T, InvestorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvestorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Investor.
     * @param {InvestorCreateArgs} args - Arguments to create a Investor.
     * @example
     * // Create one Investor
     * const Investor = await prisma.investor.create({
     *   data: {
     *     // ... data to create a Investor
     *   }
     * })
     * 
     */
    create<T extends InvestorCreateArgs>(args: SelectSubset<T, InvestorCreateArgs<ExtArgs>>): Prisma__InvestorClient<$Result.GetResult<Prisma.$InvestorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Investors.
     * @param {InvestorCreateManyArgs} args - Arguments to create many Investors.
     * @example
     * // Create many Investors
     * const investor = await prisma.investor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvestorCreateManyArgs>(args?: SelectSubset<T, InvestorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Investor.
     * @param {InvestorDeleteArgs} args - Arguments to delete one Investor.
     * @example
     * // Delete one Investor
     * const Investor = await prisma.investor.delete({
     *   where: {
     *     // ... filter to delete one Investor
     *   }
     * })
     * 
     */
    delete<T extends InvestorDeleteArgs>(args: SelectSubset<T, InvestorDeleteArgs<ExtArgs>>): Prisma__InvestorClient<$Result.GetResult<Prisma.$InvestorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Investor.
     * @param {InvestorUpdateArgs} args - Arguments to update one Investor.
     * @example
     * // Update one Investor
     * const investor = await prisma.investor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvestorUpdateArgs>(args: SelectSubset<T, InvestorUpdateArgs<ExtArgs>>): Prisma__InvestorClient<$Result.GetResult<Prisma.$InvestorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Investors.
     * @param {InvestorDeleteManyArgs} args - Arguments to filter Investors to delete.
     * @example
     * // Delete a few Investors
     * const { count } = await prisma.investor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvestorDeleteManyArgs>(args?: SelectSubset<T, InvestorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Investors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Investors
     * const investor = await prisma.investor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvestorUpdateManyArgs>(args: SelectSubset<T, InvestorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Investor.
     * @param {InvestorUpsertArgs} args - Arguments to update or create a Investor.
     * @example
     * // Update or create a Investor
     * const investor = await prisma.investor.upsert({
     *   create: {
     *     // ... data to create a Investor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Investor we want to update
     *   }
     * })
     */
    upsert<T extends InvestorUpsertArgs>(args: SelectSubset<T, InvestorUpsertArgs<ExtArgs>>): Prisma__InvestorClient<$Result.GetResult<Prisma.$InvestorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Investors that matches the filter.
     * @param {InvestorFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const investor = await prisma.investor.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: InvestorFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Investor.
     * @param {InvestorAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const investor = await prisma.investor.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: InvestorAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Investors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestorCountArgs} args - Arguments to filter Investors to count.
     * @example
     * // Count the number of Investors
     * const count = await prisma.investor.count({
     *   where: {
     *     // ... the filter for the Investors we want to count
     *   }
     * })
    **/
    count<T extends InvestorCountArgs>(
      args?: Subset<T, InvestorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvestorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Investor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvestorAggregateArgs>(args: Subset<T, InvestorAggregateArgs>): Prisma.PrismaPromise<GetInvestorAggregateType<T>>

    /**
     * Group by Investor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvestorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvestorGroupByArgs['orderBy'] }
        : { orderBy?: InvestorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvestorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvestorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Investor model
   */
  readonly fields: InvestorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Investor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvestorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Investor model
   */
  interface InvestorFieldRefs {
    readonly id: FieldRef<"Investor", 'String'>
    readonly name: FieldRef<"Investor", 'String'>
    readonly logo: FieldRef<"Investor", 'String'>
    readonly url: FieldRef<"Investor", 'String'>
    readonly order: FieldRef<"Investor", 'Int'>
    readonly published: FieldRef<"Investor", 'Boolean'>
    readonly createdAt: FieldRef<"Investor", 'DateTime'>
    readonly updatedAt: FieldRef<"Investor", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Investor findUnique
   */
  export type InvestorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investor
     */
    select?: InvestorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Investor
     */
    omit?: InvestorOmit<ExtArgs> | null
    /**
     * Filter, which Investor to fetch.
     */
    where: InvestorWhereUniqueInput
  }

  /**
   * Investor findUniqueOrThrow
   */
  export type InvestorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investor
     */
    select?: InvestorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Investor
     */
    omit?: InvestorOmit<ExtArgs> | null
    /**
     * Filter, which Investor to fetch.
     */
    where: InvestorWhereUniqueInput
  }

  /**
   * Investor findFirst
   */
  export type InvestorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investor
     */
    select?: InvestorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Investor
     */
    omit?: InvestorOmit<ExtArgs> | null
    /**
     * Filter, which Investor to fetch.
     */
    where?: InvestorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Investors to fetch.
     */
    orderBy?: InvestorOrderByWithRelationInput | InvestorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Investors.
     */
    cursor?: InvestorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Investors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Investors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Investors.
     */
    distinct?: InvestorScalarFieldEnum | InvestorScalarFieldEnum[]
  }

  /**
   * Investor findFirstOrThrow
   */
  export type InvestorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investor
     */
    select?: InvestorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Investor
     */
    omit?: InvestorOmit<ExtArgs> | null
    /**
     * Filter, which Investor to fetch.
     */
    where?: InvestorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Investors to fetch.
     */
    orderBy?: InvestorOrderByWithRelationInput | InvestorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Investors.
     */
    cursor?: InvestorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Investors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Investors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Investors.
     */
    distinct?: InvestorScalarFieldEnum | InvestorScalarFieldEnum[]
  }

  /**
   * Investor findMany
   */
  export type InvestorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investor
     */
    select?: InvestorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Investor
     */
    omit?: InvestorOmit<ExtArgs> | null
    /**
     * Filter, which Investors to fetch.
     */
    where?: InvestorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Investors to fetch.
     */
    orderBy?: InvestorOrderByWithRelationInput | InvestorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Investors.
     */
    cursor?: InvestorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Investors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Investors.
     */
    skip?: number
    distinct?: InvestorScalarFieldEnum | InvestorScalarFieldEnum[]
  }

  /**
   * Investor create
   */
  export type InvestorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investor
     */
    select?: InvestorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Investor
     */
    omit?: InvestorOmit<ExtArgs> | null
    /**
     * The data needed to create a Investor.
     */
    data: XOR<InvestorCreateInput, InvestorUncheckedCreateInput>
  }

  /**
   * Investor createMany
   */
  export type InvestorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Investors.
     */
    data: InvestorCreateManyInput | InvestorCreateManyInput[]
  }

  /**
   * Investor update
   */
  export type InvestorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investor
     */
    select?: InvestorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Investor
     */
    omit?: InvestorOmit<ExtArgs> | null
    /**
     * The data needed to update a Investor.
     */
    data: XOR<InvestorUpdateInput, InvestorUncheckedUpdateInput>
    /**
     * Choose, which Investor to update.
     */
    where: InvestorWhereUniqueInput
  }

  /**
   * Investor updateMany
   */
  export type InvestorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Investors.
     */
    data: XOR<InvestorUpdateManyMutationInput, InvestorUncheckedUpdateManyInput>
    /**
     * Filter which Investors to update
     */
    where?: InvestorWhereInput
    /**
     * Limit how many Investors to update.
     */
    limit?: number
  }

  /**
   * Investor upsert
   */
  export type InvestorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investor
     */
    select?: InvestorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Investor
     */
    omit?: InvestorOmit<ExtArgs> | null
    /**
     * The filter to search for the Investor to update in case it exists.
     */
    where: InvestorWhereUniqueInput
    /**
     * In case the Investor found by the `where` argument doesn't exist, create a new Investor with this data.
     */
    create: XOR<InvestorCreateInput, InvestorUncheckedCreateInput>
    /**
     * In case the Investor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvestorUpdateInput, InvestorUncheckedUpdateInput>
  }

  /**
   * Investor delete
   */
  export type InvestorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investor
     */
    select?: InvestorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Investor
     */
    omit?: InvestorOmit<ExtArgs> | null
    /**
     * Filter which Investor to delete.
     */
    where: InvestorWhereUniqueInput
  }

  /**
   * Investor deleteMany
   */
  export type InvestorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Investors to delete
     */
    where?: InvestorWhereInput
    /**
     * Limit how many Investors to delete.
     */
    limit?: number
  }

  /**
   * Investor findRaw
   */
  export type InvestorFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Investor aggregateRaw
   */
  export type InvestorAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Investor without action
   */
  export type InvestorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investor
     */
    select?: InvestorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Investor
     */
    omit?: InvestorOmit<ExtArgs> | null
  }


  /**
   * Model subject
   */

  export type AggregateSubject = {
    _count: SubjectCountAggregateOutputType | null
    _min: SubjectMinAggregateOutputType | null
    _max: SubjectMaxAggregateOutputType | null
  }

  export type SubjectMinAggregateOutputType = {
    id: string | null
    isIdentified: boolean | null
    externalId: string | null
    identityProvider: string | null
    lastIpAddress: string | null
    subjectTimezone: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubjectMaxAggregateOutputType = {
    id: string | null
    isIdentified: boolean | null
    externalId: string | null
    identityProvider: string | null
    lastIpAddress: string | null
    subjectTimezone: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubjectCountAggregateOutputType = {
    id: number
    isIdentified: number
    externalId: number
    identityProvider: number
    lastIpAddress: number
    subjectTimezone: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SubjectMinAggregateInputType = {
    id?: true
    isIdentified?: true
    externalId?: true
    identityProvider?: true
    lastIpAddress?: true
    subjectTimezone?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubjectMaxAggregateInputType = {
    id?: true
    isIdentified?: true
    externalId?: true
    identityProvider?: true
    lastIpAddress?: true
    subjectTimezone?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubjectCountAggregateInputType = {
    id?: true
    isIdentified?: true
    externalId?: true
    identityProvider?: true
    lastIpAddress?: true
    subjectTimezone?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SubjectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which subject to aggregate.
     */
    where?: subjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subjects to fetch.
     */
    orderBy?: subjectOrderByWithRelationInput | subjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: subjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned subjects
    **/
    _count?: true | SubjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubjectMaxAggregateInputType
  }

  export type GetSubjectAggregateType<T extends SubjectAggregateArgs> = {
        [P in keyof T & keyof AggregateSubject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubject[P]>
      : GetScalarType<T[P], AggregateSubject[P]>
  }




  export type subjectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: subjectWhereInput
    orderBy?: subjectOrderByWithAggregationInput | subjectOrderByWithAggregationInput[]
    by: SubjectScalarFieldEnum[] | SubjectScalarFieldEnum
    having?: subjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubjectCountAggregateInputType | true
    _min?: SubjectMinAggregateInputType
    _max?: SubjectMaxAggregateInputType
  }

  export type SubjectGroupByOutputType = {
    id: string
    isIdentified: boolean
    externalId: string | null
    identityProvider: string | null
    lastIpAddress: string | null
    subjectTimezone: string | null
    createdAt: Date
    updatedAt: Date
    _count: SubjectCountAggregateOutputType | null
    _min: SubjectMinAggregateOutputType | null
    _max: SubjectMaxAggregateOutputType | null
  }

  type GetSubjectGroupByPayload<T extends subjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubjectGroupByOutputType[P]>
            : GetScalarType<T[P], SubjectGroupByOutputType[P]>
        }
      >
    >


  export type subjectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    isIdentified?: boolean
    externalId?: boolean
    identityProvider?: boolean
    lastIpAddress?: boolean
    subjectTimezone?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    consents?: boolean | subject$consentsArgs<ExtArgs>
    consentRecords?: boolean | subject$consentRecordsArgs<ExtArgs>
    auditLogs?: boolean | subject$auditLogsArgs<ExtArgs>
    _count?: boolean | SubjectCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subject"]>



  export type subjectSelectScalar = {
    id?: boolean
    isIdentified?: boolean
    externalId?: boolean
    identityProvider?: boolean
    lastIpAddress?: boolean
    subjectTimezone?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type subjectOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "isIdentified" | "externalId" | "identityProvider" | "lastIpAddress" | "subjectTimezone" | "createdAt" | "updatedAt", ExtArgs["result"]["subject"]>
  export type subjectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    consents?: boolean | subject$consentsArgs<ExtArgs>
    consentRecords?: boolean | subject$consentRecordsArgs<ExtArgs>
    auditLogs?: boolean | subject$auditLogsArgs<ExtArgs>
    _count?: boolean | SubjectCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $subjectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "subject"
    objects: {
      consents: Prisma.$consentPayload<ExtArgs>[]
      consentRecords: Prisma.$consentRecordPayload<ExtArgs>[]
      auditLogs: Prisma.$auditLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      isIdentified: boolean
      externalId: string | null
      identityProvider: string | null
      lastIpAddress: string | null
      subjectTimezone: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["subject"]>
    composites: {}
  }

  type subjectGetPayload<S extends boolean | null | undefined | subjectDefaultArgs> = $Result.GetResult<Prisma.$subjectPayload, S>

  type subjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<subjectFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubjectCountAggregateInputType | true
    }

  export interface subjectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['subject'], meta: { name: 'subject' } }
    /**
     * Find zero or one Subject that matches the filter.
     * @param {subjectFindUniqueArgs} args - Arguments to find a Subject
     * @example
     * // Get one Subject
     * const subject = await prisma.subject.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends subjectFindUniqueArgs>(args: SelectSubset<T, subjectFindUniqueArgs<ExtArgs>>): Prisma__subjectClient<$Result.GetResult<Prisma.$subjectPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Subject that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {subjectFindUniqueOrThrowArgs} args - Arguments to find a Subject
     * @example
     * // Get one Subject
     * const subject = await prisma.subject.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends subjectFindUniqueOrThrowArgs>(args: SelectSubset<T, subjectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__subjectClient<$Result.GetResult<Prisma.$subjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subject that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subjectFindFirstArgs} args - Arguments to find a Subject
     * @example
     * // Get one Subject
     * const subject = await prisma.subject.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends subjectFindFirstArgs>(args?: SelectSubset<T, subjectFindFirstArgs<ExtArgs>>): Prisma__subjectClient<$Result.GetResult<Prisma.$subjectPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subject that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subjectFindFirstOrThrowArgs} args - Arguments to find a Subject
     * @example
     * // Get one Subject
     * const subject = await prisma.subject.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends subjectFindFirstOrThrowArgs>(args?: SelectSubset<T, subjectFindFirstOrThrowArgs<ExtArgs>>): Prisma__subjectClient<$Result.GetResult<Prisma.$subjectPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Subjects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subjectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subjects
     * const subjects = await prisma.subject.findMany()
     * 
     * // Get first 10 Subjects
     * const subjects = await prisma.subject.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subjectWithIdOnly = await prisma.subject.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends subjectFindManyArgs>(args?: SelectSubset<T, subjectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$subjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Subject.
     * @param {subjectCreateArgs} args - Arguments to create a Subject.
     * @example
     * // Create one Subject
     * const Subject = await prisma.subject.create({
     *   data: {
     *     // ... data to create a Subject
     *   }
     * })
     * 
     */
    create<T extends subjectCreateArgs>(args: SelectSubset<T, subjectCreateArgs<ExtArgs>>): Prisma__subjectClient<$Result.GetResult<Prisma.$subjectPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Subjects.
     * @param {subjectCreateManyArgs} args - Arguments to create many Subjects.
     * @example
     * // Create many Subjects
     * const subject = await prisma.subject.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends subjectCreateManyArgs>(args?: SelectSubset<T, subjectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Subject.
     * @param {subjectDeleteArgs} args - Arguments to delete one Subject.
     * @example
     * // Delete one Subject
     * const Subject = await prisma.subject.delete({
     *   where: {
     *     // ... filter to delete one Subject
     *   }
     * })
     * 
     */
    delete<T extends subjectDeleteArgs>(args: SelectSubset<T, subjectDeleteArgs<ExtArgs>>): Prisma__subjectClient<$Result.GetResult<Prisma.$subjectPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Subject.
     * @param {subjectUpdateArgs} args - Arguments to update one Subject.
     * @example
     * // Update one Subject
     * const subject = await prisma.subject.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends subjectUpdateArgs>(args: SelectSubset<T, subjectUpdateArgs<ExtArgs>>): Prisma__subjectClient<$Result.GetResult<Prisma.$subjectPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Subjects.
     * @param {subjectDeleteManyArgs} args - Arguments to filter Subjects to delete.
     * @example
     * // Delete a few Subjects
     * const { count } = await prisma.subject.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends subjectDeleteManyArgs>(args?: SelectSubset<T, subjectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subjects
     * const subject = await prisma.subject.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends subjectUpdateManyArgs>(args: SelectSubset<T, subjectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Subject.
     * @param {subjectUpsertArgs} args - Arguments to update or create a Subject.
     * @example
     * // Update or create a Subject
     * const subject = await prisma.subject.upsert({
     *   create: {
     *     // ... data to create a Subject
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subject we want to update
     *   }
     * })
     */
    upsert<T extends subjectUpsertArgs>(args: SelectSubset<T, subjectUpsertArgs<ExtArgs>>): Prisma__subjectClient<$Result.GetResult<Prisma.$subjectPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Subjects that matches the filter.
     * @param {subjectFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const subject = await prisma.subject.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: subjectFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Subject.
     * @param {subjectAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const subject = await prisma.subject.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: subjectAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Subjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subjectCountArgs} args - Arguments to filter Subjects to count.
     * @example
     * // Count the number of Subjects
     * const count = await prisma.subject.count({
     *   where: {
     *     // ... the filter for the Subjects we want to count
     *   }
     * })
    **/
    count<T extends subjectCountArgs>(
      args?: Subset<T, subjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubjectAggregateArgs>(args: Subset<T, SubjectAggregateArgs>): Prisma.PrismaPromise<GetSubjectAggregateType<T>>

    /**
     * Group by Subject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends subjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: subjectGroupByArgs['orderBy'] }
        : { orderBy?: subjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, subjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the subject model
   */
  readonly fields: subjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for subject.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__subjectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    consents<T extends subject$consentsArgs<ExtArgs> = {}>(args?: Subset<T, subject$consentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$consentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    consentRecords<T extends subject$consentRecordsArgs<ExtArgs> = {}>(args?: Subset<T, subject$consentRecordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$consentRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    auditLogs<T extends subject$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, subject$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$auditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the subject model
   */
  interface subjectFieldRefs {
    readonly id: FieldRef<"subject", 'String'>
    readonly isIdentified: FieldRef<"subject", 'Boolean'>
    readonly externalId: FieldRef<"subject", 'String'>
    readonly identityProvider: FieldRef<"subject", 'String'>
    readonly lastIpAddress: FieldRef<"subject", 'String'>
    readonly subjectTimezone: FieldRef<"subject", 'String'>
    readonly createdAt: FieldRef<"subject", 'DateTime'>
    readonly updatedAt: FieldRef<"subject", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * subject findUnique
   */
  export type subjectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subject
     */
    select?: subjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subject
     */
    omit?: subjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subjectInclude<ExtArgs> | null
    /**
     * Filter, which subject to fetch.
     */
    where: subjectWhereUniqueInput
  }

  /**
   * subject findUniqueOrThrow
   */
  export type subjectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subject
     */
    select?: subjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subject
     */
    omit?: subjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subjectInclude<ExtArgs> | null
    /**
     * Filter, which subject to fetch.
     */
    where: subjectWhereUniqueInput
  }

  /**
   * subject findFirst
   */
  export type subjectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subject
     */
    select?: subjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subject
     */
    omit?: subjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subjectInclude<ExtArgs> | null
    /**
     * Filter, which subject to fetch.
     */
    where?: subjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subjects to fetch.
     */
    orderBy?: subjectOrderByWithRelationInput | subjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for subjects.
     */
    cursor?: subjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of subjects.
     */
    distinct?: SubjectScalarFieldEnum | SubjectScalarFieldEnum[]
  }

  /**
   * subject findFirstOrThrow
   */
  export type subjectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subject
     */
    select?: subjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subject
     */
    omit?: subjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subjectInclude<ExtArgs> | null
    /**
     * Filter, which subject to fetch.
     */
    where?: subjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subjects to fetch.
     */
    orderBy?: subjectOrderByWithRelationInput | subjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for subjects.
     */
    cursor?: subjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of subjects.
     */
    distinct?: SubjectScalarFieldEnum | SubjectScalarFieldEnum[]
  }

  /**
   * subject findMany
   */
  export type subjectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subject
     */
    select?: subjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subject
     */
    omit?: subjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subjectInclude<ExtArgs> | null
    /**
     * Filter, which subjects to fetch.
     */
    where?: subjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subjects to fetch.
     */
    orderBy?: subjectOrderByWithRelationInput | subjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing subjects.
     */
    cursor?: subjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subjects.
     */
    skip?: number
    distinct?: SubjectScalarFieldEnum | SubjectScalarFieldEnum[]
  }

  /**
   * subject create
   */
  export type subjectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subject
     */
    select?: subjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subject
     */
    omit?: subjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subjectInclude<ExtArgs> | null
    /**
     * The data needed to create a subject.
     */
    data: XOR<subjectCreateInput, subjectUncheckedCreateInput>
  }

  /**
   * subject createMany
   */
  export type subjectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many subjects.
     */
    data: subjectCreateManyInput | subjectCreateManyInput[]
  }

  /**
   * subject update
   */
  export type subjectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subject
     */
    select?: subjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subject
     */
    omit?: subjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subjectInclude<ExtArgs> | null
    /**
     * The data needed to update a subject.
     */
    data: XOR<subjectUpdateInput, subjectUncheckedUpdateInput>
    /**
     * Choose, which subject to update.
     */
    where: subjectWhereUniqueInput
  }

  /**
   * subject updateMany
   */
  export type subjectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update subjects.
     */
    data: XOR<subjectUpdateManyMutationInput, subjectUncheckedUpdateManyInput>
    /**
     * Filter which subjects to update
     */
    where?: subjectWhereInput
    /**
     * Limit how many subjects to update.
     */
    limit?: number
  }

  /**
   * subject upsert
   */
  export type subjectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subject
     */
    select?: subjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subject
     */
    omit?: subjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subjectInclude<ExtArgs> | null
    /**
     * The filter to search for the subject to update in case it exists.
     */
    where: subjectWhereUniqueInput
    /**
     * In case the subject found by the `where` argument doesn't exist, create a new subject with this data.
     */
    create: XOR<subjectCreateInput, subjectUncheckedCreateInput>
    /**
     * In case the subject was found with the provided `where` argument, update it with this data.
     */
    update: XOR<subjectUpdateInput, subjectUncheckedUpdateInput>
  }

  /**
   * subject delete
   */
  export type subjectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subject
     */
    select?: subjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subject
     */
    omit?: subjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subjectInclude<ExtArgs> | null
    /**
     * Filter which subject to delete.
     */
    where: subjectWhereUniqueInput
  }

  /**
   * subject deleteMany
   */
  export type subjectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which subjects to delete
     */
    where?: subjectWhereInput
    /**
     * Limit how many subjects to delete.
     */
    limit?: number
  }

  /**
   * subject findRaw
   */
  export type subjectFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * subject aggregateRaw
   */
  export type subjectAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * subject.consents
   */
  export type subject$consentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consent
     */
    select?: consentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consent
     */
    omit?: consentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: consentInclude<ExtArgs> | null
    where?: consentWhereInput
    orderBy?: consentOrderByWithRelationInput | consentOrderByWithRelationInput[]
    cursor?: consentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConsentScalarFieldEnum | ConsentScalarFieldEnum[]
  }

  /**
   * subject.consentRecords
   */
  export type subject$consentRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consentRecord
     */
    select?: consentRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consentRecord
     */
    omit?: consentRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: consentRecordInclude<ExtArgs> | null
    where?: consentRecordWhereInput
    orderBy?: consentRecordOrderByWithRelationInput | consentRecordOrderByWithRelationInput[]
    cursor?: consentRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConsentRecordScalarFieldEnum | ConsentRecordScalarFieldEnum[]
  }

  /**
   * subject.auditLogs
   */
  export type subject$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auditLog
     */
    select?: auditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auditLog
     */
    omit?: auditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditLogInclude<ExtArgs> | null
    where?: auditLogWhereInput
    orderBy?: auditLogOrderByWithRelationInput | auditLogOrderByWithRelationInput[]
    cursor?: auditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * subject without action
   */
  export type subjectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subject
     */
    select?: subjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subject
     */
    omit?: subjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subjectInclude<ExtArgs> | null
  }


  /**
   * Model domain
   */

  export type AggregateDomain = {
    _count: DomainCountAggregateOutputType | null
    _min: DomainMinAggregateOutputType | null
    _max: DomainMaxAggregateOutputType | null
  }

  export type DomainMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    isVerified: boolean | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DomainMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    isVerified: boolean | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DomainCountAggregateOutputType = {
    id: number
    name: number
    description: number
    allowedOrigins: number
    isVerified: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DomainMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isVerified?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DomainMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isVerified?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DomainCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    allowedOrigins?: true
    isVerified?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DomainAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which domain to aggregate.
     */
    where?: domainWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of domains to fetch.
     */
    orderBy?: domainOrderByWithRelationInput | domainOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: domainWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` domains from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` domains.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned domains
    **/
    _count?: true | DomainCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DomainMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DomainMaxAggregateInputType
  }

  export type GetDomainAggregateType<T extends DomainAggregateArgs> = {
        [P in keyof T & keyof AggregateDomain]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDomain[P]>
      : GetScalarType<T[P], AggregateDomain[P]>
  }




  export type domainGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: domainWhereInput
    orderBy?: domainOrderByWithAggregationInput | domainOrderByWithAggregationInput[]
    by: DomainScalarFieldEnum[] | DomainScalarFieldEnum
    having?: domainScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DomainCountAggregateInputType | true
    _min?: DomainMinAggregateInputType
    _max?: DomainMaxAggregateInputType
  }

  export type DomainGroupByOutputType = {
    id: string
    name: string
    description: string | null
    allowedOrigins: JsonValue | null
    isVerified: boolean
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: DomainCountAggregateOutputType | null
    _min: DomainMinAggregateOutputType | null
    _max: DomainMaxAggregateOutputType | null
  }

  type GetDomainGroupByPayload<T extends domainGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DomainGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DomainGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DomainGroupByOutputType[P]>
            : GetScalarType<T[P], DomainGroupByOutputType[P]>
        }
      >
    >


  export type domainSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    allowedOrigins?: boolean
    isVerified?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    consents?: boolean | domain$consentsArgs<ExtArgs>
    _count?: boolean | DomainCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["domain"]>



  export type domainSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    allowedOrigins?: boolean
    isVerified?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type domainOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "allowedOrigins" | "isVerified" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["domain"]>
  export type domainInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    consents?: boolean | domain$consentsArgs<ExtArgs>
    _count?: boolean | DomainCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $domainPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "domain"
    objects: {
      consents: Prisma.$consentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      allowedOrigins: Prisma.JsonValue | null
      isVerified: boolean
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["domain"]>
    composites: {}
  }

  type domainGetPayload<S extends boolean | null | undefined | domainDefaultArgs> = $Result.GetResult<Prisma.$domainPayload, S>

  type domainCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<domainFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DomainCountAggregateInputType | true
    }

  export interface domainDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['domain'], meta: { name: 'domain' } }
    /**
     * Find zero or one Domain that matches the filter.
     * @param {domainFindUniqueArgs} args - Arguments to find a Domain
     * @example
     * // Get one Domain
     * const domain = await prisma.domain.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends domainFindUniqueArgs>(args: SelectSubset<T, domainFindUniqueArgs<ExtArgs>>): Prisma__domainClient<$Result.GetResult<Prisma.$domainPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Domain that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {domainFindUniqueOrThrowArgs} args - Arguments to find a Domain
     * @example
     * // Get one Domain
     * const domain = await prisma.domain.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends domainFindUniqueOrThrowArgs>(args: SelectSubset<T, domainFindUniqueOrThrowArgs<ExtArgs>>): Prisma__domainClient<$Result.GetResult<Prisma.$domainPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Domain that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {domainFindFirstArgs} args - Arguments to find a Domain
     * @example
     * // Get one Domain
     * const domain = await prisma.domain.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends domainFindFirstArgs>(args?: SelectSubset<T, domainFindFirstArgs<ExtArgs>>): Prisma__domainClient<$Result.GetResult<Prisma.$domainPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Domain that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {domainFindFirstOrThrowArgs} args - Arguments to find a Domain
     * @example
     * // Get one Domain
     * const domain = await prisma.domain.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends domainFindFirstOrThrowArgs>(args?: SelectSubset<T, domainFindFirstOrThrowArgs<ExtArgs>>): Prisma__domainClient<$Result.GetResult<Prisma.$domainPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Domains that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {domainFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Domains
     * const domains = await prisma.domain.findMany()
     * 
     * // Get first 10 Domains
     * const domains = await prisma.domain.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const domainWithIdOnly = await prisma.domain.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends domainFindManyArgs>(args?: SelectSubset<T, domainFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$domainPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Domain.
     * @param {domainCreateArgs} args - Arguments to create a Domain.
     * @example
     * // Create one Domain
     * const Domain = await prisma.domain.create({
     *   data: {
     *     // ... data to create a Domain
     *   }
     * })
     * 
     */
    create<T extends domainCreateArgs>(args: SelectSubset<T, domainCreateArgs<ExtArgs>>): Prisma__domainClient<$Result.GetResult<Prisma.$domainPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Domains.
     * @param {domainCreateManyArgs} args - Arguments to create many Domains.
     * @example
     * // Create many Domains
     * const domain = await prisma.domain.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends domainCreateManyArgs>(args?: SelectSubset<T, domainCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Domain.
     * @param {domainDeleteArgs} args - Arguments to delete one Domain.
     * @example
     * // Delete one Domain
     * const Domain = await prisma.domain.delete({
     *   where: {
     *     // ... filter to delete one Domain
     *   }
     * })
     * 
     */
    delete<T extends domainDeleteArgs>(args: SelectSubset<T, domainDeleteArgs<ExtArgs>>): Prisma__domainClient<$Result.GetResult<Prisma.$domainPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Domain.
     * @param {domainUpdateArgs} args - Arguments to update one Domain.
     * @example
     * // Update one Domain
     * const domain = await prisma.domain.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends domainUpdateArgs>(args: SelectSubset<T, domainUpdateArgs<ExtArgs>>): Prisma__domainClient<$Result.GetResult<Prisma.$domainPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Domains.
     * @param {domainDeleteManyArgs} args - Arguments to filter Domains to delete.
     * @example
     * // Delete a few Domains
     * const { count } = await prisma.domain.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends domainDeleteManyArgs>(args?: SelectSubset<T, domainDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Domains.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {domainUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Domains
     * const domain = await prisma.domain.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends domainUpdateManyArgs>(args: SelectSubset<T, domainUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Domain.
     * @param {domainUpsertArgs} args - Arguments to update or create a Domain.
     * @example
     * // Update or create a Domain
     * const domain = await prisma.domain.upsert({
     *   create: {
     *     // ... data to create a Domain
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Domain we want to update
     *   }
     * })
     */
    upsert<T extends domainUpsertArgs>(args: SelectSubset<T, domainUpsertArgs<ExtArgs>>): Prisma__domainClient<$Result.GetResult<Prisma.$domainPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Domains that matches the filter.
     * @param {domainFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const domain = await prisma.domain.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: domainFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Domain.
     * @param {domainAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const domain = await prisma.domain.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: domainAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Domains.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {domainCountArgs} args - Arguments to filter Domains to count.
     * @example
     * // Count the number of Domains
     * const count = await prisma.domain.count({
     *   where: {
     *     // ... the filter for the Domains we want to count
     *   }
     * })
    **/
    count<T extends domainCountArgs>(
      args?: Subset<T, domainCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DomainCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Domain.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DomainAggregateArgs>(args: Subset<T, DomainAggregateArgs>): Prisma.PrismaPromise<GetDomainAggregateType<T>>

    /**
     * Group by Domain.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {domainGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends domainGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: domainGroupByArgs['orderBy'] }
        : { orderBy?: domainGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, domainGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDomainGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the domain model
   */
  readonly fields: domainFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for domain.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__domainClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    consents<T extends domain$consentsArgs<ExtArgs> = {}>(args?: Subset<T, domain$consentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$consentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the domain model
   */
  interface domainFieldRefs {
    readonly id: FieldRef<"domain", 'String'>
    readonly name: FieldRef<"domain", 'String'>
    readonly description: FieldRef<"domain", 'String'>
    readonly allowedOrigins: FieldRef<"domain", 'Json'>
    readonly isVerified: FieldRef<"domain", 'Boolean'>
    readonly isActive: FieldRef<"domain", 'Boolean'>
    readonly createdAt: FieldRef<"domain", 'DateTime'>
    readonly updatedAt: FieldRef<"domain", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * domain findUnique
   */
  export type domainFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the domain
     */
    select?: domainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the domain
     */
    omit?: domainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: domainInclude<ExtArgs> | null
    /**
     * Filter, which domain to fetch.
     */
    where: domainWhereUniqueInput
  }

  /**
   * domain findUniqueOrThrow
   */
  export type domainFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the domain
     */
    select?: domainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the domain
     */
    omit?: domainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: domainInclude<ExtArgs> | null
    /**
     * Filter, which domain to fetch.
     */
    where: domainWhereUniqueInput
  }

  /**
   * domain findFirst
   */
  export type domainFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the domain
     */
    select?: domainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the domain
     */
    omit?: domainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: domainInclude<ExtArgs> | null
    /**
     * Filter, which domain to fetch.
     */
    where?: domainWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of domains to fetch.
     */
    orderBy?: domainOrderByWithRelationInput | domainOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for domains.
     */
    cursor?: domainWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` domains from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` domains.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of domains.
     */
    distinct?: DomainScalarFieldEnum | DomainScalarFieldEnum[]
  }

  /**
   * domain findFirstOrThrow
   */
  export type domainFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the domain
     */
    select?: domainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the domain
     */
    omit?: domainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: domainInclude<ExtArgs> | null
    /**
     * Filter, which domain to fetch.
     */
    where?: domainWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of domains to fetch.
     */
    orderBy?: domainOrderByWithRelationInput | domainOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for domains.
     */
    cursor?: domainWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` domains from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` domains.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of domains.
     */
    distinct?: DomainScalarFieldEnum | DomainScalarFieldEnum[]
  }

  /**
   * domain findMany
   */
  export type domainFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the domain
     */
    select?: domainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the domain
     */
    omit?: domainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: domainInclude<ExtArgs> | null
    /**
     * Filter, which domains to fetch.
     */
    where?: domainWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of domains to fetch.
     */
    orderBy?: domainOrderByWithRelationInput | domainOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing domains.
     */
    cursor?: domainWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` domains from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` domains.
     */
    skip?: number
    distinct?: DomainScalarFieldEnum | DomainScalarFieldEnum[]
  }

  /**
   * domain create
   */
  export type domainCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the domain
     */
    select?: domainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the domain
     */
    omit?: domainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: domainInclude<ExtArgs> | null
    /**
     * The data needed to create a domain.
     */
    data: XOR<domainCreateInput, domainUncheckedCreateInput>
  }

  /**
   * domain createMany
   */
  export type domainCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many domains.
     */
    data: domainCreateManyInput | domainCreateManyInput[]
  }

  /**
   * domain update
   */
  export type domainUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the domain
     */
    select?: domainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the domain
     */
    omit?: domainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: domainInclude<ExtArgs> | null
    /**
     * The data needed to update a domain.
     */
    data: XOR<domainUpdateInput, domainUncheckedUpdateInput>
    /**
     * Choose, which domain to update.
     */
    where: domainWhereUniqueInput
  }

  /**
   * domain updateMany
   */
  export type domainUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update domains.
     */
    data: XOR<domainUpdateManyMutationInput, domainUncheckedUpdateManyInput>
    /**
     * Filter which domains to update
     */
    where?: domainWhereInput
    /**
     * Limit how many domains to update.
     */
    limit?: number
  }

  /**
   * domain upsert
   */
  export type domainUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the domain
     */
    select?: domainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the domain
     */
    omit?: domainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: domainInclude<ExtArgs> | null
    /**
     * The filter to search for the domain to update in case it exists.
     */
    where: domainWhereUniqueInput
    /**
     * In case the domain found by the `where` argument doesn't exist, create a new domain with this data.
     */
    create: XOR<domainCreateInput, domainUncheckedCreateInput>
    /**
     * In case the domain was found with the provided `where` argument, update it with this data.
     */
    update: XOR<domainUpdateInput, domainUncheckedUpdateInput>
  }

  /**
   * domain delete
   */
  export type domainDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the domain
     */
    select?: domainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the domain
     */
    omit?: domainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: domainInclude<ExtArgs> | null
    /**
     * Filter which domain to delete.
     */
    where: domainWhereUniqueInput
  }

  /**
   * domain deleteMany
   */
  export type domainDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which domains to delete
     */
    where?: domainWhereInput
    /**
     * Limit how many domains to delete.
     */
    limit?: number
  }

  /**
   * domain findRaw
   */
  export type domainFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * domain aggregateRaw
   */
  export type domainAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * domain.consents
   */
  export type domain$consentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consent
     */
    select?: consentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consent
     */
    omit?: consentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: consentInclude<ExtArgs> | null
    where?: consentWhereInput
    orderBy?: consentOrderByWithRelationInput | consentOrderByWithRelationInput[]
    cursor?: consentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConsentScalarFieldEnum | ConsentScalarFieldEnum[]
  }

  /**
   * domain without action
   */
  export type domainDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the domain
     */
    select?: domainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the domain
     */
    omit?: domainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: domainInclude<ExtArgs> | null
  }


  /**
   * Model consentPolicy
   */

  export type AggregateConsentPolicy = {
    _count: ConsentPolicyCountAggregateOutputType | null
    _min: ConsentPolicyMinAggregateOutputType | null
    _max: ConsentPolicyMaxAggregateOutputType | null
  }

  export type ConsentPolicyMinAggregateOutputType = {
    id: string | null
    version: string | null
    type: string | null
    name: string | null
    effectiveDate: Date | null
    expirationDate: Date | null
    content: string | null
    contentHash: string | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type ConsentPolicyMaxAggregateOutputType = {
    id: string | null
    version: string | null
    type: string | null
    name: string | null
    effectiveDate: Date | null
    expirationDate: Date | null
    content: string | null
    contentHash: string | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type ConsentPolicyCountAggregateOutputType = {
    id: number
    version: number
    type: number
    name: number
    effectiveDate: number
    expirationDate: number
    content: number
    contentHash: number
    isActive: number
    createdAt: number
    _all: number
  }


  export type ConsentPolicyMinAggregateInputType = {
    id?: true
    version?: true
    type?: true
    name?: true
    effectiveDate?: true
    expirationDate?: true
    content?: true
    contentHash?: true
    isActive?: true
    createdAt?: true
  }

  export type ConsentPolicyMaxAggregateInputType = {
    id?: true
    version?: true
    type?: true
    name?: true
    effectiveDate?: true
    expirationDate?: true
    content?: true
    contentHash?: true
    isActive?: true
    createdAt?: true
  }

  export type ConsentPolicyCountAggregateInputType = {
    id?: true
    version?: true
    type?: true
    name?: true
    effectiveDate?: true
    expirationDate?: true
    content?: true
    contentHash?: true
    isActive?: true
    createdAt?: true
    _all?: true
  }

  export type ConsentPolicyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which consentPolicy to aggregate.
     */
    where?: consentPolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of consentPolicies to fetch.
     */
    orderBy?: consentPolicyOrderByWithRelationInput | consentPolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: consentPolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` consentPolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` consentPolicies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned consentPolicies
    **/
    _count?: true | ConsentPolicyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConsentPolicyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConsentPolicyMaxAggregateInputType
  }

  export type GetConsentPolicyAggregateType<T extends ConsentPolicyAggregateArgs> = {
        [P in keyof T & keyof AggregateConsentPolicy]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConsentPolicy[P]>
      : GetScalarType<T[P], AggregateConsentPolicy[P]>
  }




  export type consentPolicyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: consentPolicyWhereInput
    orderBy?: consentPolicyOrderByWithAggregationInput | consentPolicyOrderByWithAggregationInput[]
    by: ConsentPolicyScalarFieldEnum[] | ConsentPolicyScalarFieldEnum
    having?: consentPolicyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConsentPolicyCountAggregateInputType | true
    _min?: ConsentPolicyMinAggregateInputType
    _max?: ConsentPolicyMaxAggregateInputType
  }

  export type ConsentPolicyGroupByOutputType = {
    id: string
    version: string
    type: string
    name: string
    effectiveDate: Date
    expirationDate: Date | null
    content: string
    contentHash: string
    isActive: boolean
    createdAt: Date
    _count: ConsentPolicyCountAggregateOutputType | null
    _min: ConsentPolicyMinAggregateOutputType | null
    _max: ConsentPolicyMaxAggregateOutputType | null
  }

  type GetConsentPolicyGroupByPayload<T extends consentPolicyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConsentPolicyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConsentPolicyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConsentPolicyGroupByOutputType[P]>
            : GetScalarType<T[P], ConsentPolicyGroupByOutputType[P]>
        }
      >
    >


  export type consentPolicySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    version?: boolean
    type?: boolean
    name?: boolean
    effectiveDate?: boolean
    expirationDate?: boolean
    content?: boolean
    contentHash?: boolean
    isActive?: boolean
    createdAt?: boolean
    consents?: boolean | consentPolicy$consentsArgs<ExtArgs>
    _count?: boolean | ConsentPolicyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["consentPolicy"]>



  export type consentPolicySelectScalar = {
    id?: boolean
    version?: boolean
    type?: boolean
    name?: boolean
    effectiveDate?: boolean
    expirationDate?: boolean
    content?: boolean
    contentHash?: boolean
    isActive?: boolean
    createdAt?: boolean
  }

  export type consentPolicyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "version" | "type" | "name" | "effectiveDate" | "expirationDate" | "content" | "contentHash" | "isActive" | "createdAt", ExtArgs["result"]["consentPolicy"]>
  export type consentPolicyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    consents?: boolean | consentPolicy$consentsArgs<ExtArgs>
    _count?: boolean | ConsentPolicyCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $consentPolicyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "consentPolicy"
    objects: {
      consents: Prisma.$consentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      version: string
      type: string
      name: string
      effectiveDate: Date
      expirationDate: Date | null
      content: string
      contentHash: string
      isActive: boolean
      createdAt: Date
    }, ExtArgs["result"]["consentPolicy"]>
    composites: {}
  }

  type consentPolicyGetPayload<S extends boolean | null | undefined | consentPolicyDefaultArgs> = $Result.GetResult<Prisma.$consentPolicyPayload, S>

  type consentPolicyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<consentPolicyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConsentPolicyCountAggregateInputType | true
    }

  export interface consentPolicyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['consentPolicy'], meta: { name: 'consentPolicy' } }
    /**
     * Find zero or one ConsentPolicy that matches the filter.
     * @param {consentPolicyFindUniqueArgs} args - Arguments to find a ConsentPolicy
     * @example
     * // Get one ConsentPolicy
     * const consentPolicy = await prisma.consentPolicy.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends consentPolicyFindUniqueArgs>(args: SelectSubset<T, consentPolicyFindUniqueArgs<ExtArgs>>): Prisma__consentPolicyClient<$Result.GetResult<Prisma.$consentPolicyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ConsentPolicy that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {consentPolicyFindUniqueOrThrowArgs} args - Arguments to find a ConsentPolicy
     * @example
     * // Get one ConsentPolicy
     * const consentPolicy = await prisma.consentPolicy.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends consentPolicyFindUniqueOrThrowArgs>(args: SelectSubset<T, consentPolicyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__consentPolicyClient<$Result.GetResult<Prisma.$consentPolicyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConsentPolicy that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {consentPolicyFindFirstArgs} args - Arguments to find a ConsentPolicy
     * @example
     * // Get one ConsentPolicy
     * const consentPolicy = await prisma.consentPolicy.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends consentPolicyFindFirstArgs>(args?: SelectSubset<T, consentPolicyFindFirstArgs<ExtArgs>>): Prisma__consentPolicyClient<$Result.GetResult<Prisma.$consentPolicyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConsentPolicy that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {consentPolicyFindFirstOrThrowArgs} args - Arguments to find a ConsentPolicy
     * @example
     * // Get one ConsentPolicy
     * const consentPolicy = await prisma.consentPolicy.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends consentPolicyFindFirstOrThrowArgs>(args?: SelectSubset<T, consentPolicyFindFirstOrThrowArgs<ExtArgs>>): Prisma__consentPolicyClient<$Result.GetResult<Prisma.$consentPolicyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ConsentPolicies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {consentPolicyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ConsentPolicies
     * const consentPolicies = await prisma.consentPolicy.findMany()
     * 
     * // Get first 10 ConsentPolicies
     * const consentPolicies = await prisma.consentPolicy.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const consentPolicyWithIdOnly = await prisma.consentPolicy.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends consentPolicyFindManyArgs>(args?: SelectSubset<T, consentPolicyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$consentPolicyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ConsentPolicy.
     * @param {consentPolicyCreateArgs} args - Arguments to create a ConsentPolicy.
     * @example
     * // Create one ConsentPolicy
     * const ConsentPolicy = await prisma.consentPolicy.create({
     *   data: {
     *     // ... data to create a ConsentPolicy
     *   }
     * })
     * 
     */
    create<T extends consentPolicyCreateArgs>(args: SelectSubset<T, consentPolicyCreateArgs<ExtArgs>>): Prisma__consentPolicyClient<$Result.GetResult<Prisma.$consentPolicyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ConsentPolicies.
     * @param {consentPolicyCreateManyArgs} args - Arguments to create many ConsentPolicies.
     * @example
     * // Create many ConsentPolicies
     * const consentPolicy = await prisma.consentPolicy.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends consentPolicyCreateManyArgs>(args?: SelectSubset<T, consentPolicyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ConsentPolicy.
     * @param {consentPolicyDeleteArgs} args - Arguments to delete one ConsentPolicy.
     * @example
     * // Delete one ConsentPolicy
     * const ConsentPolicy = await prisma.consentPolicy.delete({
     *   where: {
     *     // ... filter to delete one ConsentPolicy
     *   }
     * })
     * 
     */
    delete<T extends consentPolicyDeleteArgs>(args: SelectSubset<T, consentPolicyDeleteArgs<ExtArgs>>): Prisma__consentPolicyClient<$Result.GetResult<Prisma.$consentPolicyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ConsentPolicy.
     * @param {consentPolicyUpdateArgs} args - Arguments to update one ConsentPolicy.
     * @example
     * // Update one ConsentPolicy
     * const consentPolicy = await prisma.consentPolicy.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends consentPolicyUpdateArgs>(args: SelectSubset<T, consentPolicyUpdateArgs<ExtArgs>>): Prisma__consentPolicyClient<$Result.GetResult<Prisma.$consentPolicyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ConsentPolicies.
     * @param {consentPolicyDeleteManyArgs} args - Arguments to filter ConsentPolicies to delete.
     * @example
     * // Delete a few ConsentPolicies
     * const { count } = await prisma.consentPolicy.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends consentPolicyDeleteManyArgs>(args?: SelectSubset<T, consentPolicyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConsentPolicies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {consentPolicyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ConsentPolicies
     * const consentPolicy = await prisma.consentPolicy.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends consentPolicyUpdateManyArgs>(args: SelectSubset<T, consentPolicyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ConsentPolicy.
     * @param {consentPolicyUpsertArgs} args - Arguments to update or create a ConsentPolicy.
     * @example
     * // Update or create a ConsentPolicy
     * const consentPolicy = await prisma.consentPolicy.upsert({
     *   create: {
     *     // ... data to create a ConsentPolicy
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ConsentPolicy we want to update
     *   }
     * })
     */
    upsert<T extends consentPolicyUpsertArgs>(args: SelectSubset<T, consentPolicyUpsertArgs<ExtArgs>>): Prisma__consentPolicyClient<$Result.GetResult<Prisma.$consentPolicyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ConsentPolicies that matches the filter.
     * @param {consentPolicyFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const consentPolicy = await prisma.consentPolicy.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: consentPolicyFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a ConsentPolicy.
     * @param {consentPolicyAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const consentPolicy = await prisma.consentPolicy.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: consentPolicyAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of ConsentPolicies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {consentPolicyCountArgs} args - Arguments to filter ConsentPolicies to count.
     * @example
     * // Count the number of ConsentPolicies
     * const count = await prisma.consentPolicy.count({
     *   where: {
     *     // ... the filter for the ConsentPolicies we want to count
     *   }
     * })
    **/
    count<T extends consentPolicyCountArgs>(
      args?: Subset<T, consentPolicyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConsentPolicyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ConsentPolicy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsentPolicyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConsentPolicyAggregateArgs>(args: Subset<T, ConsentPolicyAggregateArgs>): Prisma.PrismaPromise<GetConsentPolicyAggregateType<T>>

    /**
     * Group by ConsentPolicy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {consentPolicyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends consentPolicyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: consentPolicyGroupByArgs['orderBy'] }
        : { orderBy?: consentPolicyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, consentPolicyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConsentPolicyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the consentPolicy model
   */
  readonly fields: consentPolicyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for consentPolicy.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__consentPolicyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    consents<T extends consentPolicy$consentsArgs<ExtArgs> = {}>(args?: Subset<T, consentPolicy$consentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$consentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the consentPolicy model
   */
  interface consentPolicyFieldRefs {
    readonly id: FieldRef<"consentPolicy", 'String'>
    readonly version: FieldRef<"consentPolicy", 'String'>
    readonly type: FieldRef<"consentPolicy", 'String'>
    readonly name: FieldRef<"consentPolicy", 'String'>
    readonly effectiveDate: FieldRef<"consentPolicy", 'DateTime'>
    readonly expirationDate: FieldRef<"consentPolicy", 'DateTime'>
    readonly content: FieldRef<"consentPolicy", 'String'>
    readonly contentHash: FieldRef<"consentPolicy", 'String'>
    readonly isActive: FieldRef<"consentPolicy", 'Boolean'>
    readonly createdAt: FieldRef<"consentPolicy", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * consentPolicy findUnique
   */
  export type consentPolicyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consentPolicy
     */
    select?: consentPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the consentPolicy
     */
    omit?: consentPolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: consentPolicyInclude<ExtArgs> | null
    /**
     * Filter, which consentPolicy to fetch.
     */
    where: consentPolicyWhereUniqueInput
  }

  /**
   * consentPolicy findUniqueOrThrow
   */
  export type consentPolicyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consentPolicy
     */
    select?: consentPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the consentPolicy
     */
    omit?: consentPolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: consentPolicyInclude<ExtArgs> | null
    /**
     * Filter, which consentPolicy to fetch.
     */
    where: consentPolicyWhereUniqueInput
  }

  /**
   * consentPolicy findFirst
   */
  export type consentPolicyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consentPolicy
     */
    select?: consentPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the consentPolicy
     */
    omit?: consentPolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: consentPolicyInclude<ExtArgs> | null
    /**
     * Filter, which consentPolicy to fetch.
     */
    where?: consentPolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of consentPolicies to fetch.
     */
    orderBy?: consentPolicyOrderByWithRelationInput | consentPolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for consentPolicies.
     */
    cursor?: consentPolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` consentPolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` consentPolicies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of consentPolicies.
     */
    distinct?: ConsentPolicyScalarFieldEnum | ConsentPolicyScalarFieldEnum[]
  }

  /**
   * consentPolicy findFirstOrThrow
   */
  export type consentPolicyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consentPolicy
     */
    select?: consentPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the consentPolicy
     */
    omit?: consentPolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: consentPolicyInclude<ExtArgs> | null
    /**
     * Filter, which consentPolicy to fetch.
     */
    where?: consentPolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of consentPolicies to fetch.
     */
    orderBy?: consentPolicyOrderByWithRelationInput | consentPolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for consentPolicies.
     */
    cursor?: consentPolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` consentPolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` consentPolicies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of consentPolicies.
     */
    distinct?: ConsentPolicyScalarFieldEnum | ConsentPolicyScalarFieldEnum[]
  }

  /**
   * consentPolicy findMany
   */
  export type consentPolicyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consentPolicy
     */
    select?: consentPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the consentPolicy
     */
    omit?: consentPolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: consentPolicyInclude<ExtArgs> | null
    /**
     * Filter, which consentPolicies to fetch.
     */
    where?: consentPolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of consentPolicies to fetch.
     */
    orderBy?: consentPolicyOrderByWithRelationInput | consentPolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing consentPolicies.
     */
    cursor?: consentPolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` consentPolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` consentPolicies.
     */
    skip?: number
    distinct?: ConsentPolicyScalarFieldEnum | ConsentPolicyScalarFieldEnum[]
  }

  /**
   * consentPolicy create
   */
  export type consentPolicyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consentPolicy
     */
    select?: consentPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the consentPolicy
     */
    omit?: consentPolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: consentPolicyInclude<ExtArgs> | null
    /**
     * The data needed to create a consentPolicy.
     */
    data: XOR<consentPolicyCreateInput, consentPolicyUncheckedCreateInput>
  }

  /**
   * consentPolicy createMany
   */
  export type consentPolicyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many consentPolicies.
     */
    data: consentPolicyCreateManyInput | consentPolicyCreateManyInput[]
  }

  /**
   * consentPolicy update
   */
  export type consentPolicyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consentPolicy
     */
    select?: consentPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the consentPolicy
     */
    omit?: consentPolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: consentPolicyInclude<ExtArgs> | null
    /**
     * The data needed to update a consentPolicy.
     */
    data: XOR<consentPolicyUpdateInput, consentPolicyUncheckedUpdateInput>
    /**
     * Choose, which consentPolicy to update.
     */
    where: consentPolicyWhereUniqueInput
  }

  /**
   * consentPolicy updateMany
   */
  export type consentPolicyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update consentPolicies.
     */
    data: XOR<consentPolicyUpdateManyMutationInput, consentPolicyUncheckedUpdateManyInput>
    /**
     * Filter which consentPolicies to update
     */
    where?: consentPolicyWhereInput
    /**
     * Limit how many consentPolicies to update.
     */
    limit?: number
  }

  /**
   * consentPolicy upsert
   */
  export type consentPolicyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consentPolicy
     */
    select?: consentPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the consentPolicy
     */
    omit?: consentPolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: consentPolicyInclude<ExtArgs> | null
    /**
     * The filter to search for the consentPolicy to update in case it exists.
     */
    where: consentPolicyWhereUniqueInput
    /**
     * In case the consentPolicy found by the `where` argument doesn't exist, create a new consentPolicy with this data.
     */
    create: XOR<consentPolicyCreateInput, consentPolicyUncheckedCreateInput>
    /**
     * In case the consentPolicy was found with the provided `where` argument, update it with this data.
     */
    update: XOR<consentPolicyUpdateInput, consentPolicyUncheckedUpdateInput>
  }

  /**
   * consentPolicy delete
   */
  export type consentPolicyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consentPolicy
     */
    select?: consentPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the consentPolicy
     */
    omit?: consentPolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: consentPolicyInclude<ExtArgs> | null
    /**
     * Filter which consentPolicy to delete.
     */
    where: consentPolicyWhereUniqueInput
  }

  /**
   * consentPolicy deleteMany
   */
  export type consentPolicyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which consentPolicies to delete
     */
    where?: consentPolicyWhereInput
    /**
     * Limit how many consentPolicies to delete.
     */
    limit?: number
  }

  /**
   * consentPolicy findRaw
   */
  export type consentPolicyFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * consentPolicy aggregateRaw
   */
  export type consentPolicyAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * consentPolicy.consents
   */
  export type consentPolicy$consentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consent
     */
    select?: consentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consent
     */
    omit?: consentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: consentInclude<ExtArgs> | null
    where?: consentWhereInput
    orderBy?: consentOrderByWithRelationInput | consentOrderByWithRelationInput[]
    cursor?: consentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConsentScalarFieldEnum | ConsentScalarFieldEnum[]
  }

  /**
   * consentPolicy without action
   */
  export type consentPolicyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consentPolicy
     */
    select?: consentPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the consentPolicy
     */
    omit?: consentPolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: consentPolicyInclude<ExtArgs> | null
  }


  /**
   * Model consentPurpose
   */

  export type AggregateConsentPurpose = {
    _count: ConsentPurposeCountAggregateOutputType | null
    _min: ConsentPurposeMinAggregateOutputType | null
    _max: ConsentPurposeMaxAggregateOutputType | null
  }

  export type ConsentPurposeMinAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    description: string | null
    isEssential: boolean | null
    dataCategory: string | null
    legalBasis: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConsentPurposeMaxAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    description: string | null
    isEssential: boolean | null
    dataCategory: string | null
    legalBasis: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConsentPurposeCountAggregateOutputType = {
    id: number
    code: number
    name: number
    description: number
    isEssential: number
    dataCategory: number
    legalBasis: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ConsentPurposeMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    isEssential?: true
    dataCategory?: true
    legalBasis?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConsentPurposeMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    isEssential?: true
    dataCategory?: true
    legalBasis?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConsentPurposeCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    isEssential?: true
    dataCategory?: true
    legalBasis?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ConsentPurposeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which consentPurpose to aggregate.
     */
    where?: consentPurposeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of consentPurposes to fetch.
     */
    orderBy?: consentPurposeOrderByWithRelationInput | consentPurposeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: consentPurposeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` consentPurposes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` consentPurposes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned consentPurposes
    **/
    _count?: true | ConsentPurposeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConsentPurposeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConsentPurposeMaxAggregateInputType
  }

  export type GetConsentPurposeAggregateType<T extends ConsentPurposeAggregateArgs> = {
        [P in keyof T & keyof AggregateConsentPurpose]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConsentPurpose[P]>
      : GetScalarType<T[P], AggregateConsentPurpose[P]>
  }




  export type consentPurposeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: consentPurposeWhereInput
    orderBy?: consentPurposeOrderByWithAggregationInput | consentPurposeOrderByWithAggregationInput[]
    by: ConsentPurposeScalarFieldEnum[] | ConsentPurposeScalarFieldEnum
    having?: consentPurposeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConsentPurposeCountAggregateInputType | true
    _min?: ConsentPurposeMinAggregateInputType
    _max?: ConsentPurposeMaxAggregateInputType
  }

  export type ConsentPurposeGroupByOutputType = {
    id: string
    code: string
    name: string
    description: string
    isEssential: boolean
    dataCategory: string | null
    legalBasis: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: ConsentPurposeCountAggregateOutputType | null
    _min: ConsentPurposeMinAggregateOutputType | null
    _max: ConsentPurposeMaxAggregateOutputType | null
  }

  type GetConsentPurposeGroupByPayload<T extends consentPurposeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConsentPurposeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConsentPurposeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConsentPurposeGroupByOutputType[P]>
            : GetScalarType<T[P], ConsentPurposeGroupByOutputType[P]>
        }
      >
    >


  export type consentPurposeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    isEssential?: boolean
    dataCategory?: boolean
    legalBasis?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["consentPurpose"]>



  export type consentPurposeSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    isEssential?: boolean
    dataCategory?: boolean
    legalBasis?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type consentPurposeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "name" | "description" | "isEssential" | "dataCategory" | "legalBasis" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["consentPurpose"]>

  export type $consentPurposePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "consentPurpose"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      name: string
      description: string
      isEssential: boolean
      dataCategory: string | null
      legalBasis: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["consentPurpose"]>
    composites: {}
  }

  type consentPurposeGetPayload<S extends boolean | null | undefined | consentPurposeDefaultArgs> = $Result.GetResult<Prisma.$consentPurposePayload, S>

  type consentPurposeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<consentPurposeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConsentPurposeCountAggregateInputType | true
    }

  export interface consentPurposeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['consentPurpose'], meta: { name: 'consentPurpose' } }
    /**
     * Find zero or one ConsentPurpose that matches the filter.
     * @param {consentPurposeFindUniqueArgs} args - Arguments to find a ConsentPurpose
     * @example
     * // Get one ConsentPurpose
     * const consentPurpose = await prisma.consentPurpose.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends consentPurposeFindUniqueArgs>(args: SelectSubset<T, consentPurposeFindUniqueArgs<ExtArgs>>): Prisma__consentPurposeClient<$Result.GetResult<Prisma.$consentPurposePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ConsentPurpose that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {consentPurposeFindUniqueOrThrowArgs} args - Arguments to find a ConsentPurpose
     * @example
     * // Get one ConsentPurpose
     * const consentPurpose = await prisma.consentPurpose.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends consentPurposeFindUniqueOrThrowArgs>(args: SelectSubset<T, consentPurposeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__consentPurposeClient<$Result.GetResult<Prisma.$consentPurposePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConsentPurpose that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {consentPurposeFindFirstArgs} args - Arguments to find a ConsentPurpose
     * @example
     * // Get one ConsentPurpose
     * const consentPurpose = await prisma.consentPurpose.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends consentPurposeFindFirstArgs>(args?: SelectSubset<T, consentPurposeFindFirstArgs<ExtArgs>>): Prisma__consentPurposeClient<$Result.GetResult<Prisma.$consentPurposePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConsentPurpose that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {consentPurposeFindFirstOrThrowArgs} args - Arguments to find a ConsentPurpose
     * @example
     * // Get one ConsentPurpose
     * const consentPurpose = await prisma.consentPurpose.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends consentPurposeFindFirstOrThrowArgs>(args?: SelectSubset<T, consentPurposeFindFirstOrThrowArgs<ExtArgs>>): Prisma__consentPurposeClient<$Result.GetResult<Prisma.$consentPurposePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ConsentPurposes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {consentPurposeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ConsentPurposes
     * const consentPurposes = await prisma.consentPurpose.findMany()
     * 
     * // Get first 10 ConsentPurposes
     * const consentPurposes = await prisma.consentPurpose.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const consentPurposeWithIdOnly = await prisma.consentPurpose.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends consentPurposeFindManyArgs>(args?: SelectSubset<T, consentPurposeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$consentPurposePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ConsentPurpose.
     * @param {consentPurposeCreateArgs} args - Arguments to create a ConsentPurpose.
     * @example
     * // Create one ConsentPurpose
     * const ConsentPurpose = await prisma.consentPurpose.create({
     *   data: {
     *     // ... data to create a ConsentPurpose
     *   }
     * })
     * 
     */
    create<T extends consentPurposeCreateArgs>(args: SelectSubset<T, consentPurposeCreateArgs<ExtArgs>>): Prisma__consentPurposeClient<$Result.GetResult<Prisma.$consentPurposePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ConsentPurposes.
     * @param {consentPurposeCreateManyArgs} args - Arguments to create many ConsentPurposes.
     * @example
     * // Create many ConsentPurposes
     * const consentPurpose = await prisma.consentPurpose.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends consentPurposeCreateManyArgs>(args?: SelectSubset<T, consentPurposeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ConsentPurpose.
     * @param {consentPurposeDeleteArgs} args - Arguments to delete one ConsentPurpose.
     * @example
     * // Delete one ConsentPurpose
     * const ConsentPurpose = await prisma.consentPurpose.delete({
     *   where: {
     *     // ... filter to delete one ConsentPurpose
     *   }
     * })
     * 
     */
    delete<T extends consentPurposeDeleteArgs>(args: SelectSubset<T, consentPurposeDeleteArgs<ExtArgs>>): Prisma__consentPurposeClient<$Result.GetResult<Prisma.$consentPurposePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ConsentPurpose.
     * @param {consentPurposeUpdateArgs} args - Arguments to update one ConsentPurpose.
     * @example
     * // Update one ConsentPurpose
     * const consentPurpose = await prisma.consentPurpose.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends consentPurposeUpdateArgs>(args: SelectSubset<T, consentPurposeUpdateArgs<ExtArgs>>): Prisma__consentPurposeClient<$Result.GetResult<Prisma.$consentPurposePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ConsentPurposes.
     * @param {consentPurposeDeleteManyArgs} args - Arguments to filter ConsentPurposes to delete.
     * @example
     * // Delete a few ConsentPurposes
     * const { count } = await prisma.consentPurpose.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends consentPurposeDeleteManyArgs>(args?: SelectSubset<T, consentPurposeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConsentPurposes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {consentPurposeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ConsentPurposes
     * const consentPurpose = await prisma.consentPurpose.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends consentPurposeUpdateManyArgs>(args: SelectSubset<T, consentPurposeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ConsentPurpose.
     * @param {consentPurposeUpsertArgs} args - Arguments to update or create a ConsentPurpose.
     * @example
     * // Update or create a ConsentPurpose
     * const consentPurpose = await prisma.consentPurpose.upsert({
     *   create: {
     *     // ... data to create a ConsentPurpose
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ConsentPurpose we want to update
     *   }
     * })
     */
    upsert<T extends consentPurposeUpsertArgs>(args: SelectSubset<T, consentPurposeUpsertArgs<ExtArgs>>): Prisma__consentPurposeClient<$Result.GetResult<Prisma.$consentPurposePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ConsentPurposes that matches the filter.
     * @param {consentPurposeFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const consentPurpose = await prisma.consentPurpose.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: consentPurposeFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a ConsentPurpose.
     * @param {consentPurposeAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const consentPurpose = await prisma.consentPurpose.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: consentPurposeAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of ConsentPurposes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {consentPurposeCountArgs} args - Arguments to filter ConsentPurposes to count.
     * @example
     * // Count the number of ConsentPurposes
     * const count = await prisma.consentPurpose.count({
     *   where: {
     *     // ... the filter for the ConsentPurposes we want to count
     *   }
     * })
    **/
    count<T extends consentPurposeCountArgs>(
      args?: Subset<T, consentPurposeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConsentPurposeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ConsentPurpose.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsentPurposeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConsentPurposeAggregateArgs>(args: Subset<T, ConsentPurposeAggregateArgs>): Prisma.PrismaPromise<GetConsentPurposeAggregateType<T>>

    /**
     * Group by ConsentPurpose.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {consentPurposeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends consentPurposeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: consentPurposeGroupByArgs['orderBy'] }
        : { orderBy?: consentPurposeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, consentPurposeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConsentPurposeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the consentPurpose model
   */
  readonly fields: consentPurposeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for consentPurpose.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__consentPurposeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the consentPurpose model
   */
  interface consentPurposeFieldRefs {
    readonly id: FieldRef<"consentPurpose", 'String'>
    readonly code: FieldRef<"consentPurpose", 'String'>
    readonly name: FieldRef<"consentPurpose", 'String'>
    readonly description: FieldRef<"consentPurpose", 'String'>
    readonly isEssential: FieldRef<"consentPurpose", 'Boolean'>
    readonly dataCategory: FieldRef<"consentPurpose", 'String'>
    readonly legalBasis: FieldRef<"consentPurpose", 'String'>
    readonly isActive: FieldRef<"consentPurpose", 'Boolean'>
    readonly createdAt: FieldRef<"consentPurpose", 'DateTime'>
    readonly updatedAt: FieldRef<"consentPurpose", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * consentPurpose findUnique
   */
  export type consentPurposeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consentPurpose
     */
    select?: consentPurposeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consentPurpose
     */
    omit?: consentPurposeOmit<ExtArgs> | null
    /**
     * Filter, which consentPurpose to fetch.
     */
    where: consentPurposeWhereUniqueInput
  }

  /**
   * consentPurpose findUniqueOrThrow
   */
  export type consentPurposeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consentPurpose
     */
    select?: consentPurposeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consentPurpose
     */
    omit?: consentPurposeOmit<ExtArgs> | null
    /**
     * Filter, which consentPurpose to fetch.
     */
    where: consentPurposeWhereUniqueInput
  }

  /**
   * consentPurpose findFirst
   */
  export type consentPurposeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consentPurpose
     */
    select?: consentPurposeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consentPurpose
     */
    omit?: consentPurposeOmit<ExtArgs> | null
    /**
     * Filter, which consentPurpose to fetch.
     */
    where?: consentPurposeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of consentPurposes to fetch.
     */
    orderBy?: consentPurposeOrderByWithRelationInput | consentPurposeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for consentPurposes.
     */
    cursor?: consentPurposeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` consentPurposes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` consentPurposes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of consentPurposes.
     */
    distinct?: ConsentPurposeScalarFieldEnum | ConsentPurposeScalarFieldEnum[]
  }

  /**
   * consentPurpose findFirstOrThrow
   */
  export type consentPurposeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consentPurpose
     */
    select?: consentPurposeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consentPurpose
     */
    omit?: consentPurposeOmit<ExtArgs> | null
    /**
     * Filter, which consentPurpose to fetch.
     */
    where?: consentPurposeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of consentPurposes to fetch.
     */
    orderBy?: consentPurposeOrderByWithRelationInput | consentPurposeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for consentPurposes.
     */
    cursor?: consentPurposeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` consentPurposes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` consentPurposes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of consentPurposes.
     */
    distinct?: ConsentPurposeScalarFieldEnum | ConsentPurposeScalarFieldEnum[]
  }

  /**
   * consentPurpose findMany
   */
  export type consentPurposeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consentPurpose
     */
    select?: consentPurposeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consentPurpose
     */
    omit?: consentPurposeOmit<ExtArgs> | null
    /**
     * Filter, which consentPurposes to fetch.
     */
    where?: consentPurposeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of consentPurposes to fetch.
     */
    orderBy?: consentPurposeOrderByWithRelationInput | consentPurposeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing consentPurposes.
     */
    cursor?: consentPurposeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` consentPurposes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` consentPurposes.
     */
    skip?: number
    distinct?: ConsentPurposeScalarFieldEnum | ConsentPurposeScalarFieldEnum[]
  }

  /**
   * consentPurpose create
   */
  export type consentPurposeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consentPurpose
     */
    select?: consentPurposeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consentPurpose
     */
    omit?: consentPurposeOmit<ExtArgs> | null
    /**
     * The data needed to create a consentPurpose.
     */
    data: XOR<consentPurposeCreateInput, consentPurposeUncheckedCreateInput>
  }

  /**
   * consentPurpose createMany
   */
  export type consentPurposeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many consentPurposes.
     */
    data: consentPurposeCreateManyInput | consentPurposeCreateManyInput[]
  }

  /**
   * consentPurpose update
   */
  export type consentPurposeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consentPurpose
     */
    select?: consentPurposeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consentPurpose
     */
    omit?: consentPurposeOmit<ExtArgs> | null
    /**
     * The data needed to update a consentPurpose.
     */
    data: XOR<consentPurposeUpdateInput, consentPurposeUncheckedUpdateInput>
    /**
     * Choose, which consentPurpose to update.
     */
    where: consentPurposeWhereUniqueInput
  }

  /**
   * consentPurpose updateMany
   */
  export type consentPurposeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update consentPurposes.
     */
    data: XOR<consentPurposeUpdateManyMutationInput, consentPurposeUncheckedUpdateManyInput>
    /**
     * Filter which consentPurposes to update
     */
    where?: consentPurposeWhereInput
    /**
     * Limit how many consentPurposes to update.
     */
    limit?: number
  }

  /**
   * consentPurpose upsert
   */
  export type consentPurposeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consentPurpose
     */
    select?: consentPurposeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consentPurpose
     */
    omit?: consentPurposeOmit<ExtArgs> | null
    /**
     * The filter to search for the consentPurpose to update in case it exists.
     */
    where: consentPurposeWhereUniqueInput
    /**
     * In case the consentPurpose found by the `where` argument doesn't exist, create a new consentPurpose with this data.
     */
    create: XOR<consentPurposeCreateInput, consentPurposeUncheckedCreateInput>
    /**
     * In case the consentPurpose was found with the provided `where` argument, update it with this data.
     */
    update: XOR<consentPurposeUpdateInput, consentPurposeUncheckedUpdateInput>
  }

  /**
   * consentPurpose delete
   */
  export type consentPurposeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consentPurpose
     */
    select?: consentPurposeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consentPurpose
     */
    omit?: consentPurposeOmit<ExtArgs> | null
    /**
     * Filter which consentPurpose to delete.
     */
    where: consentPurposeWhereUniqueInput
  }

  /**
   * consentPurpose deleteMany
   */
  export type consentPurposeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which consentPurposes to delete
     */
    where?: consentPurposeWhereInput
    /**
     * Limit how many consentPurposes to delete.
     */
    limit?: number
  }

  /**
   * consentPurpose findRaw
   */
  export type consentPurposeFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * consentPurpose aggregateRaw
   */
  export type consentPurposeAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * consentPurpose without action
   */
  export type consentPurposeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consentPurpose
     */
    select?: consentPurposeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consentPurpose
     */
    omit?: consentPurposeOmit<ExtArgs> | null
  }


  /**
   * Model consent
   */

  export type AggregateConsent = {
    _count: ConsentCountAggregateOutputType | null
    _min: ConsentMinAggregateOutputType | null
    _max: ConsentMaxAggregateOutputType | null
  }

  export type ConsentMinAggregateOutputType = {
    id: string | null
    subjectId: string | null
    domainId: string | null
    policyId: string | null
    ipAddress: string | null
    userAgent: string | null
    status: string | null
    withdrawalReason: string | null
    givenAt: Date | null
    validUntil: Date | null
    isActive: boolean | null
  }

  export type ConsentMaxAggregateOutputType = {
    id: string | null
    subjectId: string | null
    domainId: string | null
    policyId: string | null
    ipAddress: string | null
    userAgent: string | null
    status: string | null
    withdrawalReason: string | null
    givenAt: Date | null
    validUntil: Date | null
    isActive: boolean | null
  }

  export type ConsentCountAggregateOutputType = {
    id: number
    subjectId: number
    domainId: number
    policyId: number
    purposeIds: number
    metadata: number
    ipAddress: number
    userAgent: number
    status: number
    withdrawalReason: number
    givenAt: number
    validUntil: number
    isActive: number
    _all: number
  }


  export type ConsentMinAggregateInputType = {
    id?: true
    subjectId?: true
    domainId?: true
    policyId?: true
    ipAddress?: true
    userAgent?: true
    status?: true
    withdrawalReason?: true
    givenAt?: true
    validUntil?: true
    isActive?: true
  }

  export type ConsentMaxAggregateInputType = {
    id?: true
    subjectId?: true
    domainId?: true
    policyId?: true
    ipAddress?: true
    userAgent?: true
    status?: true
    withdrawalReason?: true
    givenAt?: true
    validUntil?: true
    isActive?: true
  }

  export type ConsentCountAggregateInputType = {
    id?: true
    subjectId?: true
    domainId?: true
    policyId?: true
    purposeIds?: true
    metadata?: true
    ipAddress?: true
    userAgent?: true
    status?: true
    withdrawalReason?: true
    givenAt?: true
    validUntil?: true
    isActive?: true
    _all?: true
  }

  export type ConsentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which consent to aggregate.
     */
    where?: consentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of consents to fetch.
     */
    orderBy?: consentOrderByWithRelationInput | consentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: consentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` consents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` consents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned consents
    **/
    _count?: true | ConsentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConsentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConsentMaxAggregateInputType
  }

  export type GetConsentAggregateType<T extends ConsentAggregateArgs> = {
        [P in keyof T & keyof AggregateConsent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConsent[P]>
      : GetScalarType<T[P], AggregateConsent[P]>
  }




  export type consentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: consentWhereInput
    orderBy?: consentOrderByWithAggregationInput | consentOrderByWithAggregationInput[]
    by: ConsentScalarFieldEnum[] | ConsentScalarFieldEnum
    having?: consentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConsentCountAggregateInputType | true
    _min?: ConsentMinAggregateInputType
    _max?: ConsentMaxAggregateInputType
  }

  export type ConsentGroupByOutputType = {
    id: string
    subjectId: string
    domainId: string
    policyId: string | null
    purposeIds: JsonValue
    metadata: JsonValue | null
    ipAddress: string | null
    userAgent: string | null
    status: string
    withdrawalReason: string | null
    givenAt: Date
    validUntil: Date | null
    isActive: boolean
    _count: ConsentCountAggregateOutputType | null
    _min: ConsentMinAggregateOutputType | null
    _max: ConsentMaxAggregateOutputType | null
  }

  type GetConsentGroupByPayload<T extends consentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConsentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConsentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConsentGroupByOutputType[P]>
            : GetScalarType<T[P], ConsentGroupByOutputType[P]>
        }
      >
    >


  export type consentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subjectId?: boolean
    domainId?: boolean
    policyId?: boolean
    purposeIds?: boolean
    metadata?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    status?: boolean
    withdrawalReason?: boolean
    givenAt?: boolean
    validUntil?: boolean
    isActive?: boolean
    subject?: boolean | subjectDefaultArgs<ExtArgs>
    domain?: boolean | domainDefaultArgs<ExtArgs>
    policy?: boolean | consent$policyArgs<ExtArgs>
    consentRecords?: boolean | consent$consentRecordsArgs<ExtArgs>
    _count?: boolean | ConsentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["consent"]>



  export type consentSelectScalar = {
    id?: boolean
    subjectId?: boolean
    domainId?: boolean
    policyId?: boolean
    purposeIds?: boolean
    metadata?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    status?: boolean
    withdrawalReason?: boolean
    givenAt?: boolean
    validUntil?: boolean
    isActive?: boolean
  }

  export type consentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "subjectId" | "domainId" | "policyId" | "purposeIds" | "metadata" | "ipAddress" | "userAgent" | "status" | "withdrawalReason" | "givenAt" | "validUntil" | "isActive", ExtArgs["result"]["consent"]>
  export type consentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subject?: boolean | subjectDefaultArgs<ExtArgs>
    domain?: boolean | domainDefaultArgs<ExtArgs>
    policy?: boolean | consent$policyArgs<ExtArgs>
    consentRecords?: boolean | consent$consentRecordsArgs<ExtArgs>
    _count?: boolean | ConsentCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $consentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "consent"
    objects: {
      subject: Prisma.$subjectPayload<ExtArgs>
      domain: Prisma.$domainPayload<ExtArgs>
      policy: Prisma.$consentPolicyPayload<ExtArgs> | null
      consentRecords: Prisma.$consentRecordPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      subjectId: string
      domainId: string
      policyId: string | null
      purposeIds: Prisma.JsonValue
      metadata: Prisma.JsonValue | null
      ipAddress: string | null
      userAgent: string | null
      status: string
      withdrawalReason: string | null
      givenAt: Date
      validUntil: Date | null
      isActive: boolean
    }, ExtArgs["result"]["consent"]>
    composites: {}
  }

  type consentGetPayload<S extends boolean | null | undefined | consentDefaultArgs> = $Result.GetResult<Prisma.$consentPayload, S>

  type consentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<consentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConsentCountAggregateInputType | true
    }

  export interface consentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['consent'], meta: { name: 'consent' } }
    /**
     * Find zero or one Consent that matches the filter.
     * @param {consentFindUniqueArgs} args - Arguments to find a Consent
     * @example
     * // Get one Consent
     * const consent = await prisma.consent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends consentFindUniqueArgs>(args: SelectSubset<T, consentFindUniqueArgs<ExtArgs>>): Prisma__consentClient<$Result.GetResult<Prisma.$consentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Consent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {consentFindUniqueOrThrowArgs} args - Arguments to find a Consent
     * @example
     * // Get one Consent
     * const consent = await prisma.consent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends consentFindUniqueOrThrowArgs>(args: SelectSubset<T, consentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__consentClient<$Result.GetResult<Prisma.$consentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Consent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {consentFindFirstArgs} args - Arguments to find a Consent
     * @example
     * // Get one Consent
     * const consent = await prisma.consent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends consentFindFirstArgs>(args?: SelectSubset<T, consentFindFirstArgs<ExtArgs>>): Prisma__consentClient<$Result.GetResult<Prisma.$consentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Consent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {consentFindFirstOrThrowArgs} args - Arguments to find a Consent
     * @example
     * // Get one Consent
     * const consent = await prisma.consent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends consentFindFirstOrThrowArgs>(args?: SelectSubset<T, consentFindFirstOrThrowArgs<ExtArgs>>): Prisma__consentClient<$Result.GetResult<Prisma.$consentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Consents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {consentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Consents
     * const consents = await prisma.consent.findMany()
     * 
     * // Get first 10 Consents
     * const consents = await prisma.consent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const consentWithIdOnly = await prisma.consent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends consentFindManyArgs>(args?: SelectSubset<T, consentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$consentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Consent.
     * @param {consentCreateArgs} args - Arguments to create a Consent.
     * @example
     * // Create one Consent
     * const Consent = await prisma.consent.create({
     *   data: {
     *     // ... data to create a Consent
     *   }
     * })
     * 
     */
    create<T extends consentCreateArgs>(args: SelectSubset<T, consentCreateArgs<ExtArgs>>): Prisma__consentClient<$Result.GetResult<Prisma.$consentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Consents.
     * @param {consentCreateManyArgs} args - Arguments to create many Consents.
     * @example
     * // Create many Consents
     * const consent = await prisma.consent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends consentCreateManyArgs>(args?: SelectSubset<T, consentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Consent.
     * @param {consentDeleteArgs} args - Arguments to delete one Consent.
     * @example
     * // Delete one Consent
     * const Consent = await prisma.consent.delete({
     *   where: {
     *     // ... filter to delete one Consent
     *   }
     * })
     * 
     */
    delete<T extends consentDeleteArgs>(args: SelectSubset<T, consentDeleteArgs<ExtArgs>>): Prisma__consentClient<$Result.GetResult<Prisma.$consentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Consent.
     * @param {consentUpdateArgs} args - Arguments to update one Consent.
     * @example
     * // Update one Consent
     * const consent = await prisma.consent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends consentUpdateArgs>(args: SelectSubset<T, consentUpdateArgs<ExtArgs>>): Prisma__consentClient<$Result.GetResult<Prisma.$consentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Consents.
     * @param {consentDeleteManyArgs} args - Arguments to filter Consents to delete.
     * @example
     * // Delete a few Consents
     * const { count } = await prisma.consent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends consentDeleteManyArgs>(args?: SelectSubset<T, consentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Consents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {consentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Consents
     * const consent = await prisma.consent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends consentUpdateManyArgs>(args: SelectSubset<T, consentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Consent.
     * @param {consentUpsertArgs} args - Arguments to update or create a Consent.
     * @example
     * // Update or create a Consent
     * const consent = await prisma.consent.upsert({
     *   create: {
     *     // ... data to create a Consent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Consent we want to update
     *   }
     * })
     */
    upsert<T extends consentUpsertArgs>(args: SelectSubset<T, consentUpsertArgs<ExtArgs>>): Prisma__consentClient<$Result.GetResult<Prisma.$consentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Consents that matches the filter.
     * @param {consentFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const consent = await prisma.consent.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: consentFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Consent.
     * @param {consentAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const consent = await prisma.consent.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: consentAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Consents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {consentCountArgs} args - Arguments to filter Consents to count.
     * @example
     * // Count the number of Consents
     * const count = await prisma.consent.count({
     *   where: {
     *     // ... the filter for the Consents we want to count
     *   }
     * })
    **/
    count<T extends consentCountArgs>(
      args?: Subset<T, consentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConsentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Consent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConsentAggregateArgs>(args: Subset<T, ConsentAggregateArgs>): Prisma.PrismaPromise<GetConsentAggregateType<T>>

    /**
     * Group by Consent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {consentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends consentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: consentGroupByArgs['orderBy'] }
        : { orderBy?: consentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, consentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConsentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the consent model
   */
  readonly fields: consentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for consent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__consentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subject<T extends subjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, subjectDefaultArgs<ExtArgs>>): Prisma__subjectClient<$Result.GetResult<Prisma.$subjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    domain<T extends domainDefaultArgs<ExtArgs> = {}>(args?: Subset<T, domainDefaultArgs<ExtArgs>>): Prisma__domainClient<$Result.GetResult<Prisma.$domainPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    policy<T extends consent$policyArgs<ExtArgs> = {}>(args?: Subset<T, consent$policyArgs<ExtArgs>>): Prisma__consentPolicyClient<$Result.GetResult<Prisma.$consentPolicyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    consentRecords<T extends consent$consentRecordsArgs<ExtArgs> = {}>(args?: Subset<T, consent$consentRecordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$consentRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the consent model
   */
  interface consentFieldRefs {
    readonly id: FieldRef<"consent", 'String'>
    readonly subjectId: FieldRef<"consent", 'String'>
    readonly domainId: FieldRef<"consent", 'String'>
    readonly policyId: FieldRef<"consent", 'String'>
    readonly purposeIds: FieldRef<"consent", 'Json'>
    readonly metadata: FieldRef<"consent", 'Json'>
    readonly ipAddress: FieldRef<"consent", 'String'>
    readonly userAgent: FieldRef<"consent", 'String'>
    readonly status: FieldRef<"consent", 'String'>
    readonly withdrawalReason: FieldRef<"consent", 'String'>
    readonly givenAt: FieldRef<"consent", 'DateTime'>
    readonly validUntil: FieldRef<"consent", 'DateTime'>
    readonly isActive: FieldRef<"consent", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * consent findUnique
   */
  export type consentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consent
     */
    select?: consentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consent
     */
    omit?: consentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: consentInclude<ExtArgs> | null
    /**
     * Filter, which consent to fetch.
     */
    where: consentWhereUniqueInput
  }

  /**
   * consent findUniqueOrThrow
   */
  export type consentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consent
     */
    select?: consentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consent
     */
    omit?: consentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: consentInclude<ExtArgs> | null
    /**
     * Filter, which consent to fetch.
     */
    where: consentWhereUniqueInput
  }

  /**
   * consent findFirst
   */
  export type consentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consent
     */
    select?: consentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consent
     */
    omit?: consentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: consentInclude<ExtArgs> | null
    /**
     * Filter, which consent to fetch.
     */
    where?: consentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of consents to fetch.
     */
    orderBy?: consentOrderByWithRelationInput | consentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for consents.
     */
    cursor?: consentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` consents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` consents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of consents.
     */
    distinct?: ConsentScalarFieldEnum | ConsentScalarFieldEnum[]
  }

  /**
   * consent findFirstOrThrow
   */
  export type consentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consent
     */
    select?: consentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consent
     */
    omit?: consentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: consentInclude<ExtArgs> | null
    /**
     * Filter, which consent to fetch.
     */
    where?: consentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of consents to fetch.
     */
    orderBy?: consentOrderByWithRelationInput | consentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for consents.
     */
    cursor?: consentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` consents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` consents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of consents.
     */
    distinct?: ConsentScalarFieldEnum | ConsentScalarFieldEnum[]
  }

  /**
   * consent findMany
   */
  export type consentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consent
     */
    select?: consentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consent
     */
    omit?: consentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: consentInclude<ExtArgs> | null
    /**
     * Filter, which consents to fetch.
     */
    where?: consentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of consents to fetch.
     */
    orderBy?: consentOrderByWithRelationInput | consentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing consents.
     */
    cursor?: consentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` consents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` consents.
     */
    skip?: number
    distinct?: ConsentScalarFieldEnum | ConsentScalarFieldEnum[]
  }

  /**
   * consent create
   */
  export type consentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consent
     */
    select?: consentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consent
     */
    omit?: consentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: consentInclude<ExtArgs> | null
    /**
     * The data needed to create a consent.
     */
    data: XOR<consentCreateInput, consentUncheckedCreateInput>
  }

  /**
   * consent createMany
   */
  export type consentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many consents.
     */
    data: consentCreateManyInput | consentCreateManyInput[]
  }

  /**
   * consent update
   */
  export type consentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consent
     */
    select?: consentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consent
     */
    omit?: consentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: consentInclude<ExtArgs> | null
    /**
     * The data needed to update a consent.
     */
    data: XOR<consentUpdateInput, consentUncheckedUpdateInput>
    /**
     * Choose, which consent to update.
     */
    where: consentWhereUniqueInput
  }

  /**
   * consent updateMany
   */
  export type consentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update consents.
     */
    data: XOR<consentUpdateManyMutationInput, consentUncheckedUpdateManyInput>
    /**
     * Filter which consents to update
     */
    where?: consentWhereInput
    /**
     * Limit how many consents to update.
     */
    limit?: number
  }

  /**
   * consent upsert
   */
  export type consentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consent
     */
    select?: consentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consent
     */
    omit?: consentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: consentInclude<ExtArgs> | null
    /**
     * The filter to search for the consent to update in case it exists.
     */
    where: consentWhereUniqueInput
    /**
     * In case the consent found by the `where` argument doesn't exist, create a new consent with this data.
     */
    create: XOR<consentCreateInput, consentUncheckedCreateInput>
    /**
     * In case the consent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<consentUpdateInput, consentUncheckedUpdateInput>
  }

  /**
   * consent delete
   */
  export type consentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consent
     */
    select?: consentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consent
     */
    omit?: consentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: consentInclude<ExtArgs> | null
    /**
     * Filter which consent to delete.
     */
    where: consentWhereUniqueInput
  }

  /**
   * consent deleteMany
   */
  export type consentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which consents to delete
     */
    where?: consentWhereInput
    /**
     * Limit how many consents to delete.
     */
    limit?: number
  }

  /**
   * consent findRaw
   */
  export type consentFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * consent aggregateRaw
   */
  export type consentAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * consent.policy
   */
  export type consent$policyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consentPolicy
     */
    select?: consentPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the consentPolicy
     */
    omit?: consentPolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: consentPolicyInclude<ExtArgs> | null
    where?: consentPolicyWhereInput
  }

  /**
   * consent.consentRecords
   */
  export type consent$consentRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consentRecord
     */
    select?: consentRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consentRecord
     */
    omit?: consentRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: consentRecordInclude<ExtArgs> | null
    where?: consentRecordWhereInput
    orderBy?: consentRecordOrderByWithRelationInput | consentRecordOrderByWithRelationInput[]
    cursor?: consentRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConsentRecordScalarFieldEnum | ConsentRecordScalarFieldEnum[]
  }

  /**
   * consent without action
   */
  export type consentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consent
     */
    select?: consentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consent
     */
    omit?: consentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: consentInclude<ExtArgs> | null
  }


  /**
   * Model auditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    entityType: string | null
    entityId: string | null
    actionType: string | null
    subjectId: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
    eventTimezone: string | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    entityType: string | null
    entityId: string | null
    actionType: string | null
    subjectId: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
    eventTimezone: string | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    entityType: number
    entityId: number
    actionType: number
    subjectId: number
    ipAddress: number
    userAgent: number
    changes: number
    metadata: number
    createdAt: number
    eventTimezone: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    entityType?: true
    entityId?: true
    actionType?: true
    subjectId?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    eventTimezone?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    entityType?: true
    entityId?: true
    actionType?: true
    subjectId?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    eventTimezone?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    entityType?: true
    entityId?: true
    actionType?: true
    subjectId?: true
    ipAddress?: true
    userAgent?: true
    changes?: true
    metadata?: true
    createdAt?: true
    eventTimezone?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which auditLog to aggregate.
     */
    where?: auditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of auditLogs to fetch.
     */
    orderBy?: auditLogOrderByWithRelationInput | auditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: auditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` auditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` auditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned auditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type auditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: auditLogWhereInput
    orderBy?: auditLogOrderByWithAggregationInput | auditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: auditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    entityType: string
    entityId: string
    actionType: string
    subjectId: string | null
    ipAddress: string | null
    userAgent: string | null
    changes: JsonValue | null
    metadata: JsonValue | null
    createdAt: Date
    eventTimezone: string
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends auditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type auditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entityType?: boolean
    entityId?: boolean
    actionType?: boolean
    subjectId?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    changes?: boolean
    metadata?: boolean
    createdAt?: boolean
    eventTimezone?: boolean
    subject?: boolean | auditLog$subjectArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>



  export type auditLogSelectScalar = {
    id?: boolean
    entityType?: boolean
    entityId?: boolean
    actionType?: boolean
    subjectId?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    changes?: boolean
    metadata?: boolean
    createdAt?: boolean
    eventTimezone?: boolean
  }

  export type auditLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "entityType" | "entityId" | "actionType" | "subjectId" | "ipAddress" | "userAgent" | "changes" | "metadata" | "createdAt" | "eventTimezone", ExtArgs["result"]["auditLog"]>
  export type auditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subject?: boolean | auditLog$subjectArgs<ExtArgs>
  }

  export type $auditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "auditLog"
    objects: {
      subject: Prisma.$subjectPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      entityType: string
      entityId: string
      actionType: string
      subjectId: string | null
      ipAddress: string | null
      userAgent: string | null
      changes: Prisma.JsonValue | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
      eventTimezone: string
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type auditLogGetPayload<S extends boolean | null | undefined | auditLogDefaultArgs> = $Result.GetResult<Prisma.$auditLogPayload, S>

  type auditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<auditLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface auditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['auditLog'], meta: { name: 'auditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {auditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends auditLogFindUniqueArgs>(args: SelectSubset<T, auditLogFindUniqueArgs<ExtArgs>>): Prisma__auditLogClient<$Result.GetResult<Prisma.$auditLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {auditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends auditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, auditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__auditLogClient<$Result.GetResult<Prisma.$auditLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends auditLogFindFirstArgs>(args?: SelectSubset<T, auditLogFindFirstArgs<ExtArgs>>): Prisma__auditLogClient<$Result.GetResult<Prisma.$auditLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends auditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, auditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__auditLogClient<$Result.GetResult<Prisma.$auditLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends auditLogFindManyArgs>(args?: SelectSubset<T, auditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$auditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AuditLog.
     * @param {auditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends auditLogCreateArgs>(args: SelectSubset<T, auditLogCreateArgs<ExtArgs>>): Prisma__auditLogClient<$Result.GetResult<Prisma.$auditLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AuditLogs.
     * @param {auditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends auditLogCreateManyArgs>(args?: SelectSubset<T, auditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AuditLog.
     * @param {auditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends auditLogDeleteArgs>(args: SelectSubset<T, auditLogDeleteArgs<ExtArgs>>): Prisma__auditLogClient<$Result.GetResult<Prisma.$auditLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AuditLog.
     * @param {auditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends auditLogUpdateArgs>(args: SelectSubset<T, auditLogUpdateArgs<ExtArgs>>): Prisma__auditLogClient<$Result.GetResult<Prisma.$auditLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AuditLogs.
     * @param {auditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends auditLogDeleteManyArgs>(args?: SelectSubset<T, auditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends auditLogUpdateManyArgs>(args: SelectSubset<T, auditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AuditLog.
     * @param {auditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends auditLogUpsertArgs>(args: SelectSubset<T, auditLogUpsertArgs<ExtArgs>>): Prisma__auditLogClient<$Result.GetResult<Prisma.$auditLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * @param {auditLogFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const auditLog = await prisma.auditLog.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: auditLogFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a AuditLog.
     * @param {auditLogAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const auditLog = await prisma.auditLog.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: auditLogAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends auditLogCountArgs>(
      args?: Subset<T, auditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends auditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: auditLogGroupByArgs['orderBy'] }
        : { orderBy?: auditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, auditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the auditLog model
   */
  readonly fields: auditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for auditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__auditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subject<T extends auditLog$subjectArgs<ExtArgs> = {}>(args?: Subset<T, auditLog$subjectArgs<ExtArgs>>): Prisma__subjectClient<$Result.GetResult<Prisma.$subjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the auditLog model
   */
  interface auditLogFieldRefs {
    readonly id: FieldRef<"auditLog", 'String'>
    readonly entityType: FieldRef<"auditLog", 'String'>
    readonly entityId: FieldRef<"auditLog", 'String'>
    readonly actionType: FieldRef<"auditLog", 'String'>
    readonly subjectId: FieldRef<"auditLog", 'String'>
    readonly ipAddress: FieldRef<"auditLog", 'String'>
    readonly userAgent: FieldRef<"auditLog", 'String'>
    readonly changes: FieldRef<"auditLog", 'Json'>
    readonly metadata: FieldRef<"auditLog", 'Json'>
    readonly createdAt: FieldRef<"auditLog", 'DateTime'>
    readonly eventTimezone: FieldRef<"auditLog", 'String'>
  }
    

  // Custom InputTypes
  /**
   * auditLog findUnique
   */
  export type auditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auditLog
     */
    select?: auditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auditLog
     */
    omit?: auditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditLogInclude<ExtArgs> | null
    /**
     * Filter, which auditLog to fetch.
     */
    where: auditLogWhereUniqueInput
  }

  /**
   * auditLog findUniqueOrThrow
   */
  export type auditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auditLog
     */
    select?: auditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auditLog
     */
    omit?: auditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditLogInclude<ExtArgs> | null
    /**
     * Filter, which auditLog to fetch.
     */
    where: auditLogWhereUniqueInput
  }

  /**
   * auditLog findFirst
   */
  export type auditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auditLog
     */
    select?: auditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auditLog
     */
    omit?: auditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditLogInclude<ExtArgs> | null
    /**
     * Filter, which auditLog to fetch.
     */
    where?: auditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of auditLogs to fetch.
     */
    orderBy?: auditLogOrderByWithRelationInput | auditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for auditLogs.
     */
    cursor?: auditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` auditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` auditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of auditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * auditLog findFirstOrThrow
   */
  export type auditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auditLog
     */
    select?: auditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auditLog
     */
    omit?: auditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditLogInclude<ExtArgs> | null
    /**
     * Filter, which auditLog to fetch.
     */
    where?: auditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of auditLogs to fetch.
     */
    orderBy?: auditLogOrderByWithRelationInput | auditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for auditLogs.
     */
    cursor?: auditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` auditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` auditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of auditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * auditLog findMany
   */
  export type auditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auditLog
     */
    select?: auditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auditLog
     */
    omit?: auditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditLogInclude<ExtArgs> | null
    /**
     * Filter, which auditLogs to fetch.
     */
    where?: auditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of auditLogs to fetch.
     */
    orderBy?: auditLogOrderByWithRelationInput | auditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing auditLogs.
     */
    cursor?: auditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` auditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` auditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * auditLog create
   */
  export type auditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auditLog
     */
    select?: auditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auditLog
     */
    omit?: auditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a auditLog.
     */
    data: XOR<auditLogCreateInput, auditLogUncheckedCreateInput>
  }

  /**
   * auditLog createMany
   */
  export type auditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many auditLogs.
     */
    data: auditLogCreateManyInput | auditLogCreateManyInput[]
  }

  /**
   * auditLog update
   */
  export type auditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auditLog
     */
    select?: auditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auditLog
     */
    omit?: auditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a auditLog.
     */
    data: XOR<auditLogUpdateInput, auditLogUncheckedUpdateInput>
    /**
     * Choose, which auditLog to update.
     */
    where: auditLogWhereUniqueInput
  }

  /**
   * auditLog updateMany
   */
  export type auditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update auditLogs.
     */
    data: XOR<auditLogUpdateManyMutationInput, auditLogUncheckedUpdateManyInput>
    /**
     * Filter which auditLogs to update
     */
    where?: auditLogWhereInput
    /**
     * Limit how many auditLogs to update.
     */
    limit?: number
  }

  /**
   * auditLog upsert
   */
  export type auditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auditLog
     */
    select?: auditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auditLog
     */
    omit?: auditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the auditLog to update in case it exists.
     */
    where: auditLogWhereUniqueInput
    /**
     * In case the auditLog found by the `where` argument doesn't exist, create a new auditLog with this data.
     */
    create: XOR<auditLogCreateInput, auditLogUncheckedCreateInput>
    /**
     * In case the auditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<auditLogUpdateInput, auditLogUncheckedUpdateInput>
  }

  /**
   * auditLog delete
   */
  export type auditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auditLog
     */
    select?: auditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auditLog
     */
    omit?: auditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditLogInclude<ExtArgs> | null
    /**
     * Filter which auditLog to delete.
     */
    where: auditLogWhereUniqueInput
  }

  /**
   * auditLog deleteMany
   */
  export type auditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which auditLogs to delete
     */
    where?: auditLogWhereInput
    /**
     * Limit how many auditLogs to delete.
     */
    limit?: number
  }

  /**
   * auditLog findRaw
   */
  export type auditLogFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * auditLog aggregateRaw
   */
  export type auditLogAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * auditLog.subject
   */
  export type auditLog$subjectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subject
     */
    select?: subjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subject
     */
    omit?: subjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subjectInclude<ExtArgs> | null
    where?: subjectWhereInput
  }

  /**
   * auditLog without action
   */
  export type auditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auditLog
     */
    select?: auditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auditLog
     */
    omit?: auditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditLogInclude<ExtArgs> | null
  }


  /**
   * Model consentRecord
   */

  export type AggregateConsentRecord = {
    _count: ConsentRecordCountAggregateOutputType | null
    _min: ConsentRecordMinAggregateOutputType | null
    _max: ConsentRecordMaxAggregateOutputType | null
  }

  export type ConsentRecordMinAggregateOutputType = {
    id: string | null
    subjectId: string | null
    consentId: string | null
    actionType: string | null
    createdAt: Date | null
  }

  export type ConsentRecordMaxAggregateOutputType = {
    id: string | null
    subjectId: string | null
    consentId: string | null
    actionType: string | null
    createdAt: Date | null
  }

  export type ConsentRecordCountAggregateOutputType = {
    id: number
    subjectId: number
    consentId: number
    actionType: number
    details: number
    createdAt: number
    _all: number
  }


  export type ConsentRecordMinAggregateInputType = {
    id?: true
    subjectId?: true
    consentId?: true
    actionType?: true
    createdAt?: true
  }

  export type ConsentRecordMaxAggregateInputType = {
    id?: true
    subjectId?: true
    consentId?: true
    actionType?: true
    createdAt?: true
  }

  export type ConsentRecordCountAggregateInputType = {
    id?: true
    subjectId?: true
    consentId?: true
    actionType?: true
    details?: true
    createdAt?: true
    _all?: true
  }

  export type ConsentRecordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which consentRecord to aggregate.
     */
    where?: consentRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of consentRecords to fetch.
     */
    orderBy?: consentRecordOrderByWithRelationInput | consentRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: consentRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` consentRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` consentRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned consentRecords
    **/
    _count?: true | ConsentRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConsentRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConsentRecordMaxAggregateInputType
  }

  export type GetConsentRecordAggregateType<T extends ConsentRecordAggregateArgs> = {
        [P in keyof T & keyof AggregateConsentRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConsentRecord[P]>
      : GetScalarType<T[P], AggregateConsentRecord[P]>
  }




  export type consentRecordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: consentRecordWhereInput
    orderBy?: consentRecordOrderByWithAggregationInput | consentRecordOrderByWithAggregationInput[]
    by: ConsentRecordScalarFieldEnum[] | ConsentRecordScalarFieldEnum
    having?: consentRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConsentRecordCountAggregateInputType | true
    _min?: ConsentRecordMinAggregateInputType
    _max?: ConsentRecordMaxAggregateInputType
  }

  export type ConsentRecordGroupByOutputType = {
    id: string
    subjectId: string
    consentId: string | null
    actionType: string
    details: JsonValue | null
    createdAt: Date
    _count: ConsentRecordCountAggregateOutputType | null
    _min: ConsentRecordMinAggregateOutputType | null
    _max: ConsentRecordMaxAggregateOutputType | null
  }

  type GetConsentRecordGroupByPayload<T extends consentRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConsentRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConsentRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConsentRecordGroupByOutputType[P]>
            : GetScalarType<T[P], ConsentRecordGroupByOutputType[P]>
        }
      >
    >


  export type consentRecordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subjectId?: boolean
    consentId?: boolean
    actionType?: boolean
    details?: boolean
    createdAt?: boolean
    subject?: boolean | subjectDefaultArgs<ExtArgs>
    consent?: boolean | consentRecord$consentArgs<ExtArgs>
  }, ExtArgs["result"]["consentRecord"]>



  export type consentRecordSelectScalar = {
    id?: boolean
    subjectId?: boolean
    consentId?: boolean
    actionType?: boolean
    details?: boolean
    createdAt?: boolean
  }

  export type consentRecordOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "subjectId" | "consentId" | "actionType" | "details" | "createdAt", ExtArgs["result"]["consentRecord"]>
  export type consentRecordInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subject?: boolean | subjectDefaultArgs<ExtArgs>
    consent?: boolean | consentRecord$consentArgs<ExtArgs>
  }

  export type $consentRecordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "consentRecord"
    objects: {
      subject: Prisma.$subjectPayload<ExtArgs>
      consent: Prisma.$consentPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      subjectId: string
      consentId: string | null
      actionType: string
      details: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["consentRecord"]>
    composites: {}
  }

  type consentRecordGetPayload<S extends boolean | null | undefined | consentRecordDefaultArgs> = $Result.GetResult<Prisma.$consentRecordPayload, S>

  type consentRecordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<consentRecordFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConsentRecordCountAggregateInputType | true
    }

  export interface consentRecordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['consentRecord'], meta: { name: 'consentRecord' } }
    /**
     * Find zero or one ConsentRecord that matches the filter.
     * @param {consentRecordFindUniqueArgs} args - Arguments to find a ConsentRecord
     * @example
     * // Get one ConsentRecord
     * const consentRecord = await prisma.consentRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends consentRecordFindUniqueArgs>(args: SelectSubset<T, consentRecordFindUniqueArgs<ExtArgs>>): Prisma__consentRecordClient<$Result.GetResult<Prisma.$consentRecordPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ConsentRecord that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {consentRecordFindUniqueOrThrowArgs} args - Arguments to find a ConsentRecord
     * @example
     * // Get one ConsentRecord
     * const consentRecord = await prisma.consentRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends consentRecordFindUniqueOrThrowArgs>(args: SelectSubset<T, consentRecordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__consentRecordClient<$Result.GetResult<Prisma.$consentRecordPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConsentRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {consentRecordFindFirstArgs} args - Arguments to find a ConsentRecord
     * @example
     * // Get one ConsentRecord
     * const consentRecord = await prisma.consentRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends consentRecordFindFirstArgs>(args?: SelectSubset<T, consentRecordFindFirstArgs<ExtArgs>>): Prisma__consentRecordClient<$Result.GetResult<Prisma.$consentRecordPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConsentRecord that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {consentRecordFindFirstOrThrowArgs} args - Arguments to find a ConsentRecord
     * @example
     * // Get one ConsentRecord
     * const consentRecord = await prisma.consentRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends consentRecordFindFirstOrThrowArgs>(args?: SelectSubset<T, consentRecordFindFirstOrThrowArgs<ExtArgs>>): Prisma__consentRecordClient<$Result.GetResult<Prisma.$consentRecordPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ConsentRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {consentRecordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ConsentRecords
     * const consentRecords = await prisma.consentRecord.findMany()
     * 
     * // Get first 10 ConsentRecords
     * const consentRecords = await prisma.consentRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const consentRecordWithIdOnly = await prisma.consentRecord.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends consentRecordFindManyArgs>(args?: SelectSubset<T, consentRecordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$consentRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ConsentRecord.
     * @param {consentRecordCreateArgs} args - Arguments to create a ConsentRecord.
     * @example
     * // Create one ConsentRecord
     * const ConsentRecord = await prisma.consentRecord.create({
     *   data: {
     *     // ... data to create a ConsentRecord
     *   }
     * })
     * 
     */
    create<T extends consentRecordCreateArgs>(args: SelectSubset<T, consentRecordCreateArgs<ExtArgs>>): Prisma__consentRecordClient<$Result.GetResult<Prisma.$consentRecordPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ConsentRecords.
     * @param {consentRecordCreateManyArgs} args - Arguments to create many ConsentRecords.
     * @example
     * // Create many ConsentRecords
     * const consentRecord = await prisma.consentRecord.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends consentRecordCreateManyArgs>(args?: SelectSubset<T, consentRecordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ConsentRecord.
     * @param {consentRecordDeleteArgs} args - Arguments to delete one ConsentRecord.
     * @example
     * // Delete one ConsentRecord
     * const ConsentRecord = await prisma.consentRecord.delete({
     *   where: {
     *     // ... filter to delete one ConsentRecord
     *   }
     * })
     * 
     */
    delete<T extends consentRecordDeleteArgs>(args: SelectSubset<T, consentRecordDeleteArgs<ExtArgs>>): Prisma__consentRecordClient<$Result.GetResult<Prisma.$consentRecordPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ConsentRecord.
     * @param {consentRecordUpdateArgs} args - Arguments to update one ConsentRecord.
     * @example
     * // Update one ConsentRecord
     * const consentRecord = await prisma.consentRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends consentRecordUpdateArgs>(args: SelectSubset<T, consentRecordUpdateArgs<ExtArgs>>): Prisma__consentRecordClient<$Result.GetResult<Prisma.$consentRecordPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ConsentRecords.
     * @param {consentRecordDeleteManyArgs} args - Arguments to filter ConsentRecords to delete.
     * @example
     * // Delete a few ConsentRecords
     * const { count } = await prisma.consentRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends consentRecordDeleteManyArgs>(args?: SelectSubset<T, consentRecordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConsentRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {consentRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ConsentRecords
     * const consentRecord = await prisma.consentRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends consentRecordUpdateManyArgs>(args: SelectSubset<T, consentRecordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ConsentRecord.
     * @param {consentRecordUpsertArgs} args - Arguments to update or create a ConsentRecord.
     * @example
     * // Update or create a ConsentRecord
     * const consentRecord = await prisma.consentRecord.upsert({
     *   create: {
     *     // ... data to create a ConsentRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ConsentRecord we want to update
     *   }
     * })
     */
    upsert<T extends consentRecordUpsertArgs>(args: SelectSubset<T, consentRecordUpsertArgs<ExtArgs>>): Prisma__consentRecordClient<$Result.GetResult<Prisma.$consentRecordPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ConsentRecords that matches the filter.
     * @param {consentRecordFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const consentRecord = await prisma.consentRecord.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: consentRecordFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a ConsentRecord.
     * @param {consentRecordAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const consentRecord = await prisma.consentRecord.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: consentRecordAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of ConsentRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {consentRecordCountArgs} args - Arguments to filter ConsentRecords to count.
     * @example
     * // Count the number of ConsentRecords
     * const count = await prisma.consentRecord.count({
     *   where: {
     *     // ... the filter for the ConsentRecords we want to count
     *   }
     * })
    **/
    count<T extends consentRecordCountArgs>(
      args?: Subset<T, consentRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConsentRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ConsentRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsentRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConsentRecordAggregateArgs>(args: Subset<T, ConsentRecordAggregateArgs>): Prisma.PrismaPromise<GetConsentRecordAggregateType<T>>

    /**
     * Group by ConsentRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {consentRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends consentRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: consentRecordGroupByArgs['orderBy'] }
        : { orderBy?: consentRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, consentRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConsentRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the consentRecord model
   */
  readonly fields: consentRecordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for consentRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__consentRecordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subject<T extends subjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, subjectDefaultArgs<ExtArgs>>): Prisma__subjectClient<$Result.GetResult<Prisma.$subjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    consent<T extends consentRecord$consentArgs<ExtArgs> = {}>(args?: Subset<T, consentRecord$consentArgs<ExtArgs>>): Prisma__consentClient<$Result.GetResult<Prisma.$consentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the consentRecord model
   */
  interface consentRecordFieldRefs {
    readonly id: FieldRef<"consentRecord", 'String'>
    readonly subjectId: FieldRef<"consentRecord", 'String'>
    readonly consentId: FieldRef<"consentRecord", 'String'>
    readonly actionType: FieldRef<"consentRecord", 'String'>
    readonly details: FieldRef<"consentRecord", 'Json'>
    readonly createdAt: FieldRef<"consentRecord", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * consentRecord findUnique
   */
  export type consentRecordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consentRecord
     */
    select?: consentRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consentRecord
     */
    omit?: consentRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: consentRecordInclude<ExtArgs> | null
    /**
     * Filter, which consentRecord to fetch.
     */
    where: consentRecordWhereUniqueInput
  }

  /**
   * consentRecord findUniqueOrThrow
   */
  export type consentRecordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consentRecord
     */
    select?: consentRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consentRecord
     */
    omit?: consentRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: consentRecordInclude<ExtArgs> | null
    /**
     * Filter, which consentRecord to fetch.
     */
    where: consentRecordWhereUniqueInput
  }

  /**
   * consentRecord findFirst
   */
  export type consentRecordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consentRecord
     */
    select?: consentRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consentRecord
     */
    omit?: consentRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: consentRecordInclude<ExtArgs> | null
    /**
     * Filter, which consentRecord to fetch.
     */
    where?: consentRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of consentRecords to fetch.
     */
    orderBy?: consentRecordOrderByWithRelationInput | consentRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for consentRecords.
     */
    cursor?: consentRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` consentRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` consentRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of consentRecords.
     */
    distinct?: ConsentRecordScalarFieldEnum | ConsentRecordScalarFieldEnum[]
  }

  /**
   * consentRecord findFirstOrThrow
   */
  export type consentRecordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consentRecord
     */
    select?: consentRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consentRecord
     */
    omit?: consentRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: consentRecordInclude<ExtArgs> | null
    /**
     * Filter, which consentRecord to fetch.
     */
    where?: consentRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of consentRecords to fetch.
     */
    orderBy?: consentRecordOrderByWithRelationInput | consentRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for consentRecords.
     */
    cursor?: consentRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` consentRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` consentRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of consentRecords.
     */
    distinct?: ConsentRecordScalarFieldEnum | ConsentRecordScalarFieldEnum[]
  }

  /**
   * consentRecord findMany
   */
  export type consentRecordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consentRecord
     */
    select?: consentRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consentRecord
     */
    omit?: consentRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: consentRecordInclude<ExtArgs> | null
    /**
     * Filter, which consentRecords to fetch.
     */
    where?: consentRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of consentRecords to fetch.
     */
    orderBy?: consentRecordOrderByWithRelationInput | consentRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing consentRecords.
     */
    cursor?: consentRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` consentRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` consentRecords.
     */
    skip?: number
    distinct?: ConsentRecordScalarFieldEnum | ConsentRecordScalarFieldEnum[]
  }

  /**
   * consentRecord create
   */
  export type consentRecordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consentRecord
     */
    select?: consentRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consentRecord
     */
    omit?: consentRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: consentRecordInclude<ExtArgs> | null
    /**
     * The data needed to create a consentRecord.
     */
    data: XOR<consentRecordCreateInput, consentRecordUncheckedCreateInput>
  }

  /**
   * consentRecord createMany
   */
  export type consentRecordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many consentRecords.
     */
    data: consentRecordCreateManyInput | consentRecordCreateManyInput[]
  }

  /**
   * consentRecord update
   */
  export type consentRecordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consentRecord
     */
    select?: consentRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consentRecord
     */
    omit?: consentRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: consentRecordInclude<ExtArgs> | null
    /**
     * The data needed to update a consentRecord.
     */
    data: XOR<consentRecordUpdateInput, consentRecordUncheckedUpdateInput>
    /**
     * Choose, which consentRecord to update.
     */
    where: consentRecordWhereUniqueInput
  }

  /**
   * consentRecord updateMany
   */
  export type consentRecordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update consentRecords.
     */
    data: XOR<consentRecordUpdateManyMutationInput, consentRecordUncheckedUpdateManyInput>
    /**
     * Filter which consentRecords to update
     */
    where?: consentRecordWhereInput
    /**
     * Limit how many consentRecords to update.
     */
    limit?: number
  }

  /**
   * consentRecord upsert
   */
  export type consentRecordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consentRecord
     */
    select?: consentRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consentRecord
     */
    omit?: consentRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: consentRecordInclude<ExtArgs> | null
    /**
     * The filter to search for the consentRecord to update in case it exists.
     */
    where: consentRecordWhereUniqueInput
    /**
     * In case the consentRecord found by the `where` argument doesn't exist, create a new consentRecord with this data.
     */
    create: XOR<consentRecordCreateInput, consentRecordUncheckedCreateInput>
    /**
     * In case the consentRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<consentRecordUpdateInput, consentRecordUncheckedUpdateInput>
  }

  /**
   * consentRecord delete
   */
  export type consentRecordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consentRecord
     */
    select?: consentRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consentRecord
     */
    omit?: consentRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: consentRecordInclude<ExtArgs> | null
    /**
     * Filter which consentRecord to delete.
     */
    where: consentRecordWhereUniqueInput
  }

  /**
   * consentRecord deleteMany
   */
  export type consentRecordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which consentRecords to delete
     */
    where?: consentRecordWhereInput
    /**
     * Limit how many consentRecords to delete.
     */
    limit?: number
  }

  /**
   * consentRecord findRaw
   */
  export type consentRecordFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * consentRecord aggregateRaw
   */
  export type consentRecordAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * consentRecord.consent
   */
  export type consentRecord$consentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consent
     */
    select?: consentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consent
     */
    omit?: consentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: consentInclude<ExtArgs> | null
    where?: consentWhereInput
  }

  /**
   * consentRecord without action
   */
  export type consentRecordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consentRecord
     */
    select?: consentRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consentRecord
     */
    omit?: consentRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: consentRecordInclude<ExtArgs> | null
  }


  /**
   * Model private_c15t_settings
   */

  export type AggregatePrivate_c15t_settings = {
    _count: Private_c15t_settingsCountAggregateOutputType | null
    _min: Private_c15t_settingsMinAggregateOutputType | null
    _max: Private_c15t_settingsMaxAggregateOutputType | null
  }

  export type Private_c15t_settingsMinAggregateOutputType = {
    key: string | null
    value: string | null
  }

  export type Private_c15t_settingsMaxAggregateOutputType = {
    key: string | null
    value: string | null
  }

  export type Private_c15t_settingsCountAggregateOutputType = {
    key: number
    value: number
    _all: number
  }


  export type Private_c15t_settingsMinAggregateInputType = {
    key?: true
    value?: true
  }

  export type Private_c15t_settingsMaxAggregateInputType = {
    key?: true
    value?: true
  }

  export type Private_c15t_settingsCountAggregateInputType = {
    key?: true
    value?: true
    _all?: true
  }

  export type Private_c15t_settingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which private_c15t_settings to aggregate.
     */
    where?: private_c15t_settingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of private_c15t_settings to fetch.
     */
    orderBy?: private_c15t_settingsOrderByWithRelationInput | private_c15t_settingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: private_c15t_settingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` private_c15t_settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` private_c15t_settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned private_c15t_settings
    **/
    _count?: true | Private_c15t_settingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Private_c15t_settingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Private_c15t_settingsMaxAggregateInputType
  }

  export type GetPrivate_c15t_settingsAggregateType<T extends Private_c15t_settingsAggregateArgs> = {
        [P in keyof T & keyof AggregatePrivate_c15t_settings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePrivate_c15t_settings[P]>
      : GetScalarType<T[P], AggregatePrivate_c15t_settings[P]>
  }




  export type private_c15t_settingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: private_c15t_settingsWhereInput
    orderBy?: private_c15t_settingsOrderByWithAggregationInput | private_c15t_settingsOrderByWithAggregationInput[]
    by: Private_c15t_settingsScalarFieldEnum[] | Private_c15t_settingsScalarFieldEnum
    having?: private_c15t_settingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Private_c15t_settingsCountAggregateInputType | true
    _min?: Private_c15t_settingsMinAggregateInputType
    _max?: Private_c15t_settingsMaxAggregateInputType
  }

  export type Private_c15t_settingsGroupByOutputType = {
    key: string
    value: string
    _count: Private_c15t_settingsCountAggregateOutputType | null
    _min: Private_c15t_settingsMinAggregateOutputType | null
    _max: Private_c15t_settingsMaxAggregateOutputType | null
  }

  type GetPrivate_c15t_settingsGroupByPayload<T extends private_c15t_settingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Private_c15t_settingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Private_c15t_settingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Private_c15t_settingsGroupByOutputType[P]>
            : GetScalarType<T[P], Private_c15t_settingsGroupByOutputType[P]>
        }
      >
    >


  export type private_c15t_settingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    key?: boolean
    value?: boolean
  }, ExtArgs["result"]["private_c15t_settings"]>



  export type private_c15t_settingsSelectScalar = {
    key?: boolean
    value?: boolean
  }

  export type private_c15t_settingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"key" | "value", ExtArgs["result"]["private_c15t_settings"]>

  export type $private_c15t_settingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "private_c15t_settings"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      key: string
      value: string
    }, ExtArgs["result"]["private_c15t_settings"]>
    composites: {}
  }

  type private_c15t_settingsGetPayload<S extends boolean | null | undefined | private_c15t_settingsDefaultArgs> = $Result.GetResult<Prisma.$private_c15t_settingsPayload, S>

  type private_c15t_settingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<private_c15t_settingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Private_c15t_settingsCountAggregateInputType | true
    }

  export interface private_c15t_settingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['private_c15t_settings'], meta: { name: 'private_c15t_settings' } }
    /**
     * Find zero or one Private_c15t_settings that matches the filter.
     * @param {private_c15t_settingsFindUniqueArgs} args - Arguments to find a Private_c15t_settings
     * @example
     * // Get one Private_c15t_settings
     * const private_c15t_settings = await prisma.private_c15t_settings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends private_c15t_settingsFindUniqueArgs>(args: SelectSubset<T, private_c15t_settingsFindUniqueArgs<ExtArgs>>): Prisma__private_c15t_settingsClient<$Result.GetResult<Prisma.$private_c15t_settingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Private_c15t_settings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {private_c15t_settingsFindUniqueOrThrowArgs} args - Arguments to find a Private_c15t_settings
     * @example
     * // Get one Private_c15t_settings
     * const private_c15t_settings = await prisma.private_c15t_settings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends private_c15t_settingsFindUniqueOrThrowArgs>(args: SelectSubset<T, private_c15t_settingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__private_c15t_settingsClient<$Result.GetResult<Prisma.$private_c15t_settingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Private_c15t_settings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {private_c15t_settingsFindFirstArgs} args - Arguments to find a Private_c15t_settings
     * @example
     * // Get one Private_c15t_settings
     * const private_c15t_settings = await prisma.private_c15t_settings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends private_c15t_settingsFindFirstArgs>(args?: SelectSubset<T, private_c15t_settingsFindFirstArgs<ExtArgs>>): Prisma__private_c15t_settingsClient<$Result.GetResult<Prisma.$private_c15t_settingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Private_c15t_settings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {private_c15t_settingsFindFirstOrThrowArgs} args - Arguments to find a Private_c15t_settings
     * @example
     * // Get one Private_c15t_settings
     * const private_c15t_settings = await prisma.private_c15t_settings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends private_c15t_settingsFindFirstOrThrowArgs>(args?: SelectSubset<T, private_c15t_settingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__private_c15t_settingsClient<$Result.GetResult<Prisma.$private_c15t_settingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Private_c15t_settings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {private_c15t_settingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Private_c15t_settings
     * const private_c15t_settings = await prisma.private_c15t_settings.findMany()
     * 
     * // Get first 10 Private_c15t_settings
     * const private_c15t_settings = await prisma.private_c15t_settings.findMany({ take: 10 })
     * 
     * // Only select the `key`
     * const private_c15t_settingsWithKeyOnly = await prisma.private_c15t_settings.findMany({ select: { key: true } })
     * 
     */
    findMany<T extends private_c15t_settingsFindManyArgs>(args?: SelectSubset<T, private_c15t_settingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$private_c15t_settingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Private_c15t_settings.
     * @param {private_c15t_settingsCreateArgs} args - Arguments to create a Private_c15t_settings.
     * @example
     * // Create one Private_c15t_settings
     * const Private_c15t_settings = await prisma.private_c15t_settings.create({
     *   data: {
     *     // ... data to create a Private_c15t_settings
     *   }
     * })
     * 
     */
    create<T extends private_c15t_settingsCreateArgs>(args: SelectSubset<T, private_c15t_settingsCreateArgs<ExtArgs>>): Prisma__private_c15t_settingsClient<$Result.GetResult<Prisma.$private_c15t_settingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Private_c15t_settings.
     * @param {private_c15t_settingsCreateManyArgs} args - Arguments to create many Private_c15t_settings.
     * @example
     * // Create many Private_c15t_settings
     * const private_c15t_settings = await prisma.private_c15t_settings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends private_c15t_settingsCreateManyArgs>(args?: SelectSubset<T, private_c15t_settingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Private_c15t_settings.
     * @param {private_c15t_settingsDeleteArgs} args - Arguments to delete one Private_c15t_settings.
     * @example
     * // Delete one Private_c15t_settings
     * const Private_c15t_settings = await prisma.private_c15t_settings.delete({
     *   where: {
     *     // ... filter to delete one Private_c15t_settings
     *   }
     * })
     * 
     */
    delete<T extends private_c15t_settingsDeleteArgs>(args: SelectSubset<T, private_c15t_settingsDeleteArgs<ExtArgs>>): Prisma__private_c15t_settingsClient<$Result.GetResult<Prisma.$private_c15t_settingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Private_c15t_settings.
     * @param {private_c15t_settingsUpdateArgs} args - Arguments to update one Private_c15t_settings.
     * @example
     * // Update one Private_c15t_settings
     * const private_c15t_settings = await prisma.private_c15t_settings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends private_c15t_settingsUpdateArgs>(args: SelectSubset<T, private_c15t_settingsUpdateArgs<ExtArgs>>): Prisma__private_c15t_settingsClient<$Result.GetResult<Prisma.$private_c15t_settingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Private_c15t_settings.
     * @param {private_c15t_settingsDeleteManyArgs} args - Arguments to filter Private_c15t_settings to delete.
     * @example
     * // Delete a few Private_c15t_settings
     * const { count } = await prisma.private_c15t_settings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends private_c15t_settingsDeleteManyArgs>(args?: SelectSubset<T, private_c15t_settingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Private_c15t_settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {private_c15t_settingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Private_c15t_settings
     * const private_c15t_settings = await prisma.private_c15t_settings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends private_c15t_settingsUpdateManyArgs>(args: SelectSubset<T, private_c15t_settingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Private_c15t_settings.
     * @param {private_c15t_settingsUpsertArgs} args - Arguments to update or create a Private_c15t_settings.
     * @example
     * // Update or create a Private_c15t_settings
     * const private_c15t_settings = await prisma.private_c15t_settings.upsert({
     *   create: {
     *     // ... data to create a Private_c15t_settings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Private_c15t_settings we want to update
     *   }
     * })
     */
    upsert<T extends private_c15t_settingsUpsertArgs>(args: SelectSubset<T, private_c15t_settingsUpsertArgs<ExtArgs>>): Prisma__private_c15t_settingsClient<$Result.GetResult<Prisma.$private_c15t_settingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Private_c15t_settings that matches the filter.
     * @param {private_c15t_settingsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const private_c15t_settings = await prisma.private_c15t_settings.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: private_c15t_settingsFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Private_c15t_settings.
     * @param {private_c15t_settingsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const private_c15t_settings = await prisma.private_c15t_settings.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: private_c15t_settingsAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Private_c15t_settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {private_c15t_settingsCountArgs} args - Arguments to filter Private_c15t_settings to count.
     * @example
     * // Count the number of Private_c15t_settings
     * const count = await prisma.private_c15t_settings.count({
     *   where: {
     *     // ... the filter for the Private_c15t_settings we want to count
     *   }
     * })
    **/
    count<T extends private_c15t_settingsCountArgs>(
      args?: Subset<T, private_c15t_settingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Private_c15t_settingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Private_c15t_settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Private_c15t_settingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Private_c15t_settingsAggregateArgs>(args: Subset<T, Private_c15t_settingsAggregateArgs>): Prisma.PrismaPromise<GetPrivate_c15t_settingsAggregateType<T>>

    /**
     * Group by Private_c15t_settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {private_c15t_settingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends private_c15t_settingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: private_c15t_settingsGroupByArgs['orderBy'] }
        : { orderBy?: private_c15t_settingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, private_c15t_settingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPrivate_c15t_settingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the private_c15t_settings model
   */
  readonly fields: private_c15t_settingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for private_c15t_settings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__private_c15t_settingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the private_c15t_settings model
   */
  interface private_c15t_settingsFieldRefs {
    readonly key: FieldRef<"private_c15t_settings", 'String'>
    readonly value: FieldRef<"private_c15t_settings", 'String'>
  }
    

  // Custom InputTypes
  /**
   * private_c15t_settings findUnique
   */
  export type private_c15t_settingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the private_c15t_settings
     */
    select?: private_c15t_settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the private_c15t_settings
     */
    omit?: private_c15t_settingsOmit<ExtArgs> | null
    /**
     * Filter, which private_c15t_settings to fetch.
     */
    where: private_c15t_settingsWhereUniqueInput
  }

  /**
   * private_c15t_settings findUniqueOrThrow
   */
  export type private_c15t_settingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the private_c15t_settings
     */
    select?: private_c15t_settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the private_c15t_settings
     */
    omit?: private_c15t_settingsOmit<ExtArgs> | null
    /**
     * Filter, which private_c15t_settings to fetch.
     */
    where: private_c15t_settingsWhereUniqueInput
  }

  /**
   * private_c15t_settings findFirst
   */
  export type private_c15t_settingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the private_c15t_settings
     */
    select?: private_c15t_settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the private_c15t_settings
     */
    omit?: private_c15t_settingsOmit<ExtArgs> | null
    /**
     * Filter, which private_c15t_settings to fetch.
     */
    where?: private_c15t_settingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of private_c15t_settings to fetch.
     */
    orderBy?: private_c15t_settingsOrderByWithRelationInput | private_c15t_settingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for private_c15t_settings.
     */
    cursor?: private_c15t_settingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` private_c15t_settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` private_c15t_settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of private_c15t_settings.
     */
    distinct?: Private_c15t_settingsScalarFieldEnum | Private_c15t_settingsScalarFieldEnum[]
  }

  /**
   * private_c15t_settings findFirstOrThrow
   */
  export type private_c15t_settingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the private_c15t_settings
     */
    select?: private_c15t_settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the private_c15t_settings
     */
    omit?: private_c15t_settingsOmit<ExtArgs> | null
    /**
     * Filter, which private_c15t_settings to fetch.
     */
    where?: private_c15t_settingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of private_c15t_settings to fetch.
     */
    orderBy?: private_c15t_settingsOrderByWithRelationInput | private_c15t_settingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for private_c15t_settings.
     */
    cursor?: private_c15t_settingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` private_c15t_settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` private_c15t_settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of private_c15t_settings.
     */
    distinct?: Private_c15t_settingsScalarFieldEnum | Private_c15t_settingsScalarFieldEnum[]
  }

  /**
   * private_c15t_settings findMany
   */
  export type private_c15t_settingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the private_c15t_settings
     */
    select?: private_c15t_settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the private_c15t_settings
     */
    omit?: private_c15t_settingsOmit<ExtArgs> | null
    /**
     * Filter, which private_c15t_settings to fetch.
     */
    where?: private_c15t_settingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of private_c15t_settings to fetch.
     */
    orderBy?: private_c15t_settingsOrderByWithRelationInput | private_c15t_settingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing private_c15t_settings.
     */
    cursor?: private_c15t_settingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` private_c15t_settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` private_c15t_settings.
     */
    skip?: number
    distinct?: Private_c15t_settingsScalarFieldEnum | Private_c15t_settingsScalarFieldEnum[]
  }

  /**
   * private_c15t_settings create
   */
  export type private_c15t_settingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the private_c15t_settings
     */
    select?: private_c15t_settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the private_c15t_settings
     */
    omit?: private_c15t_settingsOmit<ExtArgs> | null
    /**
     * The data needed to create a private_c15t_settings.
     */
    data: XOR<private_c15t_settingsCreateInput, private_c15t_settingsUncheckedCreateInput>
  }

  /**
   * private_c15t_settings createMany
   */
  export type private_c15t_settingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many private_c15t_settings.
     */
    data: private_c15t_settingsCreateManyInput | private_c15t_settingsCreateManyInput[]
  }

  /**
   * private_c15t_settings update
   */
  export type private_c15t_settingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the private_c15t_settings
     */
    select?: private_c15t_settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the private_c15t_settings
     */
    omit?: private_c15t_settingsOmit<ExtArgs> | null
    /**
     * The data needed to update a private_c15t_settings.
     */
    data: XOR<private_c15t_settingsUpdateInput, private_c15t_settingsUncheckedUpdateInput>
    /**
     * Choose, which private_c15t_settings to update.
     */
    where: private_c15t_settingsWhereUniqueInput
  }

  /**
   * private_c15t_settings updateMany
   */
  export type private_c15t_settingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update private_c15t_settings.
     */
    data: XOR<private_c15t_settingsUpdateManyMutationInput, private_c15t_settingsUncheckedUpdateManyInput>
    /**
     * Filter which private_c15t_settings to update
     */
    where?: private_c15t_settingsWhereInput
    /**
     * Limit how many private_c15t_settings to update.
     */
    limit?: number
  }

  /**
   * private_c15t_settings upsert
   */
  export type private_c15t_settingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the private_c15t_settings
     */
    select?: private_c15t_settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the private_c15t_settings
     */
    omit?: private_c15t_settingsOmit<ExtArgs> | null
    /**
     * The filter to search for the private_c15t_settings to update in case it exists.
     */
    where: private_c15t_settingsWhereUniqueInput
    /**
     * In case the private_c15t_settings found by the `where` argument doesn't exist, create a new private_c15t_settings with this data.
     */
    create: XOR<private_c15t_settingsCreateInput, private_c15t_settingsUncheckedCreateInput>
    /**
     * In case the private_c15t_settings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<private_c15t_settingsUpdateInput, private_c15t_settingsUncheckedUpdateInput>
  }

  /**
   * private_c15t_settings delete
   */
  export type private_c15t_settingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the private_c15t_settings
     */
    select?: private_c15t_settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the private_c15t_settings
     */
    omit?: private_c15t_settingsOmit<ExtArgs> | null
    /**
     * Filter which private_c15t_settings to delete.
     */
    where: private_c15t_settingsWhereUniqueInput
  }

  /**
   * private_c15t_settings deleteMany
   */
  export type private_c15t_settingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which private_c15t_settings to delete
     */
    where?: private_c15t_settingsWhereInput
    /**
     * Limit how many private_c15t_settings to delete.
     */
    limit?: number
  }

  /**
   * private_c15t_settings findRaw
   */
  export type private_c15t_settingsFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * private_c15t_settings aggregateRaw
   */
  export type private_c15t_settingsAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * private_c15t_settings without action
   */
  export type private_c15t_settingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the private_c15t_settings
     */
    select?: private_c15t_settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the private_c15t_settings
     */
    omit?: private_c15t_settingsOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    emailVerified: 'emailVerified',
    image: 'image',
    bio: 'bio',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    expiresAt: 'expiresAt',
    token: 'token',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    userId: 'userId'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const AccountScalarFieldEnum: {
    id: 'id',
    accountId: 'accountId',
    providerId: 'providerId',
    userId: 'userId',
    accessToken: 'accessToken',
    refreshToken: 'refreshToken',
    idToken: 'idToken',
    accessTokenExpiresAt: 'accessTokenExpiresAt',
    refreshTokenExpiresAt: 'refreshTokenExpiresAt',
    scope: 'scope',
    password: 'password',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const VerificationScalarFieldEnum: {
    id: 'id',
    identifier: 'identifier',
    value: 'value',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VerificationScalarFieldEnum = (typeof VerificationScalarFieldEnum)[keyof typeof VerificationScalarFieldEnum]


  export const BlogPostScalarFieldEnum: {
    id: 'id',
    title: 'title',
    slug: 'slug',
    excerpt: 'excerpt',
    content: 'content',
    image: 'image',
    published: 'published',
    authorId: 'authorId',
    categories: 'categories',
    tags: 'tags',
    views: 'views',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BlogPostScalarFieldEnum = (typeof BlogPostScalarFieldEnum)[keyof typeof BlogPostScalarFieldEnum]


  export const RoadmapItemScalarFieldEnum: {
    id: 'id',
    title: 'title',
    slug: 'slug',
    excerpt: 'excerpt',
    content: 'content',
    featuredImage: 'featuredImage',
    gallery: 'gallery',
    youtubeVideoId: 'youtubeVideoId',
    displayDate: 'displayDate',
    published: 'published',
    authorId: 'authorId',
    categories: 'categories',
    tags: 'tags',
    views: 'views',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RoadmapItemScalarFieldEnum = (typeof RoadmapItemScalarFieldEnum)[keyof typeof RoadmapItemScalarFieldEnum]


  export const GameAssetScalarFieldEnum: {
    id: 'id',
    title: 'title',
    image: 'image',
    description: 'description',
    blogLink: 'blogLink',
    difficulty: 'difficulty',
    pinned: 'pinned',
    category: 'category',
    type: 'type',
    published: 'published',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GameAssetScalarFieldEnum = (typeof GameAssetScalarFieldEnum)[keyof typeof GameAssetScalarFieldEnum]


  export const GameObjectiveScalarFieldEnum: {
    id: 'id',
    category: 'category',
    title: 'title',
    image: 'image',
    published: 'published',
    order: 'order',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GameObjectiveScalarFieldEnum = (typeof GameObjectiveScalarFieldEnum)[keyof typeof GameObjectiveScalarFieldEnum]


  export const TestimonialScalarFieldEnum: {
    id: 'id',
    quote: 'quote',
    name: 'name',
    designation: 'designation',
    image: 'image',
    order: 'order',
    published: 'published',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TestimonialScalarFieldEnum = (typeof TestimonialScalarFieldEnum)[keyof typeof TestimonialScalarFieldEnum]


  export const SiteSettingsScalarFieldEnum: {
    id: 'id',
    heroBackgroundImage: 'heroBackgroundImage',
    header: 'header',
    pages: 'pages',
    footer: 'footer',
    homeSections: 'homeSections',
    aboutHomeSection: 'aboutHomeSection',
    aboutPage: 'aboutPage',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SiteSettingsScalarFieldEnum = (typeof SiteSettingsScalarFieldEnum)[keyof typeof SiteSettingsScalarFieldEnum]


  export const InvestorScalarFieldEnum: {
    id: 'id',
    name: 'name',
    logo: 'logo',
    url: 'url',
    order: 'order',
    published: 'published',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InvestorScalarFieldEnum = (typeof InvestorScalarFieldEnum)[keyof typeof InvestorScalarFieldEnum]


  export const SubjectScalarFieldEnum: {
    id: 'id',
    isIdentified: 'isIdentified',
    externalId: 'externalId',
    identityProvider: 'identityProvider',
    lastIpAddress: 'lastIpAddress',
    subjectTimezone: 'subjectTimezone',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SubjectScalarFieldEnum = (typeof SubjectScalarFieldEnum)[keyof typeof SubjectScalarFieldEnum]


  export const DomainScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    allowedOrigins: 'allowedOrigins',
    isVerified: 'isVerified',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DomainScalarFieldEnum = (typeof DomainScalarFieldEnum)[keyof typeof DomainScalarFieldEnum]


  export const ConsentPolicyScalarFieldEnum: {
    id: 'id',
    version: 'version',
    type: 'type',
    name: 'name',
    effectiveDate: 'effectiveDate',
    expirationDate: 'expirationDate',
    content: 'content',
    contentHash: 'contentHash',
    isActive: 'isActive',
    createdAt: 'createdAt'
  };

  export type ConsentPolicyScalarFieldEnum = (typeof ConsentPolicyScalarFieldEnum)[keyof typeof ConsentPolicyScalarFieldEnum]


  export const ConsentPurposeScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    description: 'description',
    isEssential: 'isEssential',
    dataCategory: 'dataCategory',
    legalBasis: 'legalBasis',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ConsentPurposeScalarFieldEnum = (typeof ConsentPurposeScalarFieldEnum)[keyof typeof ConsentPurposeScalarFieldEnum]


  export const ConsentScalarFieldEnum: {
    id: 'id',
    subjectId: 'subjectId',
    domainId: 'domainId',
    policyId: 'policyId',
    purposeIds: 'purposeIds',
    metadata: 'metadata',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    status: 'status',
    withdrawalReason: 'withdrawalReason',
    givenAt: 'givenAt',
    validUntil: 'validUntil',
    isActive: 'isActive'
  };

  export type ConsentScalarFieldEnum = (typeof ConsentScalarFieldEnum)[keyof typeof ConsentScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    entityType: 'entityType',
    entityId: 'entityId',
    actionType: 'actionType',
    subjectId: 'subjectId',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    changes: 'changes',
    metadata: 'metadata',
    createdAt: 'createdAt',
    eventTimezone: 'eventTimezone'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const ConsentRecordScalarFieldEnum: {
    id: 'id',
    subjectId: 'subjectId',
    consentId: 'consentId',
    actionType: 'actionType',
    details: 'details',
    createdAt: 'createdAt'
  };

  export type ConsentRecordScalarFieldEnum = (typeof ConsentRecordScalarFieldEnum)[keyof typeof ConsentRecordScalarFieldEnum]


  export const Private_c15t_settingsScalarFieldEnum: {
    key: 'key',
    value: 'value'
  };

  export type Private_c15t_settingsScalarFieldEnum = (typeof Private_c15t_settingsScalarFieldEnum)[keyof typeof Private_c15t_settingsScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    emailVerified?: BoolFilter<"User"> | boolean
    image?: StringNullableFilter<"User"> | string | null
    bio?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    sessions?: SessionListRelationFilter
    accounts?: AccountListRelationFilter
    blogPosts?: BlogPostListRelationFilter
    roadmapItems?: RoadmapItemListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    bio?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sessions?: SessionOrderByRelationAggregateInput
    accounts?: AccountOrderByRelationAggregateInput
    blogPosts?: BlogPostOrderByRelationAggregateInput
    roadmapItems?: RoadmapItemOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    emailVerified?: BoolFilter<"User"> | boolean
    image?: StringNullableFilter<"User"> | string | null
    bio?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    sessions?: SessionListRelationFilter
    accounts?: AccountListRelationFilter
    blogPosts?: BlogPostListRelationFilter
    roadmapItems?: RoadmapItemListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    bio?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    emailVerified?: BoolWithAggregatesFilter<"User"> | boolean
    image?: StringNullableWithAggregatesFilter<"User"> | string | null
    bio?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    token?: StringFilter<"Session"> | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    userId?: StringFilter<"Session"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    expiresAt?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    userId?: StringFilter<"Session"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "token">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    expiresAt?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    userId?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    token?: StringWithAggregatesFilter<"Session"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    ipAddress?: StringNullableWithAggregatesFilter<"Session"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"Session"> | string | null
    userId?: StringWithAggregatesFilter<"Session"> | string
  }

  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    id?: StringFilter<"Account"> | string
    accountId?: StringFilter<"Account"> | string
    providerId?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    accessToken?: StringNullableFilter<"Account"> | string | null
    refreshToken?: StringNullableFilter<"Account"> | string | null
    idToken?: StringNullableFilter<"Account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    password?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    userId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    idToken?: SortOrder
    accessTokenExpiresAt?: SortOrder
    refreshTokenExpiresAt?: SortOrder
    scope?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    accountId?: StringFilter<"Account"> | string
    providerId?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    accessToken?: StringNullableFilter<"Account"> | string | null
    refreshToken?: StringNullableFilter<"Account"> | string | null
    idToken?: StringNullableFilter<"Account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    password?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    userId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    idToken?: SortOrder
    accessTokenExpiresAt?: SortOrder
    refreshTokenExpiresAt?: SortOrder
    scope?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AccountCountOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Account"> | string
    accountId?: StringWithAggregatesFilter<"Account"> | string
    providerId?: StringWithAggregatesFilter<"Account"> | string
    userId?: StringWithAggregatesFilter<"Account"> | string
    accessToken?: StringNullableWithAggregatesFilter<"Account"> | string | null
    refreshToken?: StringNullableWithAggregatesFilter<"Account"> | string | null
    idToken?: StringNullableWithAggregatesFilter<"Account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableWithAggregatesFilter<"Account"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableWithAggregatesFilter<"Account"> | Date | string | null
    scope?: StringNullableWithAggregatesFilter<"Account"> | string | null
    password?: StringNullableWithAggregatesFilter<"Account"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
  }

  export type VerificationWhereInput = {
    AND?: VerificationWhereInput | VerificationWhereInput[]
    OR?: VerificationWhereInput[]
    NOT?: VerificationWhereInput | VerificationWhereInput[]
    id?: StringFilter<"Verification"> | string
    identifier?: StringFilter<"Verification"> | string
    value?: StringFilter<"Verification"> | string
    expiresAt?: DateTimeFilter<"Verification"> | Date | string
    createdAt?: DateTimeFilter<"Verification"> | Date | string
    updatedAt?: DateTimeFilter<"Verification"> | Date | string
  }

  export type VerificationOrderByWithRelationInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VerificationWhereInput | VerificationWhereInput[]
    OR?: VerificationWhereInput[]
    NOT?: VerificationWhereInput | VerificationWhereInput[]
    identifier?: StringFilter<"Verification"> | string
    value?: StringFilter<"Verification"> | string
    expiresAt?: DateTimeFilter<"Verification"> | Date | string
    createdAt?: DateTimeFilter<"Verification"> | Date | string
    updatedAt?: DateTimeFilter<"Verification"> | Date | string
  }, "id">

  export type VerificationOrderByWithAggregationInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VerificationCountOrderByAggregateInput
    _max?: VerificationMaxOrderByAggregateInput
    _min?: VerificationMinOrderByAggregateInput
  }

  export type VerificationScalarWhereWithAggregatesInput = {
    AND?: VerificationScalarWhereWithAggregatesInput | VerificationScalarWhereWithAggregatesInput[]
    OR?: VerificationScalarWhereWithAggregatesInput[]
    NOT?: VerificationScalarWhereWithAggregatesInput | VerificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Verification"> | string
    identifier?: StringWithAggregatesFilter<"Verification"> | string
    value?: StringWithAggregatesFilter<"Verification"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"Verification"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Verification"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Verification"> | Date | string
  }

  export type BlogPostWhereInput = {
    AND?: BlogPostWhereInput | BlogPostWhereInput[]
    OR?: BlogPostWhereInput[]
    NOT?: BlogPostWhereInput | BlogPostWhereInput[]
    id?: StringFilter<"BlogPost"> | string
    title?: StringFilter<"BlogPost"> | string
    slug?: StringFilter<"BlogPost"> | string
    excerpt?: StringFilter<"BlogPost"> | string
    content?: StringFilter<"BlogPost"> | string
    image?: StringFilter<"BlogPost"> | string
    published?: BoolFilter<"BlogPost"> | boolean
    authorId?: StringFilter<"BlogPost"> | string
    categories?: StringNullableListFilter<"BlogPost">
    tags?: StringNullableListFilter<"BlogPost">
    views?: IntFilter<"BlogPost"> | number
    createdAt?: DateTimeFilter<"BlogPost"> | Date | string
    updatedAt?: DateTimeFilter<"BlogPost"> | Date | string
    author?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type BlogPostOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    excerpt?: SortOrder
    content?: SortOrder
    image?: SortOrder
    published?: SortOrder
    authorId?: SortOrder
    categories?: SortOrder
    tags?: SortOrder
    views?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    author?: UserOrderByWithRelationInput
  }

  export type BlogPostWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: BlogPostWhereInput | BlogPostWhereInput[]
    OR?: BlogPostWhereInput[]
    NOT?: BlogPostWhereInput | BlogPostWhereInput[]
    title?: StringFilter<"BlogPost"> | string
    excerpt?: StringFilter<"BlogPost"> | string
    content?: StringFilter<"BlogPost"> | string
    image?: StringFilter<"BlogPost"> | string
    published?: BoolFilter<"BlogPost"> | boolean
    authorId?: StringFilter<"BlogPost"> | string
    categories?: StringNullableListFilter<"BlogPost">
    tags?: StringNullableListFilter<"BlogPost">
    views?: IntFilter<"BlogPost"> | number
    createdAt?: DateTimeFilter<"BlogPost"> | Date | string
    updatedAt?: DateTimeFilter<"BlogPost"> | Date | string
    author?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "slug">

  export type BlogPostOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    excerpt?: SortOrder
    content?: SortOrder
    image?: SortOrder
    published?: SortOrder
    authorId?: SortOrder
    categories?: SortOrder
    tags?: SortOrder
    views?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BlogPostCountOrderByAggregateInput
    _avg?: BlogPostAvgOrderByAggregateInput
    _max?: BlogPostMaxOrderByAggregateInput
    _min?: BlogPostMinOrderByAggregateInput
    _sum?: BlogPostSumOrderByAggregateInput
  }

  export type BlogPostScalarWhereWithAggregatesInput = {
    AND?: BlogPostScalarWhereWithAggregatesInput | BlogPostScalarWhereWithAggregatesInput[]
    OR?: BlogPostScalarWhereWithAggregatesInput[]
    NOT?: BlogPostScalarWhereWithAggregatesInput | BlogPostScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BlogPost"> | string
    title?: StringWithAggregatesFilter<"BlogPost"> | string
    slug?: StringWithAggregatesFilter<"BlogPost"> | string
    excerpt?: StringWithAggregatesFilter<"BlogPost"> | string
    content?: StringWithAggregatesFilter<"BlogPost"> | string
    image?: StringWithAggregatesFilter<"BlogPost"> | string
    published?: BoolWithAggregatesFilter<"BlogPost"> | boolean
    authorId?: StringWithAggregatesFilter<"BlogPost"> | string
    categories?: StringNullableListFilter<"BlogPost">
    tags?: StringNullableListFilter<"BlogPost">
    views?: IntWithAggregatesFilter<"BlogPost"> | number
    createdAt?: DateTimeWithAggregatesFilter<"BlogPost"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BlogPost"> | Date | string
  }

  export type RoadmapItemWhereInput = {
    AND?: RoadmapItemWhereInput | RoadmapItemWhereInput[]
    OR?: RoadmapItemWhereInput[]
    NOT?: RoadmapItemWhereInput | RoadmapItemWhereInput[]
    id?: StringFilter<"RoadmapItem"> | string
    title?: StringFilter<"RoadmapItem"> | string
    slug?: StringFilter<"RoadmapItem"> | string
    excerpt?: StringFilter<"RoadmapItem"> | string
    content?: StringFilter<"RoadmapItem"> | string
    featuredImage?: StringFilter<"RoadmapItem"> | string
    gallery?: StringNullableListFilter<"RoadmapItem">
    youtubeVideoId?: StringNullableFilter<"RoadmapItem"> | string | null
    displayDate?: DateTimeNullableFilter<"RoadmapItem"> | Date | string | null
    published?: BoolFilter<"RoadmapItem"> | boolean
    authorId?: StringFilter<"RoadmapItem"> | string
    categories?: StringNullableListFilter<"RoadmapItem">
    tags?: StringNullableListFilter<"RoadmapItem">
    views?: IntFilter<"RoadmapItem"> | number
    createdAt?: DateTimeFilter<"RoadmapItem"> | Date | string
    updatedAt?: DateTimeFilter<"RoadmapItem"> | Date | string
    author?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type RoadmapItemOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    excerpt?: SortOrder
    content?: SortOrder
    featuredImage?: SortOrder
    gallery?: SortOrder
    youtubeVideoId?: SortOrder
    displayDate?: SortOrder
    published?: SortOrder
    authorId?: SortOrder
    categories?: SortOrder
    tags?: SortOrder
    views?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    author?: UserOrderByWithRelationInput
  }

  export type RoadmapItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: RoadmapItemWhereInput | RoadmapItemWhereInput[]
    OR?: RoadmapItemWhereInput[]
    NOT?: RoadmapItemWhereInput | RoadmapItemWhereInput[]
    title?: StringFilter<"RoadmapItem"> | string
    excerpt?: StringFilter<"RoadmapItem"> | string
    content?: StringFilter<"RoadmapItem"> | string
    featuredImage?: StringFilter<"RoadmapItem"> | string
    gallery?: StringNullableListFilter<"RoadmapItem">
    youtubeVideoId?: StringNullableFilter<"RoadmapItem"> | string | null
    displayDate?: DateTimeNullableFilter<"RoadmapItem"> | Date | string | null
    published?: BoolFilter<"RoadmapItem"> | boolean
    authorId?: StringFilter<"RoadmapItem"> | string
    categories?: StringNullableListFilter<"RoadmapItem">
    tags?: StringNullableListFilter<"RoadmapItem">
    views?: IntFilter<"RoadmapItem"> | number
    createdAt?: DateTimeFilter<"RoadmapItem"> | Date | string
    updatedAt?: DateTimeFilter<"RoadmapItem"> | Date | string
    author?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "slug">

  export type RoadmapItemOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    excerpt?: SortOrder
    content?: SortOrder
    featuredImage?: SortOrder
    gallery?: SortOrder
    youtubeVideoId?: SortOrder
    displayDate?: SortOrder
    published?: SortOrder
    authorId?: SortOrder
    categories?: SortOrder
    tags?: SortOrder
    views?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RoadmapItemCountOrderByAggregateInput
    _avg?: RoadmapItemAvgOrderByAggregateInput
    _max?: RoadmapItemMaxOrderByAggregateInput
    _min?: RoadmapItemMinOrderByAggregateInput
    _sum?: RoadmapItemSumOrderByAggregateInput
  }

  export type RoadmapItemScalarWhereWithAggregatesInput = {
    AND?: RoadmapItemScalarWhereWithAggregatesInput | RoadmapItemScalarWhereWithAggregatesInput[]
    OR?: RoadmapItemScalarWhereWithAggregatesInput[]
    NOT?: RoadmapItemScalarWhereWithAggregatesInput | RoadmapItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RoadmapItem"> | string
    title?: StringWithAggregatesFilter<"RoadmapItem"> | string
    slug?: StringWithAggregatesFilter<"RoadmapItem"> | string
    excerpt?: StringWithAggregatesFilter<"RoadmapItem"> | string
    content?: StringWithAggregatesFilter<"RoadmapItem"> | string
    featuredImage?: StringWithAggregatesFilter<"RoadmapItem"> | string
    gallery?: StringNullableListFilter<"RoadmapItem">
    youtubeVideoId?: StringNullableWithAggregatesFilter<"RoadmapItem"> | string | null
    displayDate?: DateTimeNullableWithAggregatesFilter<"RoadmapItem"> | Date | string | null
    published?: BoolWithAggregatesFilter<"RoadmapItem"> | boolean
    authorId?: StringWithAggregatesFilter<"RoadmapItem"> | string
    categories?: StringNullableListFilter<"RoadmapItem">
    tags?: StringNullableListFilter<"RoadmapItem">
    views?: IntWithAggregatesFilter<"RoadmapItem"> | number
    createdAt?: DateTimeWithAggregatesFilter<"RoadmapItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RoadmapItem"> | Date | string
  }

  export type GameAssetWhereInput = {
    AND?: GameAssetWhereInput | GameAssetWhereInput[]
    OR?: GameAssetWhereInput[]
    NOT?: GameAssetWhereInput | GameAssetWhereInput[]
    id?: StringFilter<"GameAsset"> | string
    title?: StringFilter<"GameAsset"> | string
    image?: StringFilter<"GameAsset"> | string
    description?: StringNullableFilter<"GameAsset"> | string | null
    blogLink?: StringNullableFilter<"GameAsset"> | string | null
    difficulty?: IntFilter<"GameAsset"> | number
    pinned?: BoolFilter<"GameAsset"> | boolean
    category?: StringFilter<"GameAsset"> | string
    type?: StringNullableFilter<"GameAsset"> | string | null
    published?: BoolFilter<"GameAsset"> | boolean
    createdAt?: DateTimeFilter<"GameAsset"> | Date | string
    updatedAt?: DateTimeFilter<"GameAsset"> | Date | string
  }

  export type GameAssetOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    image?: SortOrder
    description?: SortOrder
    blogLink?: SortOrder
    difficulty?: SortOrder
    pinned?: SortOrder
    category?: SortOrder
    type?: SortOrder
    published?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GameAssetWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: GameAssetWhereInput | GameAssetWhereInput[]
    OR?: GameAssetWhereInput[]
    NOT?: GameAssetWhereInput | GameAssetWhereInput[]
    title?: StringFilter<"GameAsset"> | string
    image?: StringFilter<"GameAsset"> | string
    description?: StringNullableFilter<"GameAsset"> | string | null
    blogLink?: StringNullableFilter<"GameAsset"> | string | null
    difficulty?: IntFilter<"GameAsset"> | number
    pinned?: BoolFilter<"GameAsset"> | boolean
    category?: StringFilter<"GameAsset"> | string
    type?: StringNullableFilter<"GameAsset"> | string | null
    published?: BoolFilter<"GameAsset"> | boolean
    createdAt?: DateTimeFilter<"GameAsset"> | Date | string
    updatedAt?: DateTimeFilter<"GameAsset"> | Date | string
  }, "id">

  export type GameAssetOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    image?: SortOrder
    description?: SortOrder
    blogLink?: SortOrder
    difficulty?: SortOrder
    pinned?: SortOrder
    category?: SortOrder
    type?: SortOrder
    published?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GameAssetCountOrderByAggregateInput
    _avg?: GameAssetAvgOrderByAggregateInput
    _max?: GameAssetMaxOrderByAggregateInput
    _min?: GameAssetMinOrderByAggregateInput
    _sum?: GameAssetSumOrderByAggregateInput
  }

  export type GameAssetScalarWhereWithAggregatesInput = {
    AND?: GameAssetScalarWhereWithAggregatesInput | GameAssetScalarWhereWithAggregatesInput[]
    OR?: GameAssetScalarWhereWithAggregatesInput[]
    NOT?: GameAssetScalarWhereWithAggregatesInput | GameAssetScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GameAsset"> | string
    title?: StringWithAggregatesFilter<"GameAsset"> | string
    image?: StringWithAggregatesFilter<"GameAsset"> | string
    description?: StringNullableWithAggregatesFilter<"GameAsset"> | string | null
    blogLink?: StringNullableWithAggregatesFilter<"GameAsset"> | string | null
    difficulty?: IntWithAggregatesFilter<"GameAsset"> | number
    pinned?: BoolWithAggregatesFilter<"GameAsset"> | boolean
    category?: StringWithAggregatesFilter<"GameAsset"> | string
    type?: StringNullableWithAggregatesFilter<"GameAsset"> | string | null
    published?: BoolWithAggregatesFilter<"GameAsset"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"GameAsset"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"GameAsset"> | Date | string
  }

  export type GameObjectiveWhereInput = {
    AND?: GameObjectiveWhereInput | GameObjectiveWhereInput[]
    OR?: GameObjectiveWhereInput[]
    NOT?: GameObjectiveWhereInput | GameObjectiveWhereInput[]
    id?: StringFilter<"GameObjective"> | string
    category?: StringFilter<"GameObjective"> | string
    title?: StringFilter<"GameObjective"> | string
    image?: StringFilter<"GameObjective"> | string
    published?: BoolFilter<"GameObjective"> | boolean
    order?: IntFilter<"GameObjective"> | number
    createdAt?: DateTimeFilter<"GameObjective"> | Date | string
    updatedAt?: DateTimeFilter<"GameObjective"> | Date | string
  }

  export type GameObjectiveOrderByWithRelationInput = {
    id?: SortOrder
    category?: SortOrder
    title?: SortOrder
    image?: SortOrder
    published?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GameObjectiveWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: GameObjectiveWhereInput | GameObjectiveWhereInput[]
    OR?: GameObjectiveWhereInput[]
    NOT?: GameObjectiveWhereInput | GameObjectiveWhereInput[]
    category?: StringFilter<"GameObjective"> | string
    title?: StringFilter<"GameObjective"> | string
    image?: StringFilter<"GameObjective"> | string
    published?: BoolFilter<"GameObjective"> | boolean
    order?: IntFilter<"GameObjective"> | number
    createdAt?: DateTimeFilter<"GameObjective"> | Date | string
    updatedAt?: DateTimeFilter<"GameObjective"> | Date | string
  }, "id">

  export type GameObjectiveOrderByWithAggregationInput = {
    id?: SortOrder
    category?: SortOrder
    title?: SortOrder
    image?: SortOrder
    published?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GameObjectiveCountOrderByAggregateInput
    _avg?: GameObjectiveAvgOrderByAggregateInput
    _max?: GameObjectiveMaxOrderByAggregateInput
    _min?: GameObjectiveMinOrderByAggregateInput
    _sum?: GameObjectiveSumOrderByAggregateInput
  }

  export type GameObjectiveScalarWhereWithAggregatesInput = {
    AND?: GameObjectiveScalarWhereWithAggregatesInput | GameObjectiveScalarWhereWithAggregatesInput[]
    OR?: GameObjectiveScalarWhereWithAggregatesInput[]
    NOT?: GameObjectiveScalarWhereWithAggregatesInput | GameObjectiveScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GameObjective"> | string
    category?: StringWithAggregatesFilter<"GameObjective"> | string
    title?: StringWithAggregatesFilter<"GameObjective"> | string
    image?: StringWithAggregatesFilter<"GameObjective"> | string
    published?: BoolWithAggregatesFilter<"GameObjective"> | boolean
    order?: IntWithAggregatesFilter<"GameObjective"> | number
    createdAt?: DateTimeWithAggregatesFilter<"GameObjective"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"GameObjective"> | Date | string
  }

  export type TestimonialWhereInput = {
    AND?: TestimonialWhereInput | TestimonialWhereInput[]
    OR?: TestimonialWhereInput[]
    NOT?: TestimonialWhereInput | TestimonialWhereInput[]
    id?: StringFilter<"Testimonial"> | string
    quote?: StringFilter<"Testimonial"> | string
    name?: StringFilter<"Testimonial"> | string
    designation?: StringFilter<"Testimonial"> | string
    image?: StringFilter<"Testimonial"> | string
    order?: IntFilter<"Testimonial"> | number
    published?: BoolFilter<"Testimonial"> | boolean
    createdAt?: DateTimeFilter<"Testimonial"> | Date | string
    updatedAt?: DateTimeFilter<"Testimonial"> | Date | string
  }

  export type TestimonialOrderByWithRelationInput = {
    id?: SortOrder
    quote?: SortOrder
    name?: SortOrder
    designation?: SortOrder
    image?: SortOrder
    order?: SortOrder
    published?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TestimonialWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TestimonialWhereInput | TestimonialWhereInput[]
    OR?: TestimonialWhereInput[]
    NOT?: TestimonialWhereInput | TestimonialWhereInput[]
    quote?: StringFilter<"Testimonial"> | string
    name?: StringFilter<"Testimonial"> | string
    designation?: StringFilter<"Testimonial"> | string
    image?: StringFilter<"Testimonial"> | string
    order?: IntFilter<"Testimonial"> | number
    published?: BoolFilter<"Testimonial"> | boolean
    createdAt?: DateTimeFilter<"Testimonial"> | Date | string
    updatedAt?: DateTimeFilter<"Testimonial"> | Date | string
  }, "id">

  export type TestimonialOrderByWithAggregationInput = {
    id?: SortOrder
    quote?: SortOrder
    name?: SortOrder
    designation?: SortOrder
    image?: SortOrder
    order?: SortOrder
    published?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TestimonialCountOrderByAggregateInput
    _avg?: TestimonialAvgOrderByAggregateInput
    _max?: TestimonialMaxOrderByAggregateInput
    _min?: TestimonialMinOrderByAggregateInput
    _sum?: TestimonialSumOrderByAggregateInput
  }

  export type TestimonialScalarWhereWithAggregatesInput = {
    AND?: TestimonialScalarWhereWithAggregatesInput | TestimonialScalarWhereWithAggregatesInput[]
    OR?: TestimonialScalarWhereWithAggregatesInput[]
    NOT?: TestimonialScalarWhereWithAggregatesInput | TestimonialScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Testimonial"> | string
    quote?: StringWithAggregatesFilter<"Testimonial"> | string
    name?: StringWithAggregatesFilter<"Testimonial"> | string
    designation?: StringWithAggregatesFilter<"Testimonial"> | string
    image?: StringWithAggregatesFilter<"Testimonial"> | string
    order?: IntWithAggregatesFilter<"Testimonial"> | number
    published?: BoolWithAggregatesFilter<"Testimonial"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Testimonial"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Testimonial"> | Date | string
  }

  export type SiteSettingsWhereInput = {
    AND?: SiteSettingsWhereInput | SiteSettingsWhereInput[]
    OR?: SiteSettingsWhereInput[]
    NOT?: SiteSettingsWhereInput | SiteSettingsWhereInput[]
    id?: StringFilter<"SiteSettings"> | string
    heroBackgroundImage?: StringFilter<"SiteSettings"> | string
    header?: JsonFilter<"SiteSettings">
    pages?: JsonFilter<"SiteSettings">
    footer?: JsonFilter<"SiteSettings">
    homeSections?: JsonFilter<"SiteSettings">
    aboutHomeSection?: JsonNullableFilter<"SiteSettings">
    aboutPage?: JsonNullableFilter<"SiteSettings">
    createdAt?: DateTimeFilter<"SiteSettings"> | Date | string
    updatedAt?: DateTimeFilter<"SiteSettings"> | Date | string
  }

  export type SiteSettingsOrderByWithRelationInput = {
    id?: SortOrder
    heroBackgroundImage?: SortOrder
    header?: SortOrder
    pages?: SortOrder
    footer?: SortOrder
    homeSections?: SortOrder
    aboutHomeSection?: SortOrder
    aboutPage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SiteSettingsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SiteSettingsWhereInput | SiteSettingsWhereInput[]
    OR?: SiteSettingsWhereInput[]
    NOT?: SiteSettingsWhereInput | SiteSettingsWhereInput[]
    heroBackgroundImage?: StringFilter<"SiteSettings"> | string
    header?: JsonFilter<"SiteSettings">
    pages?: JsonFilter<"SiteSettings">
    footer?: JsonFilter<"SiteSettings">
    homeSections?: JsonFilter<"SiteSettings">
    aboutHomeSection?: JsonNullableFilter<"SiteSettings">
    aboutPage?: JsonNullableFilter<"SiteSettings">
    createdAt?: DateTimeFilter<"SiteSettings"> | Date | string
    updatedAt?: DateTimeFilter<"SiteSettings"> | Date | string
  }, "id">

  export type SiteSettingsOrderByWithAggregationInput = {
    id?: SortOrder
    heroBackgroundImage?: SortOrder
    header?: SortOrder
    pages?: SortOrder
    footer?: SortOrder
    homeSections?: SortOrder
    aboutHomeSection?: SortOrder
    aboutPage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SiteSettingsCountOrderByAggregateInput
    _max?: SiteSettingsMaxOrderByAggregateInput
    _min?: SiteSettingsMinOrderByAggregateInput
  }

  export type SiteSettingsScalarWhereWithAggregatesInput = {
    AND?: SiteSettingsScalarWhereWithAggregatesInput | SiteSettingsScalarWhereWithAggregatesInput[]
    OR?: SiteSettingsScalarWhereWithAggregatesInput[]
    NOT?: SiteSettingsScalarWhereWithAggregatesInput | SiteSettingsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SiteSettings"> | string
    heroBackgroundImage?: StringWithAggregatesFilter<"SiteSettings"> | string
    header?: JsonWithAggregatesFilter<"SiteSettings">
    pages?: JsonWithAggregatesFilter<"SiteSettings">
    footer?: JsonWithAggregatesFilter<"SiteSettings">
    homeSections?: JsonWithAggregatesFilter<"SiteSettings">
    aboutHomeSection?: JsonNullableWithAggregatesFilter<"SiteSettings">
    aboutPage?: JsonNullableWithAggregatesFilter<"SiteSettings">
    createdAt?: DateTimeWithAggregatesFilter<"SiteSettings"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SiteSettings"> | Date | string
  }

  export type InvestorWhereInput = {
    AND?: InvestorWhereInput | InvestorWhereInput[]
    OR?: InvestorWhereInput[]
    NOT?: InvestorWhereInput | InvestorWhereInput[]
    id?: StringFilter<"Investor"> | string
    name?: StringNullableFilter<"Investor"> | string | null
    logo?: StringFilter<"Investor"> | string
    url?: StringNullableFilter<"Investor"> | string | null
    order?: IntFilter<"Investor"> | number
    published?: BoolFilter<"Investor"> | boolean
    createdAt?: DateTimeFilter<"Investor"> | Date | string
    updatedAt?: DateTimeFilter<"Investor"> | Date | string
  }

  export type InvestorOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    logo?: SortOrder
    url?: SortOrder
    order?: SortOrder
    published?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvestorWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InvestorWhereInput | InvestorWhereInput[]
    OR?: InvestorWhereInput[]
    NOT?: InvestorWhereInput | InvestorWhereInput[]
    name?: StringNullableFilter<"Investor"> | string | null
    logo?: StringFilter<"Investor"> | string
    url?: StringNullableFilter<"Investor"> | string | null
    order?: IntFilter<"Investor"> | number
    published?: BoolFilter<"Investor"> | boolean
    createdAt?: DateTimeFilter<"Investor"> | Date | string
    updatedAt?: DateTimeFilter<"Investor"> | Date | string
  }, "id">

  export type InvestorOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    logo?: SortOrder
    url?: SortOrder
    order?: SortOrder
    published?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InvestorCountOrderByAggregateInput
    _avg?: InvestorAvgOrderByAggregateInput
    _max?: InvestorMaxOrderByAggregateInput
    _min?: InvestorMinOrderByAggregateInput
    _sum?: InvestorSumOrderByAggregateInput
  }

  export type InvestorScalarWhereWithAggregatesInput = {
    AND?: InvestorScalarWhereWithAggregatesInput | InvestorScalarWhereWithAggregatesInput[]
    OR?: InvestorScalarWhereWithAggregatesInput[]
    NOT?: InvestorScalarWhereWithAggregatesInput | InvestorScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Investor"> | string
    name?: StringNullableWithAggregatesFilter<"Investor"> | string | null
    logo?: StringWithAggregatesFilter<"Investor"> | string
    url?: StringNullableWithAggregatesFilter<"Investor"> | string | null
    order?: IntWithAggregatesFilter<"Investor"> | number
    published?: BoolWithAggregatesFilter<"Investor"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Investor"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Investor"> | Date | string
  }

  export type subjectWhereInput = {
    AND?: subjectWhereInput | subjectWhereInput[]
    OR?: subjectWhereInput[]
    NOT?: subjectWhereInput | subjectWhereInput[]
    id?: StringFilter<"subject"> | string
    isIdentified?: BoolFilter<"subject"> | boolean
    externalId?: StringNullableFilter<"subject"> | string | null
    identityProvider?: StringNullableFilter<"subject"> | string | null
    lastIpAddress?: StringNullableFilter<"subject"> | string | null
    subjectTimezone?: StringNullableFilter<"subject"> | string | null
    createdAt?: DateTimeFilter<"subject"> | Date | string
    updatedAt?: DateTimeFilter<"subject"> | Date | string
    consents?: ConsentListRelationFilter
    consentRecords?: ConsentRecordListRelationFilter
    auditLogs?: AuditLogListRelationFilter
  }

  export type subjectOrderByWithRelationInput = {
    id?: SortOrder
    isIdentified?: SortOrder
    externalId?: SortOrder
    identityProvider?: SortOrder
    lastIpAddress?: SortOrder
    subjectTimezone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    consents?: consentOrderByRelationAggregateInput
    consentRecords?: consentRecordOrderByRelationAggregateInput
    auditLogs?: auditLogOrderByRelationAggregateInput
  }

  export type subjectWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: subjectWhereInput | subjectWhereInput[]
    OR?: subjectWhereInput[]
    NOT?: subjectWhereInput | subjectWhereInput[]
    isIdentified?: BoolFilter<"subject"> | boolean
    externalId?: StringNullableFilter<"subject"> | string | null
    identityProvider?: StringNullableFilter<"subject"> | string | null
    lastIpAddress?: StringNullableFilter<"subject"> | string | null
    subjectTimezone?: StringNullableFilter<"subject"> | string | null
    createdAt?: DateTimeFilter<"subject"> | Date | string
    updatedAt?: DateTimeFilter<"subject"> | Date | string
    consents?: ConsentListRelationFilter
    consentRecords?: ConsentRecordListRelationFilter
    auditLogs?: AuditLogListRelationFilter
  }, "id">

  export type subjectOrderByWithAggregationInput = {
    id?: SortOrder
    isIdentified?: SortOrder
    externalId?: SortOrder
    identityProvider?: SortOrder
    lastIpAddress?: SortOrder
    subjectTimezone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: subjectCountOrderByAggregateInput
    _max?: subjectMaxOrderByAggregateInput
    _min?: subjectMinOrderByAggregateInput
  }

  export type subjectScalarWhereWithAggregatesInput = {
    AND?: subjectScalarWhereWithAggregatesInput | subjectScalarWhereWithAggregatesInput[]
    OR?: subjectScalarWhereWithAggregatesInput[]
    NOT?: subjectScalarWhereWithAggregatesInput | subjectScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"subject"> | string
    isIdentified?: BoolWithAggregatesFilter<"subject"> | boolean
    externalId?: StringNullableWithAggregatesFilter<"subject"> | string | null
    identityProvider?: StringNullableWithAggregatesFilter<"subject"> | string | null
    lastIpAddress?: StringNullableWithAggregatesFilter<"subject"> | string | null
    subjectTimezone?: StringNullableWithAggregatesFilter<"subject"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"subject"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"subject"> | Date | string
  }

  export type domainWhereInput = {
    AND?: domainWhereInput | domainWhereInput[]
    OR?: domainWhereInput[]
    NOT?: domainWhereInput | domainWhereInput[]
    id?: StringFilter<"domain"> | string
    name?: StringFilter<"domain"> | string
    description?: StringNullableFilter<"domain"> | string | null
    allowedOrigins?: JsonNullableFilter<"domain">
    isVerified?: BoolFilter<"domain"> | boolean
    isActive?: BoolFilter<"domain"> | boolean
    createdAt?: DateTimeFilter<"domain"> | Date | string
    updatedAt?: DateTimeFilter<"domain"> | Date | string
    consents?: ConsentListRelationFilter
  }

  export type domainOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    allowedOrigins?: SortOrder
    isVerified?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    consents?: consentOrderByRelationAggregateInput
  }

  export type domainWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: domainWhereInput | domainWhereInput[]
    OR?: domainWhereInput[]
    NOT?: domainWhereInput | domainWhereInput[]
    description?: StringNullableFilter<"domain"> | string | null
    allowedOrigins?: JsonNullableFilter<"domain">
    isVerified?: BoolFilter<"domain"> | boolean
    isActive?: BoolFilter<"domain"> | boolean
    createdAt?: DateTimeFilter<"domain"> | Date | string
    updatedAt?: DateTimeFilter<"domain"> | Date | string
    consents?: ConsentListRelationFilter
  }, "id" | "name">

  export type domainOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    allowedOrigins?: SortOrder
    isVerified?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: domainCountOrderByAggregateInput
    _max?: domainMaxOrderByAggregateInput
    _min?: domainMinOrderByAggregateInput
  }

  export type domainScalarWhereWithAggregatesInput = {
    AND?: domainScalarWhereWithAggregatesInput | domainScalarWhereWithAggregatesInput[]
    OR?: domainScalarWhereWithAggregatesInput[]
    NOT?: domainScalarWhereWithAggregatesInput | domainScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"domain"> | string
    name?: StringWithAggregatesFilter<"domain"> | string
    description?: StringNullableWithAggregatesFilter<"domain"> | string | null
    allowedOrigins?: JsonNullableWithAggregatesFilter<"domain">
    isVerified?: BoolWithAggregatesFilter<"domain"> | boolean
    isActive?: BoolWithAggregatesFilter<"domain"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"domain"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"domain"> | Date | string
  }

  export type consentPolicyWhereInput = {
    AND?: consentPolicyWhereInput | consentPolicyWhereInput[]
    OR?: consentPolicyWhereInput[]
    NOT?: consentPolicyWhereInput | consentPolicyWhereInput[]
    id?: StringFilter<"consentPolicy"> | string
    version?: StringFilter<"consentPolicy"> | string
    type?: StringFilter<"consentPolicy"> | string
    name?: StringFilter<"consentPolicy"> | string
    effectiveDate?: DateTimeFilter<"consentPolicy"> | Date | string
    expirationDate?: DateTimeNullableFilter<"consentPolicy"> | Date | string | null
    content?: StringFilter<"consentPolicy"> | string
    contentHash?: StringFilter<"consentPolicy"> | string
    isActive?: BoolFilter<"consentPolicy"> | boolean
    createdAt?: DateTimeFilter<"consentPolicy"> | Date | string
    consents?: ConsentListRelationFilter
  }

  export type consentPolicyOrderByWithRelationInput = {
    id?: SortOrder
    version?: SortOrder
    type?: SortOrder
    name?: SortOrder
    effectiveDate?: SortOrder
    expirationDate?: SortOrder
    content?: SortOrder
    contentHash?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    consents?: consentOrderByRelationAggregateInput
  }

  export type consentPolicyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: consentPolicyWhereInput | consentPolicyWhereInput[]
    OR?: consentPolicyWhereInput[]
    NOT?: consentPolicyWhereInput | consentPolicyWhereInput[]
    version?: StringFilter<"consentPolicy"> | string
    type?: StringFilter<"consentPolicy"> | string
    name?: StringFilter<"consentPolicy"> | string
    effectiveDate?: DateTimeFilter<"consentPolicy"> | Date | string
    expirationDate?: DateTimeNullableFilter<"consentPolicy"> | Date | string | null
    content?: StringFilter<"consentPolicy"> | string
    contentHash?: StringFilter<"consentPolicy"> | string
    isActive?: BoolFilter<"consentPolicy"> | boolean
    createdAt?: DateTimeFilter<"consentPolicy"> | Date | string
    consents?: ConsentListRelationFilter
  }, "id">

  export type consentPolicyOrderByWithAggregationInput = {
    id?: SortOrder
    version?: SortOrder
    type?: SortOrder
    name?: SortOrder
    effectiveDate?: SortOrder
    expirationDate?: SortOrder
    content?: SortOrder
    contentHash?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    _count?: consentPolicyCountOrderByAggregateInput
    _max?: consentPolicyMaxOrderByAggregateInput
    _min?: consentPolicyMinOrderByAggregateInput
  }

  export type consentPolicyScalarWhereWithAggregatesInput = {
    AND?: consentPolicyScalarWhereWithAggregatesInput | consentPolicyScalarWhereWithAggregatesInput[]
    OR?: consentPolicyScalarWhereWithAggregatesInput[]
    NOT?: consentPolicyScalarWhereWithAggregatesInput | consentPolicyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"consentPolicy"> | string
    version?: StringWithAggregatesFilter<"consentPolicy"> | string
    type?: StringWithAggregatesFilter<"consentPolicy"> | string
    name?: StringWithAggregatesFilter<"consentPolicy"> | string
    effectiveDate?: DateTimeWithAggregatesFilter<"consentPolicy"> | Date | string
    expirationDate?: DateTimeNullableWithAggregatesFilter<"consentPolicy"> | Date | string | null
    content?: StringWithAggregatesFilter<"consentPolicy"> | string
    contentHash?: StringWithAggregatesFilter<"consentPolicy"> | string
    isActive?: BoolWithAggregatesFilter<"consentPolicy"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"consentPolicy"> | Date | string
  }

  export type consentPurposeWhereInput = {
    AND?: consentPurposeWhereInput | consentPurposeWhereInput[]
    OR?: consentPurposeWhereInput[]
    NOT?: consentPurposeWhereInput | consentPurposeWhereInput[]
    id?: StringFilter<"consentPurpose"> | string
    code?: StringFilter<"consentPurpose"> | string
    name?: StringFilter<"consentPurpose"> | string
    description?: StringFilter<"consentPurpose"> | string
    isEssential?: BoolFilter<"consentPurpose"> | boolean
    dataCategory?: StringNullableFilter<"consentPurpose"> | string | null
    legalBasis?: StringNullableFilter<"consentPurpose"> | string | null
    isActive?: BoolFilter<"consentPurpose"> | boolean
    createdAt?: DateTimeFilter<"consentPurpose"> | Date | string
    updatedAt?: DateTimeFilter<"consentPurpose"> | Date | string
  }

  export type consentPurposeOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isEssential?: SortOrder
    dataCategory?: SortOrder
    legalBasis?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type consentPurposeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: consentPurposeWhereInput | consentPurposeWhereInput[]
    OR?: consentPurposeWhereInput[]
    NOT?: consentPurposeWhereInput | consentPurposeWhereInput[]
    code?: StringFilter<"consentPurpose"> | string
    name?: StringFilter<"consentPurpose"> | string
    description?: StringFilter<"consentPurpose"> | string
    isEssential?: BoolFilter<"consentPurpose"> | boolean
    dataCategory?: StringNullableFilter<"consentPurpose"> | string | null
    legalBasis?: StringNullableFilter<"consentPurpose"> | string | null
    isActive?: BoolFilter<"consentPurpose"> | boolean
    createdAt?: DateTimeFilter<"consentPurpose"> | Date | string
    updatedAt?: DateTimeFilter<"consentPurpose"> | Date | string
  }, "id">

  export type consentPurposeOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isEssential?: SortOrder
    dataCategory?: SortOrder
    legalBasis?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: consentPurposeCountOrderByAggregateInput
    _max?: consentPurposeMaxOrderByAggregateInput
    _min?: consentPurposeMinOrderByAggregateInput
  }

  export type consentPurposeScalarWhereWithAggregatesInput = {
    AND?: consentPurposeScalarWhereWithAggregatesInput | consentPurposeScalarWhereWithAggregatesInput[]
    OR?: consentPurposeScalarWhereWithAggregatesInput[]
    NOT?: consentPurposeScalarWhereWithAggregatesInput | consentPurposeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"consentPurpose"> | string
    code?: StringWithAggregatesFilter<"consentPurpose"> | string
    name?: StringWithAggregatesFilter<"consentPurpose"> | string
    description?: StringWithAggregatesFilter<"consentPurpose"> | string
    isEssential?: BoolWithAggregatesFilter<"consentPurpose"> | boolean
    dataCategory?: StringNullableWithAggregatesFilter<"consentPurpose"> | string | null
    legalBasis?: StringNullableWithAggregatesFilter<"consentPurpose"> | string | null
    isActive?: BoolWithAggregatesFilter<"consentPurpose"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"consentPurpose"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"consentPurpose"> | Date | string
  }

  export type consentWhereInput = {
    AND?: consentWhereInput | consentWhereInput[]
    OR?: consentWhereInput[]
    NOT?: consentWhereInput | consentWhereInput[]
    id?: StringFilter<"consent"> | string
    subjectId?: StringFilter<"consent"> | string
    domainId?: StringFilter<"consent"> | string
    policyId?: StringNullableFilter<"consent"> | string | null
    purposeIds?: JsonFilter<"consent">
    metadata?: JsonNullableFilter<"consent">
    ipAddress?: StringNullableFilter<"consent"> | string | null
    userAgent?: StringNullableFilter<"consent"> | string | null
    status?: StringFilter<"consent"> | string
    withdrawalReason?: StringNullableFilter<"consent"> | string | null
    givenAt?: DateTimeFilter<"consent"> | Date | string
    validUntil?: DateTimeNullableFilter<"consent"> | Date | string | null
    isActive?: BoolFilter<"consent"> | boolean
    subject?: XOR<SubjectScalarRelationFilter, subjectWhereInput>
    domain?: XOR<DomainScalarRelationFilter, domainWhereInput>
    policy?: XOR<ConsentPolicyNullableScalarRelationFilter, consentPolicyWhereInput> | null
    consentRecords?: ConsentRecordListRelationFilter
  }

  export type consentOrderByWithRelationInput = {
    id?: SortOrder
    subjectId?: SortOrder
    domainId?: SortOrder
    policyId?: SortOrder
    purposeIds?: SortOrder
    metadata?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    status?: SortOrder
    withdrawalReason?: SortOrder
    givenAt?: SortOrder
    validUntil?: SortOrder
    isActive?: SortOrder
    subject?: subjectOrderByWithRelationInput
    domain?: domainOrderByWithRelationInput
    policy?: consentPolicyOrderByWithRelationInput
    consentRecords?: consentRecordOrderByRelationAggregateInput
  }

  export type consentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: consentWhereInput | consentWhereInput[]
    OR?: consentWhereInput[]
    NOT?: consentWhereInput | consentWhereInput[]
    subjectId?: StringFilter<"consent"> | string
    domainId?: StringFilter<"consent"> | string
    policyId?: StringNullableFilter<"consent"> | string | null
    purposeIds?: JsonFilter<"consent">
    metadata?: JsonNullableFilter<"consent">
    ipAddress?: StringNullableFilter<"consent"> | string | null
    userAgent?: StringNullableFilter<"consent"> | string | null
    status?: StringFilter<"consent"> | string
    withdrawalReason?: StringNullableFilter<"consent"> | string | null
    givenAt?: DateTimeFilter<"consent"> | Date | string
    validUntil?: DateTimeNullableFilter<"consent"> | Date | string | null
    isActive?: BoolFilter<"consent"> | boolean
    subject?: XOR<SubjectScalarRelationFilter, subjectWhereInput>
    domain?: XOR<DomainScalarRelationFilter, domainWhereInput>
    policy?: XOR<ConsentPolicyNullableScalarRelationFilter, consentPolicyWhereInput> | null
    consentRecords?: ConsentRecordListRelationFilter
  }, "id">

  export type consentOrderByWithAggregationInput = {
    id?: SortOrder
    subjectId?: SortOrder
    domainId?: SortOrder
    policyId?: SortOrder
    purposeIds?: SortOrder
    metadata?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    status?: SortOrder
    withdrawalReason?: SortOrder
    givenAt?: SortOrder
    validUntil?: SortOrder
    isActive?: SortOrder
    _count?: consentCountOrderByAggregateInput
    _max?: consentMaxOrderByAggregateInput
    _min?: consentMinOrderByAggregateInput
  }

  export type consentScalarWhereWithAggregatesInput = {
    AND?: consentScalarWhereWithAggregatesInput | consentScalarWhereWithAggregatesInput[]
    OR?: consentScalarWhereWithAggregatesInput[]
    NOT?: consentScalarWhereWithAggregatesInput | consentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"consent"> | string
    subjectId?: StringWithAggregatesFilter<"consent"> | string
    domainId?: StringWithAggregatesFilter<"consent"> | string
    policyId?: StringNullableWithAggregatesFilter<"consent"> | string | null
    purposeIds?: JsonWithAggregatesFilter<"consent">
    metadata?: JsonNullableWithAggregatesFilter<"consent">
    ipAddress?: StringNullableWithAggregatesFilter<"consent"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"consent"> | string | null
    status?: StringWithAggregatesFilter<"consent"> | string
    withdrawalReason?: StringNullableWithAggregatesFilter<"consent"> | string | null
    givenAt?: DateTimeWithAggregatesFilter<"consent"> | Date | string
    validUntil?: DateTimeNullableWithAggregatesFilter<"consent"> | Date | string | null
    isActive?: BoolWithAggregatesFilter<"consent"> | boolean
  }

  export type auditLogWhereInput = {
    AND?: auditLogWhereInput | auditLogWhereInput[]
    OR?: auditLogWhereInput[]
    NOT?: auditLogWhereInput | auditLogWhereInput[]
    id?: StringFilter<"auditLog"> | string
    entityType?: StringFilter<"auditLog"> | string
    entityId?: StringFilter<"auditLog"> | string
    actionType?: StringFilter<"auditLog"> | string
    subjectId?: StringNullableFilter<"auditLog"> | string | null
    ipAddress?: StringNullableFilter<"auditLog"> | string | null
    userAgent?: StringNullableFilter<"auditLog"> | string | null
    changes?: JsonNullableFilter<"auditLog">
    metadata?: JsonNullableFilter<"auditLog">
    createdAt?: DateTimeFilter<"auditLog"> | Date | string
    eventTimezone?: StringFilter<"auditLog"> | string
    subject?: XOR<SubjectNullableScalarRelationFilter, subjectWhereInput> | null
  }

  export type auditLogOrderByWithRelationInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    actionType?: SortOrder
    subjectId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    changes?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    eventTimezone?: SortOrder
    subject?: subjectOrderByWithRelationInput
  }

  export type auditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: auditLogWhereInput | auditLogWhereInput[]
    OR?: auditLogWhereInput[]
    NOT?: auditLogWhereInput | auditLogWhereInput[]
    entityType?: StringFilter<"auditLog"> | string
    entityId?: StringFilter<"auditLog"> | string
    actionType?: StringFilter<"auditLog"> | string
    subjectId?: StringNullableFilter<"auditLog"> | string | null
    ipAddress?: StringNullableFilter<"auditLog"> | string | null
    userAgent?: StringNullableFilter<"auditLog"> | string | null
    changes?: JsonNullableFilter<"auditLog">
    metadata?: JsonNullableFilter<"auditLog">
    createdAt?: DateTimeFilter<"auditLog"> | Date | string
    eventTimezone?: StringFilter<"auditLog"> | string
    subject?: XOR<SubjectNullableScalarRelationFilter, subjectWhereInput> | null
  }, "id">

  export type auditLogOrderByWithAggregationInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    actionType?: SortOrder
    subjectId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    changes?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    eventTimezone?: SortOrder
    _count?: auditLogCountOrderByAggregateInput
    _max?: auditLogMaxOrderByAggregateInput
    _min?: auditLogMinOrderByAggregateInput
  }

  export type auditLogScalarWhereWithAggregatesInput = {
    AND?: auditLogScalarWhereWithAggregatesInput | auditLogScalarWhereWithAggregatesInput[]
    OR?: auditLogScalarWhereWithAggregatesInput[]
    NOT?: auditLogScalarWhereWithAggregatesInput | auditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"auditLog"> | string
    entityType?: StringWithAggregatesFilter<"auditLog"> | string
    entityId?: StringWithAggregatesFilter<"auditLog"> | string
    actionType?: StringWithAggregatesFilter<"auditLog"> | string
    subjectId?: StringNullableWithAggregatesFilter<"auditLog"> | string | null
    ipAddress?: StringNullableWithAggregatesFilter<"auditLog"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"auditLog"> | string | null
    changes?: JsonNullableWithAggregatesFilter<"auditLog">
    metadata?: JsonNullableWithAggregatesFilter<"auditLog">
    createdAt?: DateTimeWithAggregatesFilter<"auditLog"> | Date | string
    eventTimezone?: StringWithAggregatesFilter<"auditLog"> | string
  }

  export type consentRecordWhereInput = {
    AND?: consentRecordWhereInput | consentRecordWhereInput[]
    OR?: consentRecordWhereInput[]
    NOT?: consentRecordWhereInput | consentRecordWhereInput[]
    id?: StringFilter<"consentRecord"> | string
    subjectId?: StringFilter<"consentRecord"> | string
    consentId?: StringNullableFilter<"consentRecord"> | string | null
    actionType?: StringFilter<"consentRecord"> | string
    details?: JsonNullableFilter<"consentRecord">
    createdAt?: DateTimeFilter<"consentRecord"> | Date | string
    subject?: XOR<SubjectScalarRelationFilter, subjectWhereInput>
    consent?: XOR<ConsentNullableScalarRelationFilter, consentWhereInput> | null
  }

  export type consentRecordOrderByWithRelationInput = {
    id?: SortOrder
    subjectId?: SortOrder
    consentId?: SortOrder
    actionType?: SortOrder
    details?: SortOrder
    createdAt?: SortOrder
    subject?: subjectOrderByWithRelationInput
    consent?: consentOrderByWithRelationInput
  }

  export type consentRecordWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: consentRecordWhereInput | consentRecordWhereInput[]
    OR?: consentRecordWhereInput[]
    NOT?: consentRecordWhereInput | consentRecordWhereInput[]
    subjectId?: StringFilter<"consentRecord"> | string
    consentId?: StringNullableFilter<"consentRecord"> | string | null
    actionType?: StringFilter<"consentRecord"> | string
    details?: JsonNullableFilter<"consentRecord">
    createdAt?: DateTimeFilter<"consentRecord"> | Date | string
    subject?: XOR<SubjectScalarRelationFilter, subjectWhereInput>
    consent?: XOR<ConsentNullableScalarRelationFilter, consentWhereInput> | null
  }, "id">

  export type consentRecordOrderByWithAggregationInput = {
    id?: SortOrder
    subjectId?: SortOrder
    consentId?: SortOrder
    actionType?: SortOrder
    details?: SortOrder
    createdAt?: SortOrder
    _count?: consentRecordCountOrderByAggregateInput
    _max?: consentRecordMaxOrderByAggregateInput
    _min?: consentRecordMinOrderByAggregateInput
  }

  export type consentRecordScalarWhereWithAggregatesInput = {
    AND?: consentRecordScalarWhereWithAggregatesInput | consentRecordScalarWhereWithAggregatesInput[]
    OR?: consentRecordScalarWhereWithAggregatesInput[]
    NOT?: consentRecordScalarWhereWithAggregatesInput | consentRecordScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"consentRecord"> | string
    subjectId?: StringWithAggregatesFilter<"consentRecord"> | string
    consentId?: StringNullableWithAggregatesFilter<"consentRecord"> | string | null
    actionType?: StringWithAggregatesFilter<"consentRecord"> | string
    details?: JsonNullableWithAggregatesFilter<"consentRecord">
    createdAt?: DateTimeWithAggregatesFilter<"consentRecord"> | Date | string
  }

  export type private_c15t_settingsWhereInput = {
    AND?: private_c15t_settingsWhereInput | private_c15t_settingsWhereInput[]
    OR?: private_c15t_settingsWhereInput[]
    NOT?: private_c15t_settingsWhereInput | private_c15t_settingsWhereInput[]
    key?: StringFilter<"private_c15t_settings"> | string
    value?: StringFilter<"private_c15t_settings"> | string
  }

  export type private_c15t_settingsOrderByWithRelationInput = {
    key?: SortOrder
    value?: SortOrder
  }

  export type private_c15t_settingsWhereUniqueInput = Prisma.AtLeast<{
    key?: string
    AND?: private_c15t_settingsWhereInput | private_c15t_settingsWhereInput[]
    OR?: private_c15t_settingsWhereInput[]
    NOT?: private_c15t_settingsWhereInput | private_c15t_settingsWhereInput[]
    value?: StringFilter<"private_c15t_settings"> | string
  }, "key">

  export type private_c15t_settingsOrderByWithAggregationInput = {
    key?: SortOrder
    value?: SortOrder
    _count?: private_c15t_settingsCountOrderByAggregateInput
    _max?: private_c15t_settingsMaxOrderByAggregateInput
    _min?: private_c15t_settingsMinOrderByAggregateInput
  }

  export type private_c15t_settingsScalarWhereWithAggregatesInput = {
    AND?: private_c15t_settingsScalarWhereWithAggregatesInput | private_c15t_settingsScalarWhereWithAggregatesInput[]
    OR?: private_c15t_settingsScalarWhereWithAggregatesInput[]
    NOT?: private_c15t_settingsScalarWhereWithAggregatesInput | private_c15t_settingsScalarWhereWithAggregatesInput[]
    key?: StringWithAggregatesFilter<"private_c15t_settings"> | string
    value?: StringWithAggregatesFilter<"private_c15t_settings"> | string
  }

  export type UserCreateInput = {
    id: string
    name: string
    email: string
    emailVerified?: boolean
    image?: string | null
    bio?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostCreateNestedManyWithoutAuthorInput
    roadmapItems?: RoadmapItemCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateInput = {
    id: string
    name: string
    email: string
    emailVerified?: boolean
    image?: string | null
    bio?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutAuthorInput
    roadmapItems?: RoadmapItemUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUpdateManyWithoutAuthorNestedInput
    roadmapItems?: RoadmapItemUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutAuthorNestedInput
    roadmapItems?: RoadmapItemUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type UserCreateManyInput = {
    id: string
    name: string
    email: string
    emailVerified?: boolean
    image?: string | null
    bio?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateInput = {
    id: string
    expiresAt: Date | string
    token: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id: string
    expiresAt: Date | string
    token: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    userId: string
  }

  export type SessionUpdateInput = {
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type SessionCreateManyInput = {
    id: string
    expiresAt: Date | string
    token: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    userId: string
  }

  export type SessionUpdateManyMutationInput = {
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionUncheckedUpdateManyInput = {
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type AccountCreateInput = {
    id: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAccountsInput
  }

  export type AccountUncheckedCreateInput = {
    id: string
    accountId: string
    providerId: string
    userId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUpdateInput = {
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAccountsNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateManyInput = {
    id: string
    accountId: string
    providerId: string
    userId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUpdateManyMutationInput = {
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateManyInput = {
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationCreateInput = {
    id: string
    identifier: string
    value: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerificationUncheckedCreateInput = {
    id: string
    identifier: string
    value: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerificationUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationUncheckedUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationCreateManyInput = {
    id: string
    identifier: string
    value: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerificationUpdateManyMutationInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationUncheckedUpdateManyInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogPostCreateInput = {
    id?: string
    title: string
    slug: string
    excerpt: string
    content: string
    image: string
    published?: boolean
    categories?: BlogPostCreatecategoriesInput | string[]
    tags?: BlogPostCreatetagsInput | string[]
    views?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutBlogPostsInput
  }

  export type BlogPostUncheckedCreateInput = {
    id?: string
    title: string
    slug: string
    excerpt: string
    content: string
    image: string
    published?: boolean
    authorId: string
    categories?: BlogPostCreatecategoriesInput | string[]
    tags?: BlogPostCreatetagsInput | string[]
    views?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BlogPostUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    excerpt?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    categories?: BlogPostUpdatecategoriesInput | string[]
    tags?: BlogPostUpdatetagsInput | string[]
    views?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutBlogPostsNestedInput
  }

  export type BlogPostUncheckedUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    excerpt?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    authorId?: StringFieldUpdateOperationsInput | string
    categories?: BlogPostUpdatecategoriesInput | string[]
    tags?: BlogPostUpdatetagsInput | string[]
    views?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogPostCreateManyInput = {
    id?: string
    title: string
    slug: string
    excerpt: string
    content: string
    image: string
    published?: boolean
    authorId: string
    categories?: BlogPostCreatecategoriesInput | string[]
    tags?: BlogPostCreatetagsInput | string[]
    views?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BlogPostUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    excerpt?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    categories?: BlogPostUpdatecategoriesInput | string[]
    tags?: BlogPostUpdatetagsInput | string[]
    views?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogPostUncheckedUpdateManyInput = {
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    excerpt?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    authorId?: StringFieldUpdateOperationsInput | string
    categories?: BlogPostUpdatecategoriesInput | string[]
    tags?: BlogPostUpdatetagsInput | string[]
    views?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoadmapItemCreateInput = {
    id?: string
    title: string
    slug: string
    excerpt: string
    content: string
    featuredImage: string
    gallery?: RoadmapItemCreategalleryInput | string[]
    youtubeVideoId?: string | null
    displayDate?: Date | string | null
    published?: boolean
    categories?: RoadmapItemCreatecategoriesInput | string[]
    tags?: RoadmapItemCreatetagsInput | string[]
    views?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutRoadmapItemsInput
  }

  export type RoadmapItemUncheckedCreateInput = {
    id?: string
    title: string
    slug: string
    excerpt: string
    content: string
    featuredImage: string
    gallery?: RoadmapItemCreategalleryInput | string[]
    youtubeVideoId?: string | null
    displayDate?: Date | string | null
    published?: boolean
    authorId: string
    categories?: RoadmapItemCreatecategoriesInput | string[]
    tags?: RoadmapItemCreatetagsInput | string[]
    views?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoadmapItemUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    excerpt?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    featuredImage?: StringFieldUpdateOperationsInput | string
    gallery?: RoadmapItemUpdategalleryInput | string[]
    youtubeVideoId?: NullableStringFieldUpdateOperationsInput | string | null
    displayDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    categories?: RoadmapItemUpdatecategoriesInput | string[]
    tags?: RoadmapItemUpdatetagsInput | string[]
    views?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutRoadmapItemsNestedInput
  }

  export type RoadmapItemUncheckedUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    excerpt?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    featuredImage?: StringFieldUpdateOperationsInput | string
    gallery?: RoadmapItemUpdategalleryInput | string[]
    youtubeVideoId?: NullableStringFieldUpdateOperationsInput | string | null
    displayDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    authorId?: StringFieldUpdateOperationsInput | string
    categories?: RoadmapItemUpdatecategoriesInput | string[]
    tags?: RoadmapItemUpdatetagsInput | string[]
    views?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoadmapItemCreateManyInput = {
    id?: string
    title: string
    slug: string
    excerpt: string
    content: string
    featuredImage: string
    gallery?: RoadmapItemCreategalleryInput | string[]
    youtubeVideoId?: string | null
    displayDate?: Date | string | null
    published?: boolean
    authorId: string
    categories?: RoadmapItemCreatecategoriesInput | string[]
    tags?: RoadmapItemCreatetagsInput | string[]
    views?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoadmapItemUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    excerpt?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    featuredImage?: StringFieldUpdateOperationsInput | string
    gallery?: RoadmapItemUpdategalleryInput | string[]
    youtubeVideoId?: NullableStringFieldUpdateOperationsInput | string | null
    displayDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    categories?: RoadmapItemUpdatecategoriesInput | string[]
    tags?: RoadmapItemUpdatetagsInput | string[]
    views?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoadmapItemUncheckedUpdateManyInput = {
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    excerpt?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    featuredImage?: StringFieldUpdateOperationsInput | string
    gallery?: RoadmapItemUpdategalleryInput | string[]
    youtubeVideoId?: NullableStringFieldUpdateOperationsInput | string | null
    displayDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    authorId?: StringFieldUpdateOperationsInput | string
    categories?: RoadmapItemUpdatecategoriesInput | string[]
    tags?: RoadmapItemUpdatetagsInput | string[]
    views?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameAssetCreateInput = {
    id?: string
    title: string
    image: string
    description?: string | null
    blogLink?: string | null
    difficulty?: number
    pinned?: boolean
    category: string
    type?: string | null
    published?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GameAssetUncheckedCreateInput = {
    id?: string
    title: string
    image: string
    description?: string | null
    blogLink?: string | null
    difficulty?: number
    pinned?: boolean
    category: string
    type?: string | null
    published?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GameAssetUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    blogLink?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: IntFieldUpdateOperationsInput | number
    pinned?: BoolFieldUpdateOperationsInput | boolean
    category?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameAssetUncheckedUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    blogLink?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: IntFieldUpdateOperationsInput | number
    pinned?: BoolFieldUpdateOperationsInput | boolean
    category?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameAssetCreateManyInput = {
    id?: string
    title: string
    image: string
    description?: string | null
    blogLink?: string | null
    difficulty?: number
    pinned?: boolean
    category: string
    type?: string | null
    published?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GameAssetUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    blogLink?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: IntFieldUpdateOperationsInput | number
    pinned?: BoolFieldUpdateOperationsInput | boolean
    category?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameAssetUncheckedUpdateManyInput = {
    title?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    blogLink?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: IntFieldUpdateOperationsInput | number
    pinned?: BoolFieldUpdateOperationsInput | boolean
    category?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameObjectiveCreateInput = {
    id?: string
    category: string
    title: string
    image: string
    published?: boolean
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GameObjectiveUncheckedCreateInput = {
    id?: string
    category: string
    title: string
    image: string
    published?: boolean
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GameObjectiveUpdateInput = {
    category?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameObjectiveUncheckedUpdateInput = {
    category?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameObjectiveCreateManyInput = {
    id?: string
    category: string
    title: string
    image: string
    published?: boolean
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GameObjectiveUpdateManyMutationInput = {
    category?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameObjectiveUncheckedUpdateManyInput = {
    category?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestimonialCreateInput = {
    id?: string
    quote: string
    name: string
    designation: string
    image: string
    order?: number
    published?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TestimonialUncheckedCreateInput = {
    id?: string
    quote: string
    name: string
    designation: string
    image: string
    order?: number
    published?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TestimonialUpdateInput = {
    quote?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestimonialUncheckedUpdateInput = {
    quote?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestimonialCreateManyInput = {
    id?: string
    quote: string
    name: string
    designation: string
    image: string
    order?: number
    published?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TestimonialUpdateManyMutationInput = {
    quote?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestimonialUncheckedUpdateManyInput = {
    quote?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SiteSettingsCreateInput = {
    id: string
    heroBackgroundImage?: string
    header: InputJsonValue
    pages: InputJsonValue
    footer: InputJsonValue
    homeSections: InputJsonValue
    aboutHomeSection?: InputJsonValue | null
    aboutPage?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SiteSettingsUncheckedCreateInput = {
    id: string
    heroBackgroundImage?: string
    header: InputJsonValue
    pages: InputJsonValue
    footer: InputJsonValue
    homeSections: InputJsonValue
    aboutHomeSection?: InputJsonValue | null
    aboutPage?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SiteSettingsUpdateInput = {
    heroBackgroundImage?: StringFieldUpdateOperationsInput | string
    header?: InputJsonValue | InputJsonValue
    pages?: InputJsonValue | InputJsonValue
    footer?: InputJsonValue | InputJsonValue
    homeSections?: InputJsonValue | InputJsonValue
    aboutHomeSection?: InputJsonValue | InputJsonValue | null
    aboutPage?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SiteSettingsUncheckedUpdateInput = {
    heroBackgroundImage?: StringFieldUpdateOperationsInput | string
    header?: InputJsonValue | InputJsonValue
    pages?: InputJsonValue | InputJsonValue
    footer?: InputJsonValue | InputJsonValue
    homeSections?: InputJsonValue | InputJsonValue
    aboutHomeSection?: InputJsonValue | InputJsonValue | null
    aboutPage?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SiteSettingsCreateManyInput = {
    id: string
    heroBackgroundImage?: string
    header: InputJsonValue
    pages: InputJsonValue
    footer: InputJsonValue
    homeSections: InputJsonValue
    aboutHomeSection?: InputJsonValue | null
    aboutPage?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SiteSettingsUpdateManyMutationInput = {
    heroBackgroundImage?: StringFieldUpdateOperationsInput | string
    header?: InputJsonValue | InputJsonValue
    pages?: InputJsonValue | InputJsonValue
    footer?: InputJsonValue | InputJsonValue
    homeSections?: InputJsonValue | InputJsonValue
    aboutHomeSection?: InputJsonValue | InputJsonValue | null
    aboutPage?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SiteSettingsUncheckedUpdateManyInput = {
    heroBackgroundImage?: StringFieldUpdateOperationsInput | string
    header?: InputJsonValue | InputJsonValue
    pages?: InputJsonValue | InputJsonValue
    footer?: InputJsonValue | InputJsonValue
    homeSections?: InputJsonValue | InputJsonValue
    aboutHomeSection?: InputJsonValue | InputJsonValue | null
    aboutPage?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvestorCreateInput = {
    id?: string
    name?: string | null
    logo: string
    url?: string | null
    order?: number
    published?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvestorUncheckedCreateInput = {
    id?: string
    name?: string | null
    logo: string
    url?: string | null
    order?: number
    published?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvestorUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvestorUncheckedUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvestorCreateManyInput = {
    id?: string
    name?: string | null
    logo: string
    url?: string | null
    order?: number
    published?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvestorUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvestorUncheckedUpdateManyInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type subjectCreateInput = {
    id: string
    isIdentified: boolean
    externalId?: string | null
    identityProvider?: string | null
    lastIpAddress?: string | null
    subjectTimezone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    consents?: consentCreateNestedManyWithoutSubjectInput
    consentRecords?: consentRecordCreateNestedManyWithoutSubjectInput
    auditLogs?: auditLogCreateNestedManyWithoutSubjectInput
  }

  export type subjectUncheckedCreateInput = {
    id: string
    isIdentified: boolean
    externalId?: string | null
    identityProvider?: string | null
    lastIpAddress?: string | null
    subjectTimezone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    consents?: consentUncheckedCreateNestedManyWithoutSubjectInput
    consentRecords?: consentRecordUncheckedCreateNestedManyWithoutSubjectInput
    auditLogs?: auditLogUncheckedCreateNestedManyWithoutSubjectInput
  }

  export type subjectUpdateInput = {
    isIdentified?: BoolFieldUpdateOperationsInput | boolean
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    identityProvider?: NullableStringFieldUpdateOperationsInput | string | null
    lastIpAddress?: NullableStringFieldUpdateOperationsInput | string | null
    subjectTimezone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consents?: consentUpdateManyWithoutSubjectNestedInput
    consentRecords?: consentRecordUpdateManyWithoutSubjectNestedInput
    auditLogs?: auditLogUpdateManyWithoutSubjectNestedInput
  }

  export type subjectUncheckedUpdateInput = {
    isIdentified?: BoolFieldUpdateOperationsInput | boolean
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    identityProvider?: NullableStringFieldUpdateOperationsInput | string | null
    lastIpAddress?: NullableStringFieldUpdateOperationsInput | string | null
    subjectTimezone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consents?: consentUncheckedUpdateManyWithoutSubjectNestedInput
    consentRecords?: consentRecordUncheckedUpdateManyWithoutSubjectNestedInput
    auditLogs?: auditLogUncheckedUpdateManyWithoutSubjectNestedInput
  }

  export type subjectCreateManyInput = {
    id: string
    isIdentified: boolean
    externalId?: string | null
    identityProvider?: string | null
    lastIpAddress?: string | null
    subjectTimezone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type subjectUpdateManyMutationInput = {
    isIdentified?: BoolFieldUpdateOperationsInput | boolean
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    identityProvider?: NullableStringFieldUpdateOperationsInput | string | null
    lastIpAddress?: NullableStringFieldUpdateOperationsInput | string | null
    subjectTimezone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type subjectUncheckedUpdateManyInput = {
    isIdentified?: BoolFieldUpdateOperationsInput | boolean
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    identityProvider?: NullableStringFieldUpdateOperationsInput | string | null
    lastIpAddress?: NullableStringFieldUpdateOperationsInput | string | null
    subjectTimezone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type domainCreateInput = {
    id: string
    name: string
    description?: string | null
    allowedOrigins?: InputJsonValue | null
    isVerified: boolean
    isActive: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    consents?: consentCreateNestedManyWithoutDomainInput
  }

  export type domainUncheckedCreateInput = {
    id: string
    name: string
    description?: string | null
    allowedOrigins?: InputJsonValue | null
    isVerified: boolean
    isActive: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    consents?: consentUncheckedCreateNestedManyWithoutDomainInput
  }

  export type domainUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    allowedOrigins?: InputJsonValue | InputJsonValue | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consents?: consentUpdateManyWithoutDomainNestedInput
  }

  export type domainUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    allowedOrigins?: InputJsonValue | InputJsonValue | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consents?: consentUncheckedUpdateManyWithoutDomainNestedInput
  }

  export type domainCreateManyInput = {
    id: string
    name: string
    description?: string | null
    allowedOrigins?: InputJsonValue | null
    isVerified: boolean
    isActive: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type domainUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    allowedOrigins?: InputJsonValue | InputJsonValue | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type domainUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    allowedOrigins?: InputJsonValue | InputJsonValue | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type consentPolicyCreateInput = {
    id: string
    version: string
    type: string
    name: string
    effectiveDate: Date | string
    expirationDate?: Date | string | null
    content: string
    contentHash: string
    isActive: boolean
    createdAt?: Date | string
    consents?: consentCreateNestedManyWithoutPolicyInput
  }

  export type consentPolicyUncheckedCreateInput = {
    id: string
    version: string
    type: string
    name: string
    effectiveDate: Date | string
    expirationDate?: Date | string | null
    content: string
    contentHash: string
    isActive: boolean
    createdAt?: Date | string
    consents?: consentUncheckedCreateNestedManyWithoutPolicyInput
  }

  export type consentPolicyUpdateInput = {
    version?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    content?: StringFieldUpdateOperationsInput | string
    contentHash?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consents?: consentUpdateManyWithoutPolicyNestedInput
  }

  export type consentPolicyUncheckedUpdateInput = {
    version?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    content?: StringFieldUpdateOperationsInput | string
    contentHash?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consents?: consentUncheckedUpdateManyWithoutPolicyNestedInput
  }

  export type consentPolicyCreateManyInput = {
    id: string
    version: string
    type: string
    name: string
    effectiveDate: Date | string
    expirationDate?: Date | string | null
    content: string
    contentHash: string
    isActive: boolean
    createdAt?: Date | string
  }

  export type consentPolicyUpdateManyMutationInput = {
    version?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    content?: StringFieldUpdateOperationsInput | string
    contentHash?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type consentPolicyUncheckedUpdateManyInput = {
    version?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    content?: StringFieldUpdateOperationsInput | string
    contentHash?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type consentPurposeCreateInput = {
    id: string
    code: string
    name: string
    description: string
    isEssential: boolean
    dataCategory?: string | null
    legalBasis?: string | null
    isActive: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type consentPurposeUncheckedCreateInput = {
    id: string
    code: string
    name: string
    description: string
    isEssential: boolean
    dataCategory?: string | null
    legalBasis?: string | null
    isActive: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type consentPurposeUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isEssential?: BoolFieldUpdateOperationsInput | boolean
    dataCategory?: NullableStringFieldUpdateOperationsInput | string | null
    legalBasis?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type consentPurposeUncheckedUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isEssential?: BoolFieldUpdateOperationsInput | boolean
    dataCategory?: NullableStringFieldUpdateOperationsInput | string | null
    legalBasis?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type consentPurposeCreateManyInput = {
    id: string
    code: string
    name: string
    description: string
    isEssential: boolean
    dataCategory?: string | null
    legalBasis?: string | null
    isActive: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type consentPurposeUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isEssential?: BoolFieldUpdateOperationsInput | boolean
    dataCategory?: NullableStringFieldUpdateOperationsInput | string | null
    legalBasis?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type consentPurposeUncheckedUpdateManyInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isEssential?: BoolFieldUpdateOperationsInput | boolean
    dataCategory?: NullableStringFieldUpdateOperationsInput | string | null
    legalBasis?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type consentCreateInput = {
    id: string
    purposeIds: InputJsonValue
    metadata?: InputJsonValue | null
    ipAddress?: string | null
    userAgent?: string | null
    status: string
    withdrawalReason?: string | null
    givenAt?: Date | string
    validUntil?: Date | string | null
    isActive: boolean
    subject: subjectCreateNestedOneWithoutConsentsInput
    domain: domainCreateNestedOneWithoutConsentsInput
    policy?: consentPolicyCreateNestedOneWithoutConsentsInput
    consentRecords?: consentRecordCreateNestedManyWithoutConsentInput
  }

  export type consentUncheckedCreateInput = {
    id: string
    subjectId: string
    domainId: string
    policyId?: string | null
    purposeIds: InputJsonValue
    metadata?: InputJsonValue | null
    ipAddress?: string | null
    userAgent?: string | null
    status: string
    withdrawalReason?: string | null
    givenAt?: Date | string
    validUntil?: Date | string | null
    isActive: boolean
    consentRecords?: consentRecordUncheckedCreateNestedManyWithoutConsentInput
  }

  export type consentUpdateInput = {
    purposeIds?: InputJsonValue | InputJsonValue
    metadata?: InputJsonValue | InputJsonValue | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    withdrawalReason?: NullableStringFieldUpdateOperationsInput | string | null
    givenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subject?: subjectUpdateOneRequiredWithoutConsentsNestedInput
    domain?: domainUpdateOneRequiredWithoutConsentsNestedInput
    policy?: consentPolicyUpdateOneWithoutConsentsNestedInput
    consentRecords?: consentRecordUpdateManyWithoutConsentNestedInput
  }

  export type consentUncheckedUpdateInput = {
    subjectId?: StringFieldUpdateOperationsInput | string
    domainId?: StringFieldUpdateOperationsInput | string
    policyId?: NullableStringFieldUpdateOperationsInput | string | null
    purposeIds?: InputJsonValue | InputJsonValue
    metadata?: InputJsonValue | InputJsonValue | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    withdrawalReason?: NullableStringFieldUpdateOperationsInput | string | null
    givenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    consentRecords?: consentRecordUncheckedUpdateManyWithoutConsentNestedInput
  }

  export type consentCreateManyInput = {
    id: string
    subjectId: string
    domainId: string
    policyId?: string | null
    purposeIds: InputJsonValue
    metadata?: InputJsonValue | null
    ipAddress?: string | null
    userAgent?: string | null
    status: string
    withdrawalReason?: string | null
    givenAt?: Date | string
    validUntil?: Date | string | null
    isActive: boolean
  }

  export type consentUpdateManyMutationInput = {
    purposeIds?: InputJsonValue | InputJsonValue
    metadata?: InputJsonValue | InputJsonValue | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    withdrawalReason?: NullableStringFieldUpdateOperationsInput | string | null
    givenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type consentUncheckedUpdateManyInput = {
    subjectId?: StringFieldUpdateOperationsInput | string
    domainId?: StringFieldUpdateOperationsInput | string
    policyId?: NullableStringFieldUpdateOperationsInput | string | null
    purposeIds?: InputJsonValue | InputJsonValue
    metadata?: InputJsonValue | InputJsonValue | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    withdrawalReason?: NullableStringFieldUpdateOperationsInput | string | null
    givenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type auditLogCreateInput = {
    id: string
    entityType: string
    entityId: string
    actionType: string
    ipAddress?: string | null
    userAgent?: string | null
    changes?: InputJsonValue | null
    metadata?: InputJsonValue | null
    createdAt?: Date | string
    eventTimezone: string
    subject?: subjectCreateNestedOneWithoutAuditLogsInput
  }

  export type auditLogUncheckedCreateInput = {
    id: string
    entityType: string
    entityId: string
    actionType: string
    subjectId?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    changes?: InputJsonValue | null
    metadata?: InputJsonValue | null
    createdAt?: Date | string
    eventTimezone: string
  }

  export type auditLogUpdateInput = {
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    actionType?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    changes?: InputJsonValue | InputJsonValue | null
    metadata?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eventTimezone?: StringFieldUpdateOperationsInput | string
    subject?: subjectUpdateOneWithoutAuditLogsNestedInput
  }

  export type auditLogUncheckedUpdateInput = {
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    actionType?: StringFieldUpdateOperationsInput | string
    subjectId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    changes?: InputJsonValue | InputJsonValue | null
    metadata?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eventTimezone?: StringFieldUpdateOperationsInput | string
  }

  export type auditLogCreateManyInput = {
    id: string
    entityType: string
    entityId: string
    actionType: string
    subjectId?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    changes?: InputJsonValue | null
    metadata?: InputJsonValue | null
    createdAt?: Date | string
    eventTimezone: string
  }

  export type auditLogUpdateManyMutationInput = {
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    actionType?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    changes?: InputJsonValue | InputJsonValue | null
    metadata?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eventTimezone?: StringFieldUpdateOperationsInput | string
  }

  export type auditLogUncheckedUpdateManyInput = {
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    actionType?: StringFieldUpdateOperationsInput | string
    subjectId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    changes?: InputJsonValue | InputJsonValue | null
    metadata?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eventTimezone?: StringFieldUpdateOperationsInput | string
  }

  export type consentRecordCreateInput = {
    id: string
    actionType: string
    details?: InputJsonValue | null
    createdAt?: Date | string
    subject: subjectCreateNestedOneWithoutConsentRecordsInput
    consent?: consentCreateNestedOneWithoutConsentRecordsInput
  }

  export type consentRecordUncheckedCreateInput = {
    id: string
    subjectId: string
    consentId?: string | null
    actionType: string
    details?: InputJsonValue | null
    createdAt?: Date | string
  }

  export type consentRecordUpdateInput = {
    actionType?: StringFieldUpdateOperationsInput | string
    details?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subject?: subjectUpdateOneRequiredWithoutConsentRecordsNestedInput
    consent?: consentUpdateOneWithoutConsentRecordsNestedInput
  }

  export type consentRecordUncheckedUpdateInput = {
    subjectId?: StringFieldUpdateOperationsInput | string
    consentId?: NullableStringFieldUpdateOperationsInput | string | null
    actionType?: StringFieldUpdateOperationsInput | string
    details?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type consentRecordCreateManyInput = {
    id: string
    subjectId: string
    consentId?: string | null
    actionType: string
    details?: InputJsonValue | null
    createdAt?: Date | string
  }

  export type consentRecordUpdateManyMutationInput = {
    actionType?: StringFieldUpdateOperationsInput | string
    details?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type consentRecordUncheckedUpdateManyInput = {
    subjectId?: StringFieldUpdateOperationsInput | string
    consentId?: NullableStringFieldUpdateOperationsInput | string | null
    actionType?: StringFieldUpdateOperationsInput | string
    details?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type private_c15t_settingsCreateInput = {
    key: string
    value?: string
  }

  export type private_c15t_settingsUncheckedCreateInput = {
    key: string
    value?: string
  }

  export type private_c15t_settingsUpdateInput = {
    value?: StringFieldUpdateOperationsInput | string
  }

  export type private_c15t_settingsUncheckedUpdateInput = {
    value?: StringFieldUpdateOperationsInput | string
  }

  export type private_c15t_settingsCreateManyInput = {
    key: string
    value?: string
  }

  export type private_c15t_settingsUpdateManyMutationInput = {
    value?: StringFieldUpdateOperationsInput | string
  }

  export type private_c15t_settingsUncheckedUpdateManyInput = {
    value?: StringFieldUpdateOperationsInput | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
    isSet?: boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type BlogPostListRelationFilter = {
    every?: BlogPostWhereInput
    some?: BlogPostWhereInput
    none?: BlogPostWhereInput
  }

  export type RoadmapItemListRelationFilter = {
    every?: RoadmapItemWhereInput
    some?: RoadmapItemWhereInput
    none?: RoadmapItemWhereInput
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BlogPostOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoadmapItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    bio?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    bio?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    bio?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    expiresAt?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    userId?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    expiresAt?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    userId?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    expiresAt?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    userId?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
    isSet?: boolean
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    userId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    idToken?: SortOrder
    accessTokenExpiresAt?: SortOrder
    refreshTokenExpiresAt?: SortOrder
    scope?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    userId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    idToken?: SortOrder
    accessTokenExpiresAt?: SortOrder
    refreshTokenExpiresAt?: SortOrder
    scope?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    userId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    idToken?: SortOrder
    accessTokenExpiresAt?: SortOrder
    refreshTokenExpiresAt?: SortOrder
    scope?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type VerificationCountOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerificationMaxOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerificationMinOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type BlogPostCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    excerpt?: SortOrder
    content?: SortOrder
    image?: SortOrder
    published?: SortOrder
    authorId?: SortOrder
    categories?: SortOrder
    tags?: SortOrder
    views?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BlogPostAvgOrderByAggregateInput = {
    views?: SortOrder
  }

  export type BlogPostMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    excerpt?: SortOrder
    content?: SortOrder
    image?: SortOrder
    published?: SortOrder
    authorId?: SortOrder
    views?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BlogPostMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    excerpt?: SortOrder
    content?: SortOrder
    image?: SortOrder
    published?: SortOrder
    authorId?: SortOrder
    views?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BlogPostSumOrderByAggregateInput = {
    views?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type RoadmapItemCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    excerpt?: SortOrder
    content?: SortOrder
    featuredImage?: SortOrder
    gallery?: SortOrder
    youtubeVideoId?: SortOrder
    displayDate?: SortOrder
    published?: SortOrder
    authorId?: SortOrder
    categories?: SortOrder
    tags?: SortOrder
    views?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoadmapItemAvgOrderByAggregateInput = {
    views?: SortOrder
  }

  export type RoadmapItemMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    excerpt?: SortOrder
    content?: SortOrder
    featuredImage?: SortOrder
    youtubeVideoId?: SortOrder
    displayDate?: SortOrder
    published?: SortOrder
    authorId?: SortOrder
    views?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoadmapItemMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    excerpt?: SortOrder
    content?: SortOrder
    featuredImage?: SortOrder
    youtubeVideoId?: SortOrder
    displayDate?: SortOrder
    published?: SortOrder
    authorId?: SortOrder
    views?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoadmapItemSumOrderByAggregateInput = {
    views?: SortOrder
  }

  export type GameAssetCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    image?: SortOrder
    description?: SortOrder
    blogLink?: SortOrder
    difficulty?: SortOrder
    pinned?: SortOrder
    category?: SortOrder
    type?: SortOrder
    published?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GameAssetAvgOrderByAggregateInput = {
    difficulty?: SortOrder
  }

  export type GameAssetMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    image?: SortOrder
    description?: SortOrder
    blogLink?: SortOrder
    difficulty?: SortOrder
    pinned?: SortOrder
    category?: SortOrder
    type?: SortOrder
    published?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GameAssetMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    image?: SortOrder
    description?: SortOrder
    blogLink?: SortOrder
    difficulty?: SortOrder
    pinned?: SortOrder
    category?: SortOrder
    type?: SortOrder
    published?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GameAssetSumOrderByAggregateInput = {
    difficulty?: SortOrder
  }

  export type GameObjectiveCountOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    title?: SortOrder
    image?: SortOrder
    published?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GameObjectiveAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type GameObjectiveMaxOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    title?: SortOrder
    image?: SortOrder
    published?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GameObjectiveMinOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    title?: SortOrder
    image?: SortOrder
    published?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GameObjectiveSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type TestimonialCountOrderByAggregateInput = {
    id?: SortOrder
    quote?: SortOrder
    name?: SortOrder
    designation?: SortOrder
    image?: SortOrder
    order?: SortOrder
    published?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TestimonialAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type TestimonialMaxOrderByAggregateInput = {
    id?: SortOrder
    quote?: SortOrder
    name?: SortOrder
    designation?: SortOrder
    image?: SortOrder
    order?: SortOrder
    published?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TestimonialMinOrderByAggregateInput = {
    id?: SortOrder
    quote?: SortOrder
    name?: SortOrder
    designation?: SortOrder
    image?: SortOrder
    order?: SortOrder
    published?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TestimonialSumOrderByAggregateInput = {
    order?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    isSet?: boolean
  }

  export type SiteSettingsCountOrderByAggregateInput = {
    id?: SortOrder
    heroBackgroundImage?: SortOrder
    header?: SortOrder
    pages?: SortOrder
    footer?: SortOrder
    homeSections?: SortOrder
    aboutHomeSection?: SortOrder
    aboutPage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SiteSettingsMaxOrderByAggregateInput = {
    id?: SortOrder
    heroBackgroundImage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SiteSettingsMinOrderByAggregateInput = {
    id?: SortOrder
    heroBackgroundImage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type InvestorCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    logo?: SortOrder
    url?: SortOrder
    order?: SortOrder
    published?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvestorAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type InvestorMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    logo?: SortOrder
    url?: SortOrder
    order?: SortOrder
    published?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvestorMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    logo?: SortOrder
    url?: SortOrder
    order?: SortOrder
    published?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvestorSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type ConsentListRelationFilter = {
    every?: consentWhereInput
    some?: consentWhereInput
    none?: consentWhereInput
  }

  export type ConsentRecordListRelationFilter = {
    every?: consentRecordWhereInput
    some?: consentRecordWhereInput
    none?: consentRecordWhereInput
  }

  export type AuditLogListRelationFilter = {
    every?: auditLogWhereInput
    some?: auditLogWhereInput
    none?: auditLogWhereInput
  }

  export type consentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type consentRecordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type auditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type subjectCountOrderByAggregateInput = {
    id?: SortOrder
    isIdentified?: SortOrder
    externalId?: SortOrder
    identityProvider?: SortOrder
    lastIpAddress?: SortOrder
    subjectTimezone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type subjectMaxOrderByAggregateInput = {
    id?: SortOrder
    isIdentified?: SortOrder
    externalId?: SortOrder
    identityProvider?: SortOrder
    lastIpAddress?: SortOrder
    subjectTimezone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type subjectMinOrderByAggregateInput = {
    id?: SortOrder
    isIdentified?: SortOrder
    externalId?: SortOrder
    identityProvider?: SortOrder
    lastIpAddress?: SortOrder
    subjectTimezone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type domainCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    allowedOrigins?: SortOrder
    isVerified?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type domainMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isVerified?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type domainMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isVerified?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type consentPolicyCountOrderByAggregateInput = {
    id?: SortOrder
    version?: SortOrder
    type?: SortOrder
    name?: SortOrder
    effectiveDate?: SortOrder
    expirationDate?: SortOrder
    content?: SortOrder
    contentHash?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type consentPolicyMaxOrderByAggregateInput = {
    id?: SortOrder
    version?: SortOrder
    type?: SortOrder
    name?: SortOrder
    effectiveDate?: SortOrder
    expirationDate?: SortOrder
    content?: SortOrder
    contentHash?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type consentPolicyMinOrderByAggregateInput = {
    id?: SortOrder
    version?: SortOrder
    type?: SortOrder
    name?: SortOrder
    effectiveDate?: SortOrder
    expirationDate?: SortOrder
    content?: SortOrder
    contentHash?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type consentPurposeCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isEssential?: SortOrder
    dataCategory?: SortOrder
    legalBasis?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type consentPurposeMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isEssential?: SortOrder
    dataCategory?: SortOrder
    legalBasis?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type consentPurposeMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isEssential?: SortOrder
    dataCategory?: SortOrder
    legalBasis?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubjectScalarRelationFilter = {
    is?: subjectWhereInput
    isNot?: subjectWhereInput
  }

  export type DomainScalarRelationFilter = {
    is?: domainWhereInput
    isNot?: domainWhereInput
  }

  export type ConsentPolicyNullableScalarRelationFilter = {
    is?: consentPolicyWhereInput | null
    isNot?: consentPolicyWhereInput | null
  }

  export type consentCountOrderByAggregateInput = {
    id?: SortOrder
    subjectId?: SortOrder
    domainId?: SortOrder
    policyId?: SortOrder
    purposeIds?: SortOrder
    metadata?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    status?: SortOrder
    withdrawalReason?: SortOrder
    givenAt?: SortOrder
    validUntil?: SortOrder
    isActive?: SortOrder
  }

  export type consentMaxOrderByAggregateInput = {
    id?: SortOrder
    subjectId?: SortOrder
    domainId?: SortOrder
    policyId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    status?: SortOrder
    withdrawalReason?: SortOrder
    givenAt?: SortOrder
    validUntil?: SortOrder
    isActive?: SortOrder
  }

  export type consentMinOrderByAggregateInput = {
    id?: SortOrder
    subjectId?: SortOrder
    domainId?: SortOrder
    policyId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    status?: SortOrder
    withdrawalReason?: SortOrder
    givenAt?: SortOrder
    validUntil?: SortOrder
    isActive?: SortOrder
  }

  export type SubjectNullableScalarRelationFilter = {
    is?: subjectWhereInput | null
    isNot?: subjectWhereInput | null
  }

  export type auditLogCountOrderByAggregateInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    actionType?: SortOrder
    subjectId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    changes?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    eventTimezone?: SortOrder
  }

  export type auditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    actionType?: SortOrder
    subjectId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
    eventTimezone?: SortOrder
  }

  export type auditLogMinOrderByAggregateInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    actionType?: SortOrder
    subjectId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
    eventTimezone?: SortOrder
  }

  export type ConsentNullableScalarRelationFilter = {
    is?: consentWhereInput | null
    isNot?: consentWhereInput | null
  }

  export type consentRecordCountOrderByAggregateInput = {
    id?: SortOrder
    subjectId?: SortOrder
    consentId?: SortOrder
    actionType?: SortOrder
    details?: SortOrder
    createdAt?: SortOrder
  }

  export type consentRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    subjectId?: SortOrder
    consentId?: SortOrder
    actionType?: SortOrder
    createdAt?: SortOrder
  }

  export type consentRecordMinOrderByAggregateInput = {
    id?: SortOrder
    subjectId?: SortOrder
    consentId?: SortOrder
    actionType?: SortOrder
    createdAt?: SortOrder
  }

  export type private_c15t_settingsCountOrderByAggregateInput = {
    key?: SortOrder
    value?: SortOrder
  }

  export type private_c15t_settingsMaxOrderByAggregateInput = {
    key?: SortOrder
    value?: SortOrder
  }

  export type private_c15t_settingsMinOrderByAggregateInput = {
    key?: SortOrder
    value?: SortOrder
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type AccountCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type BlogPostCreateNestedManyWithoutAuthorInput = {
    create?: XOR<BlogPostCreateWithoutAuthorInput, BlogPostUncheckedCreateWithoutAuthorInput> | BlogPostCreateWithoutAuthorInput[] | BlogPostUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: BlogPostCreateOrConnectWithoutAuthorInput | BlogPostCreateOrConnectWithoutAuthorInput[]
    createMany?: BlogPostCreateManyAuthorInputEnvelope
    connect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
  }

  export type RoadmapItemCreateNestedManyWithoutAuthorInput = {
    create?: XOR<RoadmapItemCreateWithoutAuthorInput, RoadmapItemUncheckedCreateWithoutAuthorInput> | RoadmapItemCreateWithoutAuthorInput[] | RoadmapItemUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: RoadmapItemCreateOrConnectWithoutAuthorInput | RoadmapItemCreateOrConnectWithoutAuthorInput[]
    createMany?: RoadmapItemCreateManyAuthorInputEnvelope
    connect?: RoadmapItemWhereUniqueInput | RoadmapItemWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type AccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type BlogPostUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<BlogPostCreateWithoutAuthorInput, BlogPostUncheckedCreateWithoutAuthorInput> | BlogPostCreateWithoutAuthorInput[] | BlogPostUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: BlogPostCreateOrConnectWithoutAuthorInput | BlogPostCreateOrConnectWithoutAuthorInput[]
    createMany?: BlogPostCreateManyAuthorInputEnvelope
    connect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
  }

  export type RoadmapItemUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<RoadmapItemCreateWithoutAuthorInput, RoadmapItemUncheckedCreateWithoutAuthorInput> | RoadmapItemCreateWithoutAuthorInput[] | RoadmapItemUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: RoadmapItemCreateOrConnectWithoutAuthorInput | RoadmapItemCreateOrConnectWithoutAuthorInput[]
    createMany?: RoadmapItemCreateManyAuthorInputEnvelope
    connect?: RoadmapItemWhereUniqueInput | RoadmapItemWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
    unset?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type AccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type BlogPostUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<BlogPostCreateWithoutAuthorInput, BlogPostUncheckedCreateWithoutAuthorInput> | BlogPostCreateWithoutAuthorInput[] | BlogPostUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: BlogPostCreateOrConnectWithoutAuthorInput | BlogPostCreateOrConnectWithoutAuthorInput[]
    upsert?: BlogPostUpsertWithWhereUniqueWithoutAuthorInput | BlogPostUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: BlogPostCreateManyAuthorInputEnvelope
    set?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    disconnect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    delete?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    connect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    update?: BlogPostUpdateWithWhereUniqueWithoutAuthorInput | BlogPostUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: BlogPostUpdateManyWithWhereWithoutAuthorInput | BlogPostUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: BlogPostScalarWhereInput | BlogPostScalarWhereInput[]
  }

  export type RoadmapItemUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<RoadmapItemCreateWithoutAuthorInput, RoadmapItemUncheckedCreateWithoutAuthorInput> | RoadmapItemCreateWithoutAuthorInput[] | RoadmapItemUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: RoadmapItemCreateOrConnectWithoutAuthorInput | RoadmapItemCreateOrConnectWithoutAuthorInput[]
    upsert?: RoadmapItemUpsertWithWhereUniqueWithoutAuthorInput | RoadmapItemUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: RoadmapItemCreateManyAuthorInputEnvelope
    set?: RoadmapItemWhereUniqueInput | RoadmapItemWhereUniqueInput[]
    disconnect?: RoadmapItemWhereUniqueInput | RoadmapItemWhereUniqueInput[]
    delete?: RoadmapItemWhereUniqueInput | RoadmapItemWhereUniqueInput[]
    connect?: RoadmapItemWhereUniqueInput | RoadmapItemWhereUniqueInput[]
    update?: RoadmapItemUpdateWithWhereUniqueWithoutAuthorInput | RoadmapItemUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: RoadmapItemUpdateManyWithWhereWithoutAuthorInput | RoadmapItemUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: RoadmapItemScalarWhereInput | RoadmapItemScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type AccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type BlogPostUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<BlogPostCreateWithoutAuthorInput, BlogPostUncheckedCreateWithoutAuthorInput> | BlogPostCreateWithoutAuthorInput[] | BlogPostUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: BlogPostCreateOrConnectWithoutAuthorInput | BlogPostCreateOrConnectWithoutAuthorInput[]
    upsert?: BlogPostUpsertWithWhereUniqueWithoutAuthorInput | BlogPostUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: BlogPostCreateManyAuthorInputEnvelope
    set?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    disconnect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    delete?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    connect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    update?: BlogPostUpdateWithWhereUniqueWithoutAuthorInput | BlogPostUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: BlogPostUpdateManyWithWhereWithoutAuthorInput | BlogPostUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: BlogPostScalarWhereInput | BlogPostScalarWhereInput[]
  }

  export type RoadmapItemUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<RoadmapItemCreateWithoutAuthorInput, RoadmapItemUncheckedCreateWithoutAuthorInput> | RoadmapItemCreateWithoutAuthorInput[] | RoadmapItemUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: RoadmapItemCreateOrConnectWithoutAuthorInput | RoadmapItemCreateOrConnectWithoutAuthorInput[]
    upsert?: RoadmapItemUpsertWithWhereUniqueWithoutAuthorInput | RoadmapItemUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: RoadmapItemCreateManyAuthorInputEnvelope
    set?: RoadmapItemWhereUniqueInput | RoadmapItemWhereUniqueInput[]
    disconnect?: RoadmapItemWhereUniqueInput | RoadmapItemWhereUniqueInput[]
    delete?: RoadmapItemWhereUniqueInput | RoadmapItemWhereUniqueInput[]
    connect?: RoadmapItemWhereUniqueInput | RoadmapItemWhereUniqueInput[]
    update?: RoadmapItemUpdateWithWhereUniqueWithoutAuthorInput | RoadmapItemUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: RoadmapItemUpdateManyWithWhereWithoutAuthorInput | RoadmapItemUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: RoadmapItemScalarWhereInput | RoadmapItemScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserCreateNestedOneWithoutAccountsInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
    unset?: boolean
  }

  export type UserUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    upsert?: UserUpsertWithoutAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccountsInput, UserUpdateWithoutAccountsInput>, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type BlogPostCreatecategoriesInput = {
    set: string[]
  }

  export type BlogPostCreatetagsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutBlogPostsInput = {
    create?: XOR<UserCreateWithoutBlogPostsInput, UserUncheckedCreateWithoutBlogPostsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBlogPostsInput
    connect?: UserWhereUniqueInput
  }

  export type BlogPostUpdatecategoriesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type BlogPostUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutBlogPostsNestedInput = {
    create?: XOR<UserCreateWithoutBlogPostsInput, UserUncheckedCreateWithoutBlogPostsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBlogPostsInput
    upsert?: UserUpsertWithoutBlogPostsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBlogPostsInput, UserUpdateWithoutBlogPostsInput>, UserUncheckedUpdateWithoutBlogPostsInput>
  }

  export type RoadmapItemCreategalleryInput = {
    set: string[]
  }

  export type RoadmapItemCreatecategoriesInput = {
    set: string[]
  }

  export type RoadmapItemCreatetagsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutRoadmapItemsInput = {
    create?: XOR<UserCreateWithoutRoadmapItemsInput, UserUncheckedCreateWithoutRoadmapItemsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRoadmapItemsInput
    connect?: UserWhereUniqueInput
  }

  export type RoadmapItemUpdategalleryInput = {
    set?: string[]
    push?: string | string[]
  }

  export type RoadmapItemUpdatecategoriesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type RoadmapItemUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutRoadmapItemsNestedInput = {
    create?: XOR<UserCreateWithoutRoadmapItemsInput, UserUncheckedCreateWithoutRoadmapItemsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRoadmapItemsInput
    upsert?: UserUpsertWithoutRoadmapItemsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRoadmapItemsInput, UserUpdateWithoutRoadmapItemsInput>, UserUncheckedUpdateWithoutRoadmapItemsInput>
  }

  export type consentCreateNestedManyWithoutSubjectInput = {
    create?: XOR<consentCreateWithoutSubjectInput, consentUncheckedCreateWithoutSubjectInput> | consentCreateWithoutSubjectInput[] | consentUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: consentCreateOrConnectWithoutSubjectInput | consentCreateOrConnectWithoutSubjectInput[]
    createMany?: consentCreateManySubjectInputEnvelope
    connect?: consentWhereUniqueInput | consentWhereUniqueInput[]
  }

  export type consentRecordCreateNestedManyWithoutSubjectInput = {
    create?: XOR<consentRecordCreateWithoutSubjectInput, consentRecordUncheckedCreateWithoutSubjectInput> | consentRecordCreateWithoutSubjectInput[] | consentRecordUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: consentRecordCreateOrConnectWithoutSubjectInput | consentRecordCreateOrConnectWithoutSubjectInput[]
    createMany?: consentRecordCreateManySubjectInputEnvelope
    connect?: consentRecordWhereUniqueInput | consentRecordWhereUniqueInput[]
  }

  export type auditLogCreateNestedManyWithoutSubjectInput = {
    create?: XOR<auditLogCreateWithoutSubjectInput, auditLogUncheckedCreateWithoutSubjectInput> | auditLogCreateWithoutSubjectInput[] | auditLogUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: auditLogCreateOrConnectWithoutSubjectInput | auditLogCreateOrConnectWithoutSubjectInput[]
    createMany?: auditLogCreateManySubjectInputEnvelope
    connect?: auditLogWhereUniqueInput | auditLogWhereUniqueInput[]
  }

  export type consentUncheckedCreateNestedManyWithoutSubjectInput = {
    create?: XOR<consentCreateWithoutSubjectInput, consentUncheckedCreateWithoutSubjectInput> | consentCreateWithoutSubjectInput[] | consentUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: consentCreateOrConnectWithoutSubjectInput | consentCreateOrConnectWithoutSubjectInput[]
    createMany?: consentCreateManySubjectInputEnvelope
    connect?: consentWhereUniqueInput | consentWhereUniqueInput[]
  }

  export type consentRecordUncheckedCreateNestedManyWithoutSubjectInput = {
    create?: XOR<consentRecordCreateWithoutSubjectInput, consentRecordUncheckedCreateWithoutSubjectInput> | consentRecordCreateWithoutSubjectInput[] | consentRecordUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: consentRecordCreateOrConnectWithoutSubjectInput | consentRecordCreateOrConnectWithoutSubjectInput[]
    createMany?: consentRecordCreateManySubjectInputEnvelope
    connect?: consentRecordWhereUniqueInput | consentRecordWhereUniqueInput[]
  }

  export type auditLogUncheckedCreateNestedManyWithoutSubjectInput = {
    create?: XOR<auditLogCreateWithoutSubjectInput, auditLogUncheckedCreateWithoutSubjectInput> | auditLogCreateWithoutSubjectInput[] | auditLogUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: auditLogCreateOrConnectWithoutSubjectInput | auditLogCreateOrConnectWithoutSubjectInput[]
    createMany?: auditLogCreateManySubjectInputEnvelope
    connect?: auditLogWhereUniqueInput | auditLogWhereUniqueInput[]
  }

  export type consentUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<consentCreateWithoutSubjectInput, consentUncheckedCreateWithoutSubjectInput> | consentCreateWithoutSubjectInput[] | consentUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: consentCreateOrConnectWithoutSubjectInput | consentCreateOrConnectWithoutSubjectInput[]
    upsert?: consentUpsertWithWhereUniqueWithoutSubjectInput | consentUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: consentCreateManySubjectInputEnvelope
    set?: consentWhereUniqueInput | consentWhereUniqueInput[]
    disconnect?: consentWhereUniqueInput | consentWhereUniqueInput[]
    delete?: consentWhereUniqueInput | consentWhereUniqueInput[]
    connect?: consentWhereUniqueInput | consentWhereUniqueInput[]
    update?: consentUpdateWithWhereUniqueWithoutSubjectInput | consentUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: consentUpdateManyWithWhereWithoutSubjectInput | consentUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: consentScalarWhereInput | consentScalarWhereInput[]
  }

  export type consentRecordUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<consentRecordCreateWithoutSubjectInput, consentRecordUncheckedCreateWithoutSubjectInput> | consentRecordCreateWithoutSubjectInput[] | consentRecordUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: consentRecordCreateOrConnectWithoutSubjectInput | consentRecordCreateOrConnectWithoutSubjectInput[]
    upsert?: consentRecordUpsertWithWhereUniqueWithoutSubjectInput | consentRecordUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: consentRecordCreateManySubjectInputEnvelope
    set?: consentRecordWhereUniqueInput | consentRecordWhereUniqueInput[]
    disconnect?: consentRecordWhereUniqueInput | consentRecordWhereUniqueInput[]
    delete?: consentRecordWhereUniqueInput | consentRecordWhereUniqueInput[]
    connect?: consentRecordWhereUniqueInput | consentRecordWhereUniqueInput[]
    update?: consentRecordUpdateWithWhereUniqueWithoutSubjectInput | consentRecordUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: consentRecordUpdateManyWithWhereWithoutSubjectInput | consentRecordUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: consentRecordScalarWhereInput | consentRecordScalarWhereInput[]
  }

  export type auditLogUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<auditLogCreateWithoutSubjectInput, auditLogUncheckedCreateWithoutSubjectInput> | auditLogCreateWithoutSubjectInput[] | auditLogUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: auditLogCreateOrConnectWithoutSubjectInput | auditLogCreateOrConnectWithoutSubjectInput[]
    upsert?: auditLogUpsertWithWhereUniqueWithoutSubjectInput | auditLogUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: auditLogCreateManySubjectInputEnvelope
    set?: auditLogWhereUniqueInput | auditLogWhereUniqueInput[]
    disconnect?: auditLogWhereUniqueInput | auditLogWhereUniqueInput[]
    delete?: auditLogWhereUniqueInput | auditLogWhereUniqueInput[]
    connect?: auditLogWhereUniqueInput | auditLogWhereUniqueInput[]
    update?: auditLogUpdateWithWhereUniqueWithoutSubjectInput | auditLogUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: auditLogUpdateManyWithWhereWithoutSubjectInput | auditLogUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: auditLogScalarWhereInput | auditLogScalarWhereInput[]
  }

  export type consentUncheckedUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<consentCreateWithoutSubjectInput, consentUncheckedCreateWithoutSubjectInput> | consentCreateWithoutSubjectInput[] | consentUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: consentCreateOrConnectWithoutSubjectInput | consentCreateOrConnectWithoutSubjectInput[]
    upsert?: consentUpsertWithWhereUniqueWithoutSubjectInput | consentUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: consentCreateManySubjectInputEnvelope
    set?: consentWhereUniqueInput | consentWhereUniqueInput[]
    disconnect?: consentWhereUniqueInput | consentWhereUniqueInput[]
    delete?: consentWhereUniqueInput | consentWhereUniqueInput[]
    connect?: consentWhereUniqueInput | consentWhereUniqueInput[]
    update?: consentUpdateWithWhereUniqueWithoutSubjectInput | consentUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: consentUpdateManyWithWhereWithoutSubjectInput | consentUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: consentScalarWhereInput | consentScalarWhereInput[]
  }

  export type consentRecordUncheckedUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<consentRecordCreateWithoutSubjectInput, consentRecordUncheckedCreateWithoutSubjectInput> | consentRecordCreateWithoutSubjectInput[] | consentRecordUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: consentRecordCreateOrConnectWithoutSubjectInput | consentRecordCreateOrConnectWithoutSubjectInput[]
    upsert?: consentRecordUpsertWithWhereUniqueWithoutSubjectInput | consentRecordUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: consentRecordCreateManySubjectInputEnvelope
    set?: consentRecordWhereUniqueInput | consentRecordWhereUniqueInput[]
    disconnect?: consentRecordWhereUniqueInput | consentRecordWhereUniqueInput[]
    delete?: consentRecordWhereUniqueInput | consentRecordWhereUniqueInput[]
    connect?: consentRecordWhereUniqueInput | consentRecordWhereUniqueInput[]
    update?: consentRecordUpdateWithWhereUniqueWithoutSubjectInput | consentRecordUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: consentRecordUpdateManyWithWhereWithoutSubjectInput | consentRecordUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: consentRecordScalarWhereInput | consentRecordScalarWhereInput[]
  }

  export type auditLogUncheckedUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<auditLogCreateWithoutSubjectInput, auditLogUncheckedCreateWithoutSubjectInput> | auditLogCreateWithoutSubjectInput[] | auditLogUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: auditLogCreateOrConnectWithoutSubjectInput | auditLogCreateOrConnectWithoutSubjectInput[]
    upsert?: auditLogUpsertWithWhereUniqueWithoutSubjectInput | auditLogUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: auditLogCreateManySubjectInputEnvelope
    set?: auditLogWhereUniqueInput | auditLogWhereUniqueInput[]
    disconnect?: auditLogWhereUniqueInput | auditLogWhereUniqueInput[]
    delete?: auditLogWhereUniqueInput | auditLogWhereUniqueInput[]
    connect?: auditLogWhereUniqueInput | auditLogWhereUniqueInput[]
    update?: auditLogUpdateWithWhereUniqueWithoutSubjectInput | auditLogUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: auditLogUpdateManyWithWhereWithoutSubjectInput | auditLogUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: auditLogScalarWhereInput | auditLogScalarWhereInput[]
  }

  export type consentCreateNestedManyWithoutDomainInput = {
    create?: XOR<consentCreateWithoutDomainInput, consentUncheckedCreateWithoutDomainInput> | consentCreateWithoutDomainInput[] | consentUncheckedCreateWithoutDomainInput[]
    connectOrCreate?: consentCreateOrConnectWithoutDomainInput | consentCreateOrConnectWithoutDomainInput[]
    createMany?: consentCreateManyDomainInputEnvelope
    connect?: consentWhereUniqueInput | consentWhereUniqueInput[]
  }

  export type consentUncheckedCreateNestedManyWithoutDomainInput = {
    create?: XOR<consentCreateWithoutDomainInput, consentUncheckedCreateWithoutDomainInput> | consentCreateWithoutDomainInput[] | consentUncheckedCreateWithoutDomainInput[]
    connectOrCreate?: consentCreateOrConnectWithoutDomainInput | consentCreateOrConnectWithoutDomainInput[]
    createMany?: consentCreateManyDomainInputEnvelope
    connect?: consentWhereUniqueInput | consentWhereUniqueInput[]
  }

  export type consentUpdateManyWithoutDomainNestedInput = {
    create?: XOR<consentCreateWithoutDomainInput, consentUncheckedCreateWithoutDomainInput> | consentCreateWithoutDomainInput[] | consentUncheckedCreateWithoutDomainInput[]
    connectOrCreate?: consentCreateOrConnectWithoutDomainInput | consentCreateOrConnectWithoutDomainInput[]
    upsert?: consentUpsertWithWhereUniqueWithoutDomainInput | consentUpsertWithWhereUniqueWithoutDomainInput[]
    createMany?: consentCreateManyDomainInputEnvelope
    set?: consentWhereUniqueInput | consentWhereUniqueInput[]
    disconnect?: consentWhereUniqueInput | consentWhereUniqueInput[]
    delete?: consentWhereUniqueInput | consentWhereUniqueInput[]
    connect?: consentWhereUniqueInput | consentWhereUniqueInput[]
    update?: consentUpdateWithWhereUniqueWithoutDomainInput | consentUpdateWithWhereUniqueWithoutDomainInput[]
    updateMany?: consentUpdateManyWithWhereWithoutDomainInput | consentUpdateManyWithWhereWithoutDomainInput[]
    deleteMany?: consentScalarWhereInput | consentScalarWhereInput[]
  }

  export type consentUncheckedUpdateManyWithoutDomainNestedInput = {
    create?: XOR<consentCreateWithoutDomainInput, consentUncheckedCreateWithoutDomainInput> | consentCreateWithoutDomainInput[] | consentUncheckedCreateWithoutDomainInput[]
    connectOrCreate?: consentCreateOrConnectWithoutDomainInput | consentCreateOrConnectWithoutDomainInput[]
    upsert?: consentUpsertWithWhereUniqueWithoutDomainInput | consentUpsertWithWhereUniqueWithoutDomainInput[]
    createMany?: consentCreateManyDomainInputEnvelope
    set?: consentWhereUniqueInput | consentWhereUniqueInput[]
    disconnect?: consentWhereUniqueInput | consentWhereUniqueInput[]
    delete?: consentWhereUniqueInput | consentWhereUniqueInput[]
    connect?: consentWhereUniqueInput | consentWhereUniqueInput[]
    update?: consentUpdateWithWhereUniqueWithoutDomainInput | consentUpdateWithWhereUniqueWithoutDomainInput[]
    updateMany?: consentUpdateManyWithWhereWithoutDomainInput | consentUpdateManyWithWhereWithoutDomainInput[]
    deleteMany?: consentScalarWhereInput | consentScalarWhereInput[]
  }

  export type consentCreateNestedManyWithoutPolicyInput = {
    create?: XOR<consentCreateWithoutPolicyInput, consentUncheckedCreateWithoutPolicyInput> | consentCreateWithoutPolicyInput[] | consentUncheckedCreateWithoutPolicyInput[]
    connectOrCreate?: consentCreateOrConnectWithoutPolicyInput | consentCreateOrConnectWithoutPolicyInput[]
    createMany?: consentCreateManyPolicyInputEnvelope
    connect?: consentWhereUniqueInput | consentWhereUniqueInput[]
  }

  export type consentUncheckedCreateNestedManyWithoutPolicyInput = {
    create?: XOR<consentCreateWithoutPolicyInput, consentUncheckedCreateWithoutPolicyInput> | consentCreateWithoutPolicyInput[] | consentUncheckedCreateWithoutPolicyInput[]
    connectOrCreate?: consentCreateOrConnectWithoutPolicyInput | consentCreateOrConnectWithoutPolicyInput[]
    createMany?: consentCreateManyPolicyInputEnvelope
    connect?: consentWhereUniqueInput | consentWhereUniqueInput[]
  }

  export type consentUpdateManyWithoutPolicyNestedInput = {
    create?: XOR<consentCreateWithoutPolicyInput, consentUncheckedCreateWithoutPolicyInput> | consentCreateWithoutPolicyInput[] | consentUncheckedCreateWithoutPolicyInput[]
    connectOrCreate?: consentCreateOrConnectWithoutPolicyInput | consentCreateOrConnectWithoutPolicyInput[]
    upsert?: consentUpsertWithWhereUniqueWithoutPolicyInput | consentUpsertWithWhereUniqueWithoutPolicyInput[]
    createMany?: consentCreateManyPolicyInputEnvelope
    set?: consentWhereUniqueInput | consentWhereUniqueInput[]
    disconnect?: consentWhereUniqueInput | consentWhereUniqueInput[]
    delete?: consentWhereUniqueInput | consentWhereUniqueInput[]
    connect?: consentWhereUniqueInput | consentWhereUniqueInput[]
    update?: consentUpdateWithWhereUniqueWithoutPolicyInput | consentUpdateWithWhereUniqueWithoutPolicyInput[]
    updateMany?: consentUpdateManyWithWhereWithoutPolicyInput | consentUpdateManyWithWhereWithoutPolicyInput[]
    deleteMany?: consentScalarWhereInput | consentScalarWhereInput[]
  }

  export type consentUncheckedUpdateManyWithoutPolicyNestedInput = {
    create?: XOR<consentCreateWithoutPolicyInput, consentUncheckedCreateWithoutPolicyInput> | consentCreateWithoutPolicyInput[] | consentUncheckedCreateWithoutPolicyInput[]
    connectOrCreate?: consentCreateOrConnectWithoutPolicyInput | consentCreateOrConnectWithoutPolicyInput[]
    upsert?: consentUpsertWithWhereUniqueWithoutPolicyInput | consentUpsertWithWhereUniqueWithoutPolicyInput[]
    createMany?: consentCreateManyPolicyInputEnvelope
    set?: consentWhereUniqueInput | consentWhereUniqueInput[]
    disconnect?: consentWhereUniqueInput | consentWhereUniqueInput[]
    delete?: consentWhereUniqueInput | consentWhereUniqueInput[]
    connect?: consentWhereUniqueInput | consentWhereUniqueInput[]
    update?: consentUpdateWithWhereUniqueWithoutPolicyInput | consentUpdateWithWhereUniqueWithoutPolicyInput[]
    updateMany?: consentUpdateManyWithWhereWithoutPolicyInput | consentUpdateManyWithWhereWithoutPolicyInput[]
    deleteMany?: consentScalarWhereInput | consentScalarWhereInput[]
  }

  export type subjectCreateNestedOneWithoutConsentsInput = {
    create?: XOR<subjectCreateWithoutConsentsInput, subjectUncheckedCreateWithoutConsentsInput>
    connectOrCreate?: subjectCreateOrConnectWithoutConsentsInput
    connect?: subjectWhereUniqueInput
  }

  export type domainCreateNestedOneWithoutConsentsInput = {
    create?: XOR<domainCreateWithoutConsentsInput, domainUncheckedCreateWithoutConsentsInput>
    connectOrCreate?: domainCreateOrConnectWithoutConsentsInput
    connect?: domainWhereUniqueInput
  }

  export type consentPolicyCreateNestedOneWithoutConsentsInput = {
    create?: XOR<consentPolicyCreateWithoutConsentsInput, consentPolicyUncheckedCreateWithoutConsentsInput>
    connectOrCreate?: consentPolicyCreateOrConnectWithoutConsentsInput
    connect?: consentPolicyWhereUniqueInput
  }

  export type consentRecordCreateNestedManyWithoutConsentInput = {
    create?: XOR<consentRecordCreateWithoutConsentInput, consentRecordUncheckedCreateWithoutConsentInput> | consentRecordCreateWithoutConsentInput[] | consentRecordUncheckedCreateWithoutConsentInput[]
    connectOrCreate?: consentRecordCreateOrConnectWithoutConsentInput | consentRecordCreateOrConnectWithoutConsentInput[]
    createMany?: consentRecordCreateManyConsentInputEnvelope
    connect?: consentRecordWhereUniqueInput | consentRecordWhereUniqueInput[]
  }

  export type consentRecordUncheckedCreateNestedManyWithoutConsentInput = {
    create?: XOR<consentRecordCreateWithoutConsentInput, consentRecordUncheckedCreateWithoutConsentInput> | consentRecordCreateWithoutConsentInput[] | consentRecordUncheckedCreateWithoutConsentInput[]
    connectOrCreate?: consentRecordCreateOrConnectWithoutConsentInput | consentRecordCreateOrConnectWithoutConsentInput[]
    createMany?: consentRecordCreateManyConsentInputEnvelope
    connect?: consentRecordWhereUniqueInput | consentRecordWhereUniqueInput[]
  }

  export type subjectUpdateOneRequiredWithoutConsentsNestedInput = {
    create?: XOR<subjectCreateWithoutConsentsInput, subjectUncheckedCreateWithoutConsentsInput>
    connectOrCreate?: subjectCreateOrConnectWithoutConsentsInput
    upsert?: subjectUpsertWithoutConsentsInput
    connect?: subjectWhereUniqueInput
    update?: XOR<XOR<subjectUpdateToOneWithWhereWithoutConsentsInput, subjectUpdateWithoutConsentsInput>, subjectUncheckedUpdateWithoutConsentsInput>
  }

  export type domainUpdateOneRequiredWithoutConsentsNestedInput = {
    create?: XOR<domainCreateWithoutConsentsInput, domainUncheckedCreateWithoutConsentsInput>
    connectOrCreate?: domainCreateOrConnectWithoutConsentsInput
    upsert?: domainUpsertWithoutConsentsInput
    connect?: domainWhereUniqueInput
    update?: XOR<XOR<domainUpdateToOneWithWhereWithoutConsentsInput, domainUpdateWithoutConsentsInput>, domainUncheckedUpdateWithoutConsentsInput>
  }

  export type consentPolicyUpdateOneWithoutConsentsNestedInput = {
    create?: XOR<consentPolicyCreateWithoutConsentsInput, consentPolicyUncheckedCreateWithoutConsentsInput>
    connectOrCreate?: consentPolicyCreateOrConnectWithoutConsentsInput
    upsert?: consentPolicyUpsertWithoutConsentsInput
    disconnect?: boolean
    delete?: consentPolicyWhereInput | boolean
    connect?: consentPolicyWhereUniqueInput
    update?: XOR<XOR<consentPolicyUpdateToOneWithWhereWithoutConsentsInput, consentPolicyUpdateWithoutConsentsInput>, consentPolicyUncheckedUpdateWithoutConsentsInput>
  }

  export type consentRecordUpdateManyWithoutConsentNestedInput = {
    create?: XOR<consentRecordCreateWithoutConsentInput, consentRecordUncheckedCreateWithoutConsentInput> | consentRecordCreateWithoutConsentInput[] | consentRecordUncheckedCreateWithoutConsentInput[]
    connectOrCreate?: consentRecordCreateOrConnectWithoutConsentInput | consentRecordCreateOrConnectWithoutConsentInput[]
    upsert?: consentRecordUpsertWithWhereUniqueWithoutConsentInput | consentRecordUpsertWithWhereUniqueWithoutConsentInput[]
    createMany?: consentRecordCreateManyConsentInputEnvelope
    set?: consentRecordWhereUniqueInput | consentRecordWhereUniqueInput[]
    disconnect?: consentRecordWhereUniqueInput | consentRecordWhereUniqueInput[]
    delete?: consentRecordWhereUniqueInput | consentRecordWhereUniqueInput[]
    connect?: consentRecordWhereUniqueInput | consentRecordWhereUniqueInput[]
    update?: consentRecordUpdateWithWhereUniqueWithoutConsentInput | consentRecordUpdateWithWhereUniqueWithoutConsentInput[]
    updateMany?: consentRecordUpdateManyWithWhereWithoutConsentInput | consentRecordUpdateManyWithWhereWithoutConsentInput[]
    deleteMany?: consentRecordScalarWhereInput | consentRecordScalarWhereInput[]
  }

  export type consentRecordUncheckedUpdateManyWithoutConsentNestedInput = {
    create?: XOR<consentRecordCreateWithoutConsentInput, consentRecordUncheckedCreateWithoutConsentInput> | consentRecordCreateWithoutConsentInput[] | consentRecordUncheckedCreateWithoutConsentInput[]
    connectOrCreate?: consentRecordCreateOrConnectWithoutConsentInput | consentRecordCreateOrConnectWithoutConsentInput[]
    upsert?: consentRecordUpsertWithWhereUniqueWithoutConsentInput | consentRecordUpsertWithWhereUniqueWithoutConsentInput[]
    createMany?: consentRecordCreateManyConsentInputEnvelope
    set?: consentRecordWhereUniqueInput | consentRecordWhereUniqueInput[]
    disconnect?: consentRecordWhereUniqueInput | consentRecordWhereUniqueInput[]
    delete?: consentRecordWhereUniqueInput | consentRecordWhereUniqueInput[]
    connect?: consentRecordWhereUniqueInput | consentRecordWhereUniqueInput[]
    update?: consentRecordUpdateWithWhereUniqueWithoutConsentInput | consentRecordUpdateWithWhereUniqueWithoutConsentInput[]
    updateMany?: consentRecordUpdateManyWithWhereWithoutConsentInput | consentRecordUpdateManyWithWhereWithoutConsentInput[]
    deleteMany?: consentRecordScalarWhereInput | consentRecordScalarWhereInput[]
  }

  export type subjectCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<subjectCreateWithoutAuditLogsInput, subjectUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: subjectCreateOrConnectWithoutAuditLogsInput
    connect?: subjectWhereUniqueInput
  }

  export type subjectUpdateOneWithoutAuditLogsNestedInput = {
    create?: XOR<subjectCreateWithoutAuditLogsInput, subjectUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: subjectCreateOrConnectWithoutAuditLogsInput
    upsert?: subjectUpsertWithoutAuditLogsInput
    disconnect?: boolean
    delete?: subjectWhereInput | boolean
    connect?: subjectWhereUniqueInput
    update?: XOR<XOR<subjectUpdateToOneWithWhereWithoutAuditLogsInput, subjectUpdateWithoutAuditLogsInput>, subjectUncheckedUpdateWithoutAuditLogsInput>
  }

  export type subjectCreateNestedOneWithoutConsentRecordsInput = {
    create?: XOR<subjectCreateWithoutConsentRecordsInput, subjectUncheckedCreateWithoutConsentRecordsInput>
    connectOrCreate?: subjectCreateOrConnectWithoutConsentRecordsInput
    connect?: subjectWhereUniqueInput
  }

  export type consentCreateNestedOneWithoutConsentRecordsInput = {
    create?: XOR<consentCreateWithoutConsentRecordsInput, consentUncheckedCreateWithoutConsentRecordsInput>
    connectOrCreate?: consentCreateOrConnectWithoutConsentRecordsInput
    connect?: consentWhereUniqueInput
  }

  export type subjectUpdateOneRequiredWithoutConsentRecordsNestedInput = {
    create?: XOR<subjectCreateWithoutConsentRecordsInput, subjectUncheckedCreateWithoutConsentRecordsInput>
    connectOrCreate?: subjectCreateOrConnectWithoutConsentRecordsInput
    upsert?: subjectUpsertWithoutConsentRecordsInput
    connect?: subjectWhereUniqueInput
    update?: XOR<XOR<subjectUpdateToOneWithWhereWithoutConsentRecordsInput, subjectUpdateWithoutConsentRecordsInput>, subjectUncheckedUpdateWithoutConsentRecordsInput>
  }

  export type consentUpdateOneWithoutConsentRecordsNestedInput = {
    create?: XOR<consentCreateWithoutConsentRecordsInput, consentUncheckedCreateWithoutConsentRecordsInput>
    connectOrCreate?: consentCreateOrConnectWithoutConsentRecordsInput
    upsert?: consentUpsertWithoutConsentRecordsInput
    disconnect?: boolean
    delete?: consentWhereInput | boolean
    connect?: consentWhereUniqueInput
    update?: XOR<XOR<consentUpdateToOneWithWhereWithoutConsentRecordsInput, consentUpdateWithoutConsentRecordsInput>, consentUncheckedUpdateWithoutConsentRecordsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
    isSet?: boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
    isSet?: boolean
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    isSet?: boolean
  }

  export type SessionCreateWithoutUserInput = {
    id: string
    expiresAt: Date | string
    token: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id: string
    expiresAt: Date | string
    token: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
  }

  export type AccountCreateWithoutUserInput = {
    id: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUncheckedCreateWithoutUserInput = {
    id: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountCreateManyUserInputEnvelope = {
    data: AccountCreateManyUserInput | AccountCreateManyUserInput[]
  }

  export type BlogPostCreateWithoutAuthorInput = {
    id?: string
    title: string
    slug: string
    excerpt: string
    content: string
    image: string
    published?: boolean
    categories?: BlogPostCreatecategoriesInput | string[]
    tags?: BlogPostCreatetagsInput | string[]
    views?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BlogPostUncheckedCreateWithoutAuthorInput = {
    id?: string
    title: string
    slug: string
    excerpt: string
    content: string
    image: string
    published?: boolean
    categories?: BlogPostCreatecategoriesInput | string[]
    tags?: BlogPostCreatetagsInput | string[]
    views?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BlogPostCreateOrConnectWithoutAuthorInput = {
    where: BlogPostWhereUniqueInput
    create: XOR<BlogPostCreateWithoutAuthorInput, BlogPostUncheckedCreateWithoutAuthorInput>
  }

  export type BlogPostCreateManyAuthorInputEnvelope = {
    data: BlogPostCreateManyAuthorInput | BlogPostCreateManyAuthorInput[]
  }

  export type RoadmapItemCreateWithoutAuthorInput = {
    id?: string
    title: string
    slug: string
    excerpt: string
    content: string
    featuredImage: string
    gallery?: RoadmapItemCreategalleryInput | string[]
    youtubeVideoId?: string | null
    displayDate?: Date | string | null
    published?: boolean
    categories?: RoadmapItemCreatecategoriesInput | string[]
    tags?: RoadmapItemCreatetagsInput | string[]
    views?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoadmapItemUncheckedCreateWithoutAuthorInput = {
    id?: string
    title: string
    slug: string
    excerpt: string
    content: string
    featuredImage: string
    gallery?: RoadmapItemCreategalleryInput | string[]
    youtubeVideoId?: string | null
    displayDate?: Date | string | null
    published?: boolean
    categories?: RoadmapItemCreatecategoriesInput | string[]
    tags?: RoadmapItemCreatetagsInput | string[]
    views?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoadmapItemCreateOrConnectWithoutAuthorInput = {
    where: RoadmapItemWhereUniqueInput
    create: XOR<RoadmapItemCreateWithoutAuthorInput, RoadmapItemUncheckedCreateWithoutAuthorInput>
  }

  export type RoadmapItemCreateManyAuthorInputEnvelope = {
    data: RoadmapItemCreateManyAuthorInput | RoadmapItemCreateManyAuthorInput[]
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    token?: StringFilter<"Session"> | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    userId?: StringFilter<"Session"> | string
  }

  export type AccountUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
  }

  export type AccountUpdateManyWithWhereWithoutUserInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutUserInput>
  }

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[]
    OR?: AccountScalarWhereInput[]
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[]
    id?: StringFilter<"Account"> | string
    accountId?: StringFilter<"Account"> | string
    providerId?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    accessToken?: StringNullableFilter<"Account"> | string | null
    refreshToken?: StringNullableFilter<"Account"> | string | null
    idToken?: StringNullableFilter<"Account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    password?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
  }

  export type BlogPostUpsertWithWhereUniqueWithoutAuthorInput = {
    where: BlogPostWhereUniqueInput
    update: XOR<BlogPostUpdateWithoutAuthorInput, BlogPostUncheckedUpdateWithoutAuthorInput>
    create: XOR<BlogPostCreateWithoutAuthorInput, BlogPostUncheckedCreateWithoutAuthorInput>
  }

  export type BlogPostUpdateWithWhereUniqueWithoutAuthorInput = {
    where: BlogPostWhereUniqueInput
    data: XOR<BlogPostUpdateWithoutAuthorInput, BlogPostUncheckedUpdateWithoutAuthorInput>
  }

  export type BlogPostUpdateManyWithWhereWithoutAuthorInput = {
    where: BlogPostScalarWhereInput
    data: XOR<BlogPostUpdateManyMutationInput, BlogPostUncheckedUpdateManyWithoutAuthorInput>
  }

  export type BlogPostScalarWhereInput = {
    AND?: BlogPostScalarWhereInput | BlogPostScalarWhereInput[]
    OR?: BlogPostScalarWhereInput[]
    NOT?: BlogPostScalarWhereInput | BlogPostScalarWhereInput[]
    id?: StringFilter<"BlogPost"> | string
    title?: StringFilter<"BlogPost"> | string
    slug?: StringFilter<"BlogPost"> | string
    excerpt?: StringFilter<"BlogPost"> | string
    content?: StringFilter<"BlogPost"> | string
    image?: StringFilter<"BlogPost"> | string
    published?: BoolFilter<"BlogPost"> | boolean
    authorId?: StringFilter<"BlogPost"> | string
    categories?: StringNullableListFilter<"BlogPost">
    tags?: StringNullableListFilter<"BlogPost">
    views?: IntFilter<"BlogPost"> | number
    createdAt?: DateTimeFilter<"BlogPost"> | Date | string
    updatedAt?: DateTimeFilter<"BlogPost"> | Date | string
  }

  export type RoadmapItemUpsertWithWhereUniqueWithoutAuthorInput = {
    where: RoadmapItemWhereUniqueInput
    update: XOR<RoadmapItemUpdateWithoutAuthorInput, RoadmapItemUncheckedUpdateWithoutAuthorInput>
    create: XOR<RoadmapItemCreateWithoutAuthorInput, RoadmapItemUncheckedCreateWithoutAuthorInput>
  }

  export type RoadmapItemUpdateWithWhereUniqueWithoutAuthorInput = {
    where: RoadmapItemWhereUniqueInput
    data: XOR<RoadmapItemUpdateWithoutAuthorInput, RoadmapItemUncheckedUpdateWithoutAuthorInput>
  }

  export type RoadmapItemUpdateManyWithWhereWithoutAuthorInput = {
    where: RoadmapItemScalarWhereInput
    data: XOR<RoadmapItemUpdateManyMutationInput, RoadmapItemUncheckedUpdateManyWithoutAuthorInput>
  }

  export type RoadmapItemScalarWhereInput = {
    AND?: RoadmapItemScalarWhereInput | RoadmapItemScalarWhereInput[]
    OR?: RoadmapItemScalarWhereInput[]
    NOT?: RoadmapItemScalarWhereInput | RoadmapItemScalarWhereInput[]
    id?: StringFilter<"RoadmapItem"> | string
    title?: StringFilter<"RoadmapItem"> | string
    slug?: StringFilter<"RoadmapItem"> | string
    excerpt?: StringFilter<"RoadmapItem"> | string
    content?: StringFilter<"RoadmapItem"> | string
    featuredImage?: StringFilter<"RoadmapItem"> | string
    gallery?: StringNullableListFilter<"RoadmapItem">
    youtubeVideoId?: StringNullableFilter<"RoadmapItem"> | string | null
    displayDate?: DateTimeNullableFilter<"RoadmapItem"> | Date | string | null
    published?: BoolFilter<"RoadmapItem"> | boolean
    authorId?: StringFilter<"RoadmapItem"> | string
    categories?: StringNullableListFilter<"RoadmapItem">
    tags?: StringNullableListFilter<"RoadmapItem">
    views?: IntFilter<"RoadmapItem"> | number
    createdAt?: DateTimeFilter<"RoadmapItem"> | Date | string
    updatedAt?: DateTimeFilter<"RoadmapItem"> | Date | string
  }

  export type UserCreateWithoutSessionsInput = {
    id: string
    name: string
    email: string
    emailVerified?: boolean
    image?: string | null
    bio?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostCreateNestedManyWithoutAuthorInput
    roadmapItems?: RoadmapItemCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id: string
    name: string
    email: string
    emailVerified?: boolean
    image?: string | null
    bio?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutAuthorInput
    roadmapItems?: RoadmapItemUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUpdateManyWithoutAuthorNestedInput
    roadmapItems?: RoadmapItemUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutAuthorNestedInput
    roadmapItems?: RoadmapItemUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type UserCreateWithoutAccountsInput = {
    id: string
    name: string
    email: string
    emailVerified?: boolean
    image?: string | null
    bio?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostCreateNestedManyWithoutAuthorInput
    roadmapItems?: RoadmapItemCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutAccountsInput = {
    id: string
    name: string
    email: string
    emailVerified?: boolean
    image?: string | null
    bio?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutAuthorInput
    roadmapItems?: RoadmapItemUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
  }

  export type UserUpsertWithoutAccountsInput = {
    update: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserUpdateWithoutAccountsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUpdateManyWithoutAuthorNestedInput
    roadmapItems?: RoadmapItemUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutAuthorNestedInput
    roadmapItems?: RoadmapItemUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type UserCreateWithoutBlogPostsInput = {
    id: string
    name: string
    email: string
    emailVerified?: boolean
    image?: string | null
    bio?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    roadmapItems?: RoadmapItemCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutBlogPostsInput = {
    id: string
    name: string
    email: string
    emailVerified?: boolean
    image?: string | null
    bio?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    roadmapItems?: RoadmapItemUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutBlogPostsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBlogPostsInput, UserUncheckedCreateWithoutBlogPostsInput>
  }

  export type UserUpsertWithoutBlogPostsInput = {
    update: XOR<UserUpdateWithoutBlogPostsInput, UserUncheckedUpdateWithoutBlogPostsInput>
    create: XOR<UserCreateWithoutBlogPostsInput, UserUncheckedCreateWithoutBlogPostsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBlogPostsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBlogPostsInput, UserUncheckedUpdateWithoutBlogPostsInput>
  }

  export type UserUpdateWithoutBlogPostsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    roadmapItems?: RoadmapItemUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutBlogPostsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    roadmapItems?: RoadmapItemUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type UserCreateWithoutRoadmapItemsInput = {
    id: string
    name: string
    email: string
    emailVerified?: boolean
    image?: string | null
    bio?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutRoadmapItemsInput = {
    id: string
    name: string
    email: string
    emailVerified?: boolean
    image?: string | null
    bio?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutRoadmapItemsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRoadmapItemsInput, UserUncheckedCreateWithoutRoadmapItemsInput>
  }

  export type UserUpsertWithoutRoadmapItemsInput = {
    update: XOR<UserUpdateWithoutRoadmapItemsInput, UserUncheckedUpdateWithoutRoadmapItemsInput>
    create: XOR<UserCreateWithoutRoadmapItemsInput, UserUncheckedCreateWithoutRoadmapItemsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRoadmapItemsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRoadmapItemsInput, UserUncheckedUpdateWithoutRoadmapItemsInput>
  }

  export type UserUpdateWithoutRoadmapItemsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutRoadmapItemsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type consentCreateWithoutSubjectInput = {
    id: string
    purposeIds: InputJsonValue
    metadata?: InputJsonValue | null
    ipAddress?: string | null
    userAgent?: string | null
    status: string
    withdrawalReason?: string | null
    givenAt?: Date | string
    validUntil?: Date | string | null
    isActive: boolean
    domain: domainCreateNestedOneWithoutConsentsInput
    policy?: consentPolicyCreateNestedOneWithoutConsentsInput
    consentRecords?: consentRecordCreateNestedManyWithoutConsentInput
  }

  export type consentUncheckedCreateWithoutSubjectInput = {
    id: string
    domainId: string
    policyId?: string | null
    purposeIds: InputJsonValue
    metadata?: InputJsonValue | null
    ipAddress?: string | null
    userAgent?: string | null
    status: string
    withdrawalReason?: string | null
    givenAt?: Date | string
    validUntil?: Date | string | null
    isActive: boolean
    consentRecords?: consentRecordUncheckedCreateNestedManyWithoutConsentInput
  }

  export type consentCreateOrConnectWithoutSubjectInput = {
    where: consentWhereUniqueInput
    create: XOR<consentCreateWithoutSubjectInput, consentUncheckedCreateWithoutSubjectInput>
  }

  export type consentCreateManySubjectInputEnvelope = {
    data: consentCreateManySubjectInput | consentCreateManySubjectInput[]
  }

  export type consentRecordCreateWithoutSubjectInput = {
    id: string
    actionType: string
    details?: InputJsonValue | null
    createdAt?: Date | string
    consent?: consentCreateNestedOneWithoutConsentRecordsInput
  }

  export type consentRecordUncheckedCreateWithoutSubjectInput = {
    id: string
    consentId?: string | null
    actionType: string
    details?: InputJsonValue | null
    createdAt?: Date | string
  }

  export type consentRecordCreateOrConnectWithoutSubjectInput = {
    where: consentRecordWhereUniqueInput
    create: XOR<consentRecordCreateWithoutSubjectInput, consentRecordUncheckedCreateWithoutSubjectInput>
  }

  export type consentRecordCreateManySubjectInputEnvelope = {
    data: consentRecordCreateManySubjectInput | consentRecordCreateManySubjectInput[]
  }

  export type auditLogCreateWithoutSubjectInput = {
    id: string
    entityType: string
    entityId: string
    actionType: string
    ipAddress?: string | null
    userAgent?: string | null
    changes?: InputJsonValue | null
    metadata?: InputJsonValue | null
    createdAt?: Date | string
    eventTimezone: string
  }

  export type auditLogUncheckedCreateWithoutSubjectInput = {
    id: string
    entityType: string
    entityId: string
    actionType: string
    ipAddress?: string | null
    userAgent?: string | null
    changes?: InputJsonValue | null
    metadata?: InputJsonValue | null
    createdAt?: Date | string
    eventTimezone: string
  }

  export type auditLogCreateOrConnectWithoutSubjectInput = {
    where: auditLogWhereUniqueInput
    create: XOR<auditLogCreateWithoutSubjectInput, auditLogUncheckedCreateWithoutSubjectInput>
  }

  export type auditLogCreateManySubjectInputEnvelope = {
    data: auditLogCreateManySubjectInput | auditLogCreateManySubjectInput[]
  }

  export type consentUpsertWithWhereUniqueWithoutSubjectInput = {
    where: consentWhereUniqueInput
    update: XOR<consentUpdateWithoutSubjectInput, consentUncheckedUpdateWithoutSubjectInput>
    create: XOR<consentCreateWithoutSubjectInput, consentUncheckedCreateWithoutSubjectInput>
  }

  export type consentUpdateWithWhereUniqueWithoutSubjectInput = {
    where: consentWhereUniqueInput
    data: XOR<consentUpdateWithoutSubjectInput, consentUncheckedUpdateWithoutSubjectInput>
  }

  export type consentUpdateManyWithWhereWithoutSubjectInput = {
    where: consentScalarWhereInput
    data: XOR<consentUpdateManyMutationInput, consentUncheckedUpdateManyWithoutSubjectInput>
  }

  export type consentScalarWhereInput = {
    AND?: consentScalarWhereInput | consentScalarWhereInput[]
    OR?: consentScalarWhereInput[]
    NOT?: consentScalarWhereInput | consentScalarWhereInput[]
    id?: StringFilter<"consent"> | string
    subjectId?: StringFilter<"consent"> | string
    domainId?: StringFilter<"consent"> | string
    policyId?: StringNullableFilter<"consent"> | string | null
    purposeIds?: JsonFilter<"consent">
    metadata?: JsonNullableFilter<"consent">
    ipAddress?: StringNullableFilter<"consent"> | string | null
    userAgent?: StringNullableFilter<"consent"> | string | null
    status?: StringFilter<"consent"> | string
    withdrawalReason?: StringNullableFilter<"consent"> | string | null
    givenAt?: DateTimeFilter<"consent"> | Date | string
    validUntil?: DateTimeNullableFilter<"consent"> | Date | string | null
    isActive?: BoolFilter<"consent"> | boolean
  }

  export type consentRecordUpsertWithWhereUniqueWithoutSubjectInput = {
    where: consentRecordWhereUniqueInput
    update: XOR<consentRecordUpdateWithoutSubjectInput, consentRecordUncheckedUpdateWithoutSubjectInput>
    create: XOR<consentRecordCreateWithoutSubjectInput, consentRecordUncheckedCreateWithoutSubjectInput>
  }

  export type consentRecordUpdateWithWhereUniqueWithoutSubjectInput = {
    where: consentRecordWhereUniqueInput
    data: XOR<consentRecordUpdateWithoutSubjectInput, consentRecordUncheckedUpdateWithoutSubjectInput>
  }

  export type consentRecordUpdateManyWithWhereWithoutSubjectInput = {
    where: consentRecordScalarWhereInput
    data: XOR<consentRecordUpdateManyMutationInput, consentRecordUncheckedUpdateManyWithoutSubjectInput>
  }

  export type consentRecordScalarWhereInput = {
    AND?: consentRecordScalarWhereInput | consentRecordScalarWhereInput[]
    OR?: consentRecordScalarWhereInput[]
    NOT?: consentRecordScalarWhereInput | consentRecordScalarWhereInput[]
    id?: StringFilter<"consentRecord"> | string
    subjectId?: StringFilter<"consentRecord"> | string
    consentId?: StringNullableFilter<"consentRecord"> | string | null
    actionType?: StringFilter<"consentRecord"> | string
    details?: JsonNullableFilter<"consentRecord">
    createdAt?: DateTimeFilter<"consentRecord"> | Date | string
  }

  export type auditLogUpsertWithWhereUniqueWithoutSubjectInput = {
    where: auditLogWhereUniqueInput
    update: XOR<auditLogUpdateWithoutSubjectInput, auditLogUncheckedUpdateWithoutSubjectInput>
    create: XOR<auditLogCreateWithoutSubjectInput, auditLogUncheckedCreateWithoutSubjectInput>
  }

  export type auditLogUpdateWithWhereUniqueWithoutSubjectInput = {
    where: auditLogWhereUniqueInput
    data: XOR<auditLogUpdateWithoutSubjectInput, auditLogUncheckedUpdateWithoutSubjectInput>
  }

  export type auditLogUpdateManyWithWhereWithoutSubjectInput = {
    where: auditLogScalarWhereInput
    data: XOR<auditLogUpdateManyMutationInput, auditLogUncheckedUpdateManyWithoutSubjectInput>
  }

  export type auditLogScalarWhereInput = {
    AND?: auditLogScalarWhereInput | auditLogScalarWhereInput[]
    OR?: auditLogScalarWhereInput[]
    NOT?: auditLogScalarWhereInput | auditLogScalarWhereInput[]
    id?: StringFilter<"auditLog"> | string
    entityType?: StringFilter<"auditLog"> | string
    entityId?: StringFilter<"auditLog"> | string
    actionType?: StringFilter<"auditLog"> | string
    subjectId?: StringNullableFilter<"auditLog"> | string | null
    ipAddress?: StringNullableFilter<"auditLog"> | string | null
    userAgent?: StringNullableFilter<"auditLog"> | string | null
    changes?: JsonNullableFilter<"auditLog">
    metadata?: JsonNullableFilter<"auditLog">
    createdAt?: DateTimeFilter<"auditLog"> | Date | string
    eventTimezone?: StringFilter<"auditLog"> | string
  }

  export type consentCreateWithoutDomainInput = {
    id: string
    purposeIds: InputJsonValue
    metadata?: InputJsonValue | null
    ipAddress?: string | null
    userAgent?: string | null
    status: string
    withdrawalReason?: string | null
    givenAt?: Date | string
    validUntil?: Date | string | null
    isActive: boolean
    subject: subjectCreateNestedOneWithoutConsentsInput
    policy?: consentPolicyCreateNestedOneWithoutConsentsInput
    consentRecords?: consentRecordCreateNestedManyWithoutConsentInput
  }

  export type consentUncheckedCreateWithoutDomainInput = {
    id: string
    subjectId: string
    policyId?: string | null
    purposeIds: InputJsonValue
    metadata?: InputJsonValue | null
    ipAddress?: string | null
    userAgent?: string | null
    status: string
    withdrawalReason?: string | null
    givenAt?: Date | string
    validUntil?: Date | string | null
    isActive: boolean
    consentRecords?: consentRecordUncheckedCreateNestedManyWithoutConsentInput
  }

  export type consentCreateOrConnectWithoutDomainInput = {
    where: consentWhereUniqueInput
    create: XOR<consentCreateWithoutDomainInput, consentUncheckedCreateWithoutDomainInput>
  }

  export type consentCreateManyDomainInputEnvelope = {
    data: consentCreateManyDomainInput | consentCreateManyDomainInput[]
  }

  export type consentUpsertWithWhereUniqueWithoutDomainInput = {
    where: consentWhereUniqueInput
    update: XOR<consentUpdateWithoutDomainInput, consentUncheckedUpdateWithoutDomainInput>
    create: XOR<consentCreateWithoutDomainInput, consentUncheckedCreateWithoutDomainInput>
  }

  export type consentUpdateWithWhereUniqueWithoutDomainInput = {
    where: consentWhereUniqueInput
    data: XOR<consentUpdateWithoutDomainInput, consentUncheckedUpdateWithoutDomainInput>
  }

  export type consentUpdateManyWithWhereWithoutDomainInput = {
    where: consentScalarWhereInput
    data: XOR<consentUpdateManyMutationInput, consentUncheckedUpdateManyWithoutDomainInput>
  }

  export type consentCreateWithoutPolicyInput = {
    id: string
    purposeIds: InputJsonValue
    metadata?: InputJsonValue | null
    ipAddress?: string | null
    userAgent?: string | null
    status: string
    withdrawalReason?: string | null
    givenAt?: Date | string
    validUntil?: Date | string | null
    isActive: boolean
    subject: subjectCreateNestedOneWithoutConsentsInput
    domain: domainCreateNestedOneWithoutConsentsInput
    consentRecords?: consentRecordCreateNestedManyWithoutConsentInput
  }

  export type consentUncheckedCreateWithoutPolicyInput = {
    id: string
    subjectId: string
    domainId: string
    purposeIds: InputJsonValue
    metadata?: InputJsonValue | null
    ipAddress?: string | null
    userAgent?: string | null
    status: string
    withdrawalReason?: string | null
    givenAt?: Date | string
    validUntil?: Date | string | null
    isActive: boolean
    consentRecords?: consentRecordUncheckedCreateNestedManyWithoutConsentInput
  }

  export type consentCreateOrConnectWithoutPolicyInput = {
    where: consentWhereUniqueInput
    create: XOR<consentCreateWithoutPolicyInput, consentUncheckedCreateWithoutPolicyInput>
  }

  export type consentCreateManyPolicyInputEnvelope = {
    data: consentCreateManyPolicyInput | consentCreateManyPolicyInput[]
  }

  export type consentUpsertWithWhereUniqueWithoutPolicyInput = {
    where: consentWhereUniqueInput
    update: XOR<consentUpdateWithoutPolicyInput, consentUncheckedUpdateWithoutPolicyInput>
    create: XOR<consentCreateWithoutPolicyInput, consentUncheckedCreateWithoutPolicyInput>
  }

  export type consentUpdateWithWhereUniqueWithoutPolicyInput = {
    where: consentWhereUniqueInput
    data: XOR<consentUpdateWithoutPolicyInput, consentUncheckedUpdateWithoutPolicyInput>
  }

  export type consentUpdateManyWithWhereWithoutPolicyInput = {
    where: consentScalarWhereInput
    data: XOR<consentUpdateManyMutationInput, consentUncheckedUpdateManyWithoutPolicyInput>
  }

  export type subjectCreateWithoutConsentsInput = {
    id: string
    isIdentified: boolean
    externalId?: string | null
    identityProvider?: string | null
    lastIpAddress?: string | null
    subjectTimezone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    consentRecords?: consentRecordCreateNestedManyWithoutSubjectInput
    auditLogs?: auditLogCreateNestedManyWithoutSubjectInput
  }

  export type subjectUncheckedCreateWithoutConsentsInput = {
    id: string
    isIdentified: boolean
    externalId?: string | null
    identityProvider?: string | null
    lastIpAddress?: string | null
    subjectTimezone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    consentRecords?: consentRecordUncheckedCreateNestedManyWithoutSubjectInput
    auditLogs?: auditLogUncheckedCreateNestedManyWithoutSubjectInput
  }

  export type subjectCreateOrConnectWithoutConsentsInput = {
    where: subjectWhereUniqueInput
    create: XOR<subjectCreateWithoutConsentsInput, subjectUncheckedCreateWithoutConsentsInput>
  }

  export type domainCreateWithoutConsentsInput = {
    id: string
    name: string
    description?: string | null
    allowedOrigins?: InputJsonValue | null
    isVerified: boolean
    isActive: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type domainUncheckedCreateWithoutConsentsInput = {
    id: string
    name: string
    description?: string | null
    allowedOrigins?: InputJsonValue | null
    isVerified: boolean
    isActive: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type domainCreateOrConnectWithoutConsentsInput = {
    where: domainWhereUniqueInput
    create: XOR<domainCreateWithoutConsentsInput, domainUncheckedCreateWithoutConsentsInput>
  }

  export type consentPolicyCreateWithoutConsentsInput = {
    id: string
    version: string
    type: string
    name: string
    effectiveDate: Date | string
    expirationDate?: Date | string | null
    content: string
    contentHash: string
    isActive: boolean
    createdAt?: Date | string
  }

  export type consentPolicyUncheckedCreateWithoutConsentsInput = {
    id: string
    version: string
    type: string
    name: string
    effectiveDate: Date | string
    expirationDate?: Date | string | null
    content: string
    contentHash: string
    isActive: boolean
    createdAt?: Date | string
  }

  export type consentPolicyCreateOrConnectWithoutConsentsInput = {
    where: consentPolicyWhereUniqueInput
    create: XOR<consentPolicyCreateWithoutConsentsInput, consentPolicyUncheckedCreateWithoutConsentsInput>
  }

  export type consentRecordCreateWithoutConsentInput = {
    id: string
    actionType: string
    details?: InputJsonValue | null
    createdAt?: Date | string
    subject: subjectCreateNestedOneWithoutConsentRecordsInput
  }

  export type consentRecordUncheckedCreateWithoutConsentInput = {
    id: string
    subjectId: string
    actionType: string
    details?: InputJsonValue | null
    createdAt?: Date | string
  }

  export type consentRecordCreateOrConnectWithoutConsentInput = {
    where: consentRecordWhereUniqueInput
    create: XOR<consentRecordCreateWithoutConsentInput, consentRecordUncheckedCreateWithoutConsentInput>
  }

  export type consentRecordCreateManyConsentInputEnvelope = {
    data: consentRecordCreateManyConsentInput | consentRecordCreateManyConsentInput[]
  }

  export type subjectUpsertWithoutConsentsInput = {
    update: XOR<subjectUpdateWithoutConsentsInput, subjectUncheckedUpdateWithoutConsentsInput>
    create: XOR<subjectCreateWithoutConsentsInput, subjectUncheckedCreateWithoutConsentsInput>
    where?: subjectWhereInput
  }

  export type subjectUpdateToOneWithWhereWithoutConsentsInput = {
    where?: subjectWhereInput
    data: XOR<subjectUpdateWithoutConsentsInput, subjectUncheckedUpdateWithoutConsentsInput>
  }

  export type subjectUpdateWithoutConsentsInput = {
    isIdentified?: BoolFieldUpdateOperationsInput | boolean
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    identityProvider?: NullableStringFieldUpdateOperationsInput | string | null
    lastIpAddress?: NullableStringFieldUpdateOperationsInput | string | null
    subjectTimezone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consentRecords?: consentRecordUpdateManyWithoutSubjectNestedInput
    auditLogs?: auditLogUpdateManyWithoutSubjectNestedInput
  }

  export type subjectUncheckedUpdateWithoutConsentsInput = {
    isIdentified?: BoolFieldUpdateOperationsInput | boolean
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    identityProvider?: NullableStringFieldUpdateOperationsInput | string | null
    lastIpAddress?: NullableStringFieldUpdateOperationsInput | string | null
    subjectTimezone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consentRecords?: consentRecordUncheckedUpdateManyWithoutSubjectNestedInput
    auditLogs?: auditLogUncheckedUpdateManyWithoutSubjectNestedInput
  }

  export type domainUpsertWithoutConsentsInput = {
    update: XOR<domainUpdateWithoutConsentsInput, domainUncheckedUpdateWithoutConsentsInput>
    create: XOR<domainCreateWithoutConsentsInput, domainUncheckedCreateWithoutConsentsInput>
    where?: domainWhereInput
  }

  export type domainUpdateToOneWithWhereWithoutConsentsInput = {
    where?: domainWhereInput
    data: XOR<domainUpdateWithoutConsentsInput, domainUncheckedUpdateWithoutConsentsInput>
  }

  export type domainUpdateWithoutConsentsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    allowedOrigins?: InputJsonValue | InputJsonValue | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type domainUncheckedUpdateWithoutConsentsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    allowedOrigins?: InputJsonValue | InputJsonValue | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type consentPolicyUpsertWithoutConsentsInput = {
    update: XOR<consentPolicyUpdateWithoutConsentsInput, consentPolicyUncheckedUpdateWithoutConsentsInput>
    create: XOR<consentPolicyCreateWithoutConsentsInput, consentPolicyUncheckedCreateWithoutConsentsInput>
    where?: consentPolicyWhereInput
  }

  export type consentPolicyUpdateToOneWithWhereWithoutConsentsInput = {
    where?: consentPolicyWhereInput
    data: XOR<consentPolicyUpdateWithoutConsentsInput, consentPolicyUncheckedUpdateWithoutConsentsInput>
  }

  export type consentPolicyUpdateWithoutConsentsInput = {
    version?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    content?: StringFieldUpdateOperationsInput | string
    contentHash?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type consentPolicyUncheckedUpdateWithoutConsentsInput = {
    version?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    content?: StringFieldUpdateOperationsInput | string
    contentHash?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type consentRecordUpsertWithWhereUniqueWithoutConsentInput = {
    where: consentRecordWhereUniqueInput
    update: XOR<consentRecordUpdateWithoutConsentInput, consentRecordUncheckedUpdateWithoutConsentInput>
    create: XOR<consentRecordCreateWithoutConsentInput, consentRecordUncheckedCreateWithoutConsentInput>
  }

  export type consentRecordUpdateWithWhereUniqueWithoutConsentInput = {
    where: consentRecordWhereUniqueInput
    data: XOR<consentRecordUpdateWithoutConsentInput, consentRecordUncheckedUpdateWithoutConsentInput>
  }

  export type consentRecordUpdateManyWithWhereWithoutConsentInput = {
    where: consentRecordScalarWhereInput
    data: XOR<consentRecordUpdateManyMutationInput, consentRecordUncheckedUpdateManyWithoutConsentInput>
  }

  export type subjectCreateWithoutAuditLogsInput = {
    id: string
    isIdentified: boolean
    externalId?: string | null
    identityProvider?: string | null
    lastIpAddress?: string | null
    subjectTimezone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    consents?: consentCreateNestedManyWithoutSubjectInput
    consentRecords?: consentRecordCreateNestedManyWithoutSubjectInput
  }

  export type subjectUncheckedCreateWithoutAuditLogsInput = {
    id: string
    isIdentified: boolean
    externalId?: string | null
    identityProvider?: string | null
    lastIpAddress?: string | null
    subjectTimezone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    consents?: consentUncheckedCreateNestedManyWithoutSubjectInput
    consentRecords?: consentRecordUncheckedCreateNestedManyWithoutSubjectInput
  }

  export type subjectCreateOrConnectWithoutAuditLogsInput = {
    where: subjectWhereUniqueInput
    create: XOR<subjectCreateWithoutAuditLogsInput, subjectUncheckedCreateWithoutAuditLogsInput>
  }

  export type subjectUpsertWithoutAuditLogsInput = {
    update: XOR<subjectUpdateWithoutAuditLogsInput, subjectUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<subjectCreateWithoutAuditLogsInput, subjectUncheckedCreateWithoutAuditLogsInput>
    where?: subjectWhereInput
  }

  export type subjectUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: subjectWhereInput
    data: XOR<subjectUpdateWithoutAuditLogsInput, subjectUncheckedUpdateWithoutAuditLogsInput>
  }

  export type subjectUpdateWithoutAuditLogsInput = {
    isIdentified?: BoolFieldUpdateOperationsInput | boolean
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    identityProvider?: NullableStringFieldUpdateOperationsInput | string | null
    lastIpAddress?: NullableStringFieldUpdateOperationsInput | string | null
    subjectTimezone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consents?: consentUpdateManyWithoutSubjectNestedInput
    consentRecords?: consentRecordUpdateManyWithoutSubjectNestedInput
  }

  export type subjectUncheckedUpdateWithoutAuditLogsInput = {
    isIdentified?: BoolFieldUpdateOperationsInput | boolean
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    identityProvider?: NullableStringFieldUpdateOperationsInput | string | null
    lastIpAddress?: NullableStringFieldUpdateOperationsInput | string | null
    subjectTimezone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consents?: consentUncheckedUpdateManyWithoutSubjectNestedInput
    consentRecords?: consentRecordUncheckedUpdateManyWithoutSubjectNestedInput
  }

  export type subjectCreateWithoutConsentRecordsInput = {
    id: string
    isIdentified: boolean
    externalId?: string | null
    identityProvider?: string | null
    lastIpAddress?: string | null
    subjectTimezone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    consents?: consentCreateNestedManyWithoutSubjectInput
    auditLogs?: auditLogCreateNestedManyWithoutSubjectInput
  }

  export type subjectUncheckedCreateWithoutConsentRecordsInput = {
    id: string
    isIdentified: boolean
    externalId?: string | null
    identityProvider?: string | null
    lastIpAddress?: string | null
    subjectTimezone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    consents?: consentUncheckedCreateNestedManyWithoutSubjectInput
    auditLogs?: auditLogUncheckedCreateNestedManyWithoutSubjectInput
  }

  export type subjectCreateOrConnectWithoutConsentRecordsInput = {
    where: subjectWhereUniqueInput
    create: XOR<subjectCreateWithoutConsentRecordsInput, subjectUncheckedCreateWithoutConsentRecordsInput>
  }

  export type consentCreateWithoutConsentRecordsInput = {
    id: string
    purposeIds: InputJsonValue
    metadata?: InputJsonValue | null
    ipAddress?: string | null
    userAgent?: string | null
    status: string
    withdrawalReason?: string | null
    givenAt?: Date | string
    validUntil?: Date | string | null
    isActive: boolean
    subject: subjectCreateNestedOneWithoutConsentsInput
    domain: domainCreateNestedOneWithoutConsentsInput
    policy?: consentPolicyCreateNestedOneWithoutConsentsInput
  }

  export type consentUncheckedCreateWithoutConsentRecordsInput = {
    id: string
    subjectId: string
    domainId: string
    policyId?: string | null
    purposeIds: InputJsonValue
    metadata?: InputJsonValue | null
    ipAddress?: string | null
    userAgent?: string | null
    status: string
    withdrawalReason?: string | null
    givenAt?: Date | string
    validUntil?: Date | string | null
    isActive: boolean
  }

  export type consentCreateOrConnectWithoutConsentRecordsInput = {
    where: consentWhereUniqueInput
    create: XOR<consentCreateWithoutConsentRecordsInput, consentUncheckedCreateWithoutConsentRecordsInput>
  }

  export type subjectUpsertWithoutConsentRecordsInput = {
    update: XOR<subjectUpdateWithoutConsentRecordsInput, subjectUncheckedUpdateWithoutConsentRecordsInput>
    create: XOR<subjectCreateWithoutConsentRecordsInput, subjectUncheckedCreateWithoutConsentRecordsInput>
    where?: subjectWhereInput
  }

  export type subjectUpdateToOneWithWhereWithoutConsentRecordsInput = {
    where?: subjectWhereInput
    data: XOR<subjectUpdateWithoutConsentRecordsInput, subjectUncheckedUpdateWithoutConsentRecordsInput>
  }

  export type subjectUpdateWithoutConsentRecordsInput = {
    isIdentified?: BoolFieldUpdateOperationsInput | boolean
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    identityProvider?: NullableStringFieldUpdateOperationsInput | string | null
    lastIpAddress?: NullableStringFieldUpdateOperationsInput | string | null
    subjectTimezone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consents?: consentUpdateManyWithoutSubjectNestedInput
    auditLogs?: auditLogUpdateManyWithoutSubjectNestedInput
  }

  export type subjectUncheckedUpdateWithoutConsentRecordsInput = {
    isIdentified?: BoolFieldUpdateOperationsInput | boolean
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    identityProvider?: NullableStringFieldUpdateOperationsInput | string | null
    lastIpAddress?: NullableStringFieldUpdateOperationsInput | string | null
    subjectTimezone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consents?: consentUncheckedUpdateManyWithoutSubjectNestedInput
    auditLogs?: auditLogUncheckedUpdateManyWithoutSubjectNestedInput
  }

  export type consentUpsertWithoutConsentRecordsInput = {
    update: XOR<consentUpdateWithoutConsentRecordsInput, consentUncheckedUpdateWithoutConsentRecordsInput>
    create: XOR<consentCreateWithoutConsentRecordsInput, consentUncheckedCreateWithoutConsentRecordsInput>
    where?: consentWhereInput
  }

  export type consentUpdateToOneWithWhereWithoutConsentRecordsInput = {
    where?: consentWhereInput
    data: XOR<consentUpdateWithoutConsentRecordsInput, consentUncheckedUpdateWithoutConsentRecordsInput>
  }

  export type consentUpdateWithoutConsentRecordsInput = {
    purposeIds?: InputJsonValue | InputJsonValue
    metadata?: InputJsonValue | InputJsonValue | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    withdrawalReason?: NullableStringFieldUpdateOperationsInput | string | null
    givenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subject?: subjectUpdateOneRequiredWithoutConsentsNestedInput
    domain?: domainUpdateOneRequiredWithoutConsentsNestedInput
    policy?: consentPolicyUpdateOneWithoutConsentsNestedInput
  }

  export type consentUncheckedUpdateWithoutConsentRecordsInput = {
    subjectId?: StringFieldUpdateOperationsInput | string
    domainId?: StringFieldUpdateOperationsInput | string
    policyId?: NullableStringFieldUpdateOperationsInput | string | null
    purposeIds?: InputJsonValue | InputJsonValue
    metadata?: InputJsonValue | InputJsonValue | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    withdrawalReason?: NullableStringFieldUpdateOperationsInput | string | null
    givenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SessionCreateManyUserInput = {
    id: string
    expiresAt: Date | string
    token: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
  }

  export type AccountCreateManyUserInput = {
    id: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BlogPostCreateManyAuthorInput = {
    id?: string
    title: string
    slug: string
    excerpt: string
    content: string
    image: string
    published?: boolean
    categories?: BlogPostCreatecategoriesInput | string[]
    tags?: BlogPostCreatetagsInput | string[]
    views?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoadmapItemCreateManyAuthorInput = {
    id?: string
    title: string
    slug: string
    excerpt: string
    content: string
    featuredImage: string
    gallery?: RoadmapItemCreategalleryInput | string[]
    youtubeVideoId?: string | null
    displayDate?: Date | string | null
    published?: boolean
    categories?: RoadmapItemCreatecategoriesInput | string[]
    tags?: RoadmapItemCreatetagsInput | string[]
    views?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionUpdateWithoutUserInput = {
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUpdateWithoutUserInput = {
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateWithoutUserInput = {
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateManyWithoutUserInput = {
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogPostUpdateWithoutAuthorInput = {
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    excerpt?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    categories?: BlogPostUpdatecategoriesInput | string[]
    tags?: BlogPostUpdatetagsInput | string[]
    views?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogPostUncheckedUpdateWithoutAuthorInput = {
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    excerpt?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    categories?: BlogPostUpdatecategoriesInput | string[]
    tags?: BlogPostUpdatetagsInput | string[]
    views?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogPostUncheckedUpdateManyWithoutAuthorInput = {
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    excerpt?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    categories?: BlogPostUpdatecategoriesInput | string[]
    tags?: BlogPostUpdatetagsInput | string[]
    views?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoadmapItemUpdateWithoutAuthorInput = {
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    excerpt?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    featuredImage?: StringFieldUpdateOperationsInput | string
    gallery?: RoadmapItemUpdategalleryInput | string[]
    youtubeVideoId?: NullableStringFieldUpdateOperationsInput | string | null
    displayDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    categories?: RoadmapItemUpdatecategoriesInput | string[]
    tags?: RoadmapItemUpdatetagsInput | string[]
    views?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoadmapItemUncheckedUpdateWithoutAuthorInput = {
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    excerpt?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    featuredImage?: StringFieldUpdateOperationsInput | string
    gallery?: RoadmapItemUpdategalleryInput | string[]
    youtubeVideoId?: NullableStringFieldUpdateOperationsInput | string | null
    displayDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    categories?: RoadmapItemUpdatecategoriesInput | string[]
    tags?: RoadmapItemUpdatetagsInput | string[]
    views?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoadmapItemUncheckedUpdateManyWithoutAuthorInput = {
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    excerpt?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    featuredImage?: StringFieldUpdateOperationsInput | string
    gallery?: RoadmapItemUpdategalleryInput | string[]
    youtubeVideoId?: NullableStringFieldUpdateOperationsInput | string | null
    displayDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    categories?: RoadmapItemUpdatecategoriesInput | string[]
    tags?: RoadmapItemUpdatetagsInput | string[]
    views?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type consentCreateManySubjectInput = {
    id: string
    domainId: string
    policyId?: string | null
    purposeIds: InputJsonValue
    metadata?: InputJsonValue | null
    ipAddress?: string | null
    userAgent?: string | null
    status: string
    withdrawalReason?: string | null
    givenAt?: Date | string
    validUntil?: Date | string | null
    isActive: boolean
  }

  export type consentRecordCreateManySubjectInput = {
    id: string
    consentId?: string | null
    actionType: string
    details?: InputJsonValue | null
    createdAt?: Date | string
  }

  export type auditLogCreateManySubjectInput = {
    id: string
    entityType: string
    entityId: string
    actionType: string
    ipAddress?: string | null
    userAgent?: string | null
    changes?: InputJsonValue | null
    metadata?: InputJsonValue | null
    createdAt?: Date | string
    eventTimezone: string
  }

  export type consentUpdateWithoutSubjectInput = {
    purposeIds?: InputJsonValue | InputJsonValue
    metadata?: InputJsonValue | InputJsonValue | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    withdrawalReason?: NullableStringFieldUpdateOperationsInput | string | null
    givenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    domain?: domainUpdateOneRequiredWithoutConsentsNestedInput
    policy?: consentPolicyUpdateOneWithoutConsentsNestedInput
    consentRecords?: consentRecordUpdateManyWithoutConsentNestedInput
  }

  export type consentUncheckedUpdateWithoutSubjectInput = {
    domainId?: StringFieldUpdateOperationsInput | string
    policyId?: NullableStringFieldUpdateOperationsInput | string | null
    purposeIds?: InputJsonValue | InputJsonValue
    metadata?: InputJsonValue | InputJsonValue | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    withdrawalReason?: NullableStringFieldUpdateOperationsInput | string | null
    givenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    consentRecords?: consentRecordUncheckedUpdateManyWithoutConsentNestedInput
  }

  export type consentUncheckedUpdateManyWithoutSubjectInput = {
    domainId?: StringFieldUpdateOperationsInput | string
    policyId?: NullableStringFieldUpdateOperationsInput | string | null
    purposeIds?: InputJsonValue | InputJsonValue
    metadata?: InputJsonValue | InputJsonValue | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    withdrawalReason?: NullableStringFieldUpdateOperationsInput | string | null
    givenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type consentRecordUpdateWithoutSubjectInput = {
    actionType?: StringFieldUpdateOperationsInput | string
    details?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consent?: consentUpdateOneWithoutConsentRecordsNestedInput
  }

  export type consentRecordUncheckedUpdateWithoutSubjectInput = {
    consentId?: NullableStringFieldUpdateOperationsInput | string | null
    actionType?: StringFieldUpdateOperationsInput | string
    details?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type consentRecordUncheckedUpdateManyWithoutSubjectInput = {
    consentId?: NullableStringFieldUpdateOperationsInput | string | null
    actionType?: StringFieldUpdateOperationsInput | string
    details?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type auditLogUpdateWithoutSubjectInput = {
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    actionType?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    changes?: InputJsonValue | InputJsonValue | null
    metadata?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eventTimezone?: StringFieldUpdateOperationsInput | string
  }

  export type auditLogUncheckedUpdateWithoutSubjectInput = {
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    actionType?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    changes?: InputJsonValue | InputJsonValue | null
    metadata?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eventTimezone?: StringFieldUpdateOperationsInput | string
  }

  export type auditLogUncheckedUpdateManyWithoutSubjectInput = {
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    actionType?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    changes?: InputJsonValue | InputJsonValue | null
    metadata?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eventTimezone?: StringFieldUpdateOperationsInput | string
  }

  export type consentCreateManyDomainInput = {
    id: string
    subjectId: string
    policyId?: string | null
    purposeIds: InputJsonValue
    metadata?: InputJsonValue | null
    ipAddress?: string | null
    userAgent?: string | null
    status: string
    withdrawalReason?: string | null
    givenAt?: Date | string
    validUntil?: Date | string | null
    isActive: boolean
  }

  export type consentUpdateWithoutDomainInput = {
    purposeIds?: InputJsonValue | InputJsonValue
    metadata?: InputJsonValue | InputJsonValue | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    withdrawalReason?: NullableStringFieldUpdateOperationsInput | string | null
    givenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subject?: subjectUpdateOneRequiredWithoutConsentsNestedInput
    policy?: consentPolicyUpdateOneWithoutConsentsNestedInput
    consentRecords?: consentRecordUpdateManyWithoutConsentNestedInput
  }

  export type consentUncheckedUpdateWithoutDomainInput = {
    subjectId?: StringFieldUpdateOperationsInput | string
    policyId?: NullableStringFieldUpdateOperationsInput | string | null
    purposeIds?: InputJsonValue | InputJsonValue
    metadata?: InputJsonValue | InputJsonValue | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    withdrawalReason?: NullableStringFieldUpdateOperationsInput | string | null
    givenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    consentRecords?: consentRecordUncheckedUpdateManyWithoutConsentNestedInput
  }

  export type consentUncheckedUpdateManyWithoutDomainInput = {
    subjectId?: StringFieldUpdateOperationsInput | string
    policyId?: NullableStringFieldUpdateOperationsInput | string | null
    purposeIds?: InputJsonValue | InputJsonValue
    metadata?: InputJsonValue | InputJsonValue | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    withdrawalReason?: NullableStringFieldUpdateOperationsInput | string | null
    givenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type consentCreateManyPolicyInput = {
    id: string
    subjectId: string
    domainId: string
    purposeIds: InputJsonValue
    metadata?: InputJsonValue | null
    ipAddress?: string | null
    userAgent?: string | null
    status: string
    withdrawalReason?: string | null
    givenAt?: Date | string
    validUntil?: Date | string | null
    isActive: boolean
  }

  export type consentUpdateWithoutPolicyInput = {
    purposeIds?: InputJsonValue | InputJsonValue
    metadata?: InputJsonValue | InputJsonValue | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    withdrawalReason?: NullableStringFieldUpdateOperationsInput | string | null
    givenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subject?: subjectUpdateOneRequiredWithoutConsentsNestedInput
    domain?: domainUpdateOneRequiredWithoutConsentsNestedInput
    consentRecords?: consentRecordUpdateManyWithoutConsentNestedInput
  }

  export type consentUncheckedUpdateWithoutPolicyInput = {
    subjectId?: StringFieldUpdateOperationsInput | string
    domainId?: StringFieldUpdateOperationsInput | string
    purposeIds?: InputJsonValue | InputJsonValue
    metadata?: InputJsonValue | InputJsonValue | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    withdrawalReason?: NullableStringFieldUpdateOperationsInput | string | null
    givenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    consentRecords?: consentRecordUncheckedUpdateManyWithoutConsentNestedInput
  }

  export type consentUncheckedUpdateManyWithoutPolicyInput = {
    subjectId?: StringFieldUpdateOperationsInput | string
    domainId?: StringFieldUpdateOperationsInput | string
    purposeIds?: InputJsonValue | InputJsonValue
    metadata?: InputJsonValue | InputJsonValue | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    withdrawalReason?: NullableStringFieldUpdateOperationsInput | string | null
    givenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type consentRecordCreateManyConsentInput = {
    id: string
    subjectId: string
    actionType: string
    details?: InputJsonValue | null
    createdAt?: Date | string
  }

  export type consentRecordUpdateWithoutConsentInput = {
    actionType?: StringFieldUpdateOperationsInput | string
    details?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subject?: subjectUpdateOneRequiredWithoutConsentRecordsNestedInput
  }

  export type consentRecordUncheckedUpdateWithoutConsentInput = {
    subjectId?: StringFieldUpdateOperationsInput | string
    actionType?: StringFieldUpdateOperationsInput | string
    details?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type consentRecordUncheckedUpdateManyWithoutConsentInput = {
    subjectId?: StringFieldUpdateOperationsInput | string
    actionType?: StringFieldUpdateOperationsInput | string
    details?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}